---
title: "let, const & BlockLevelScope"
date: 2020-09-23 19:53:38
category: "javascript"
draft: false
---

# let, const와 블록 레벨 스코프

## 1. var 키워드로 선언한 변수의 문제점

**ES5 까지의 변수 선언**

ES5까지 변수를 선언할 수 있는 유일한 방법은 var 키워들ㄹ 사용하는 것이었다. var 키워드로 선언된 변수는 다른 언어와는 구별되는 독특한 특징이 있으며, 주의를 기울이지 않으면 심각한 문제를 발생시킬 수 있다.

### 1.1 변수 중복 선언 허용

**중복 선언시 var 키워드가 없는 것처럼 동작**

var 키워드로 선언한 변수는 중복선언이 가능하다.

- 같은 스코프 내에서 중복 선언이 가능하다.
- 초기화문이 있는 변수 선언문은 자바 스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작한다.
- 초기화문이 없는 변수 선언문을 중복선언하면 무시된다.

```
var x = 1;
var y = 1;

//같은 스코프 내 중복 선언 허용
// var 키워드가 없는 것처럼 동작
var x = 100;

//초기화 문이 없으면 무시, 에러x
var y;

//x : 100, y : 1
```

**문제점**

동일한 이름의 변수가 이미 선언되어 있는 것을 모르고 변수를 중복 선언 하면서 값까지 할당했다면 의도치 않게 먼저 선언된 변수 값이 변경 되는 부작용 발생

### 1.2 함수 레벨 스코프

**함수의 코드 블록만을 스코프로 인정**

var 키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다. 따라서 함수 외부에서 var 키워드로 선언한 변수는 코드 블록 내에서 선언해도 모두 전역 변수가 된다.

```
var x = 1;

//함수 외 코드블록은 스코프로 인정하지 않는다.
//x 변수 중복된다
if(true) {
	var x = 10;
}

console.log(x); //10

//for 문도 마찬가지
for(var i = 0; i<5; i++){
console.log(i); //0 1 2 3 4
}

```

**문제점**

함수 레벨 스코프를 인지 못하고 전역 변수를 선언하게 된다. 그러면 의도치 않게 변수값을 변경할 수 있다.

### 1.3 변수 호이스팅

**변수 호이스팅으로 초기화까지 일어난다.**

var 키워드로 변수를 선언하면 변수 호이스팅에 의해 변수 선언문이 스코프의 선두로 끌어 올려진 것처럼 동작한다. 즉, 변수 호이스팅에 의해 var 키워드로 선언한 변수는 변수 선언문 이전에 참조할 수 있다. 변수 할당문 이전에 변수를 참조하면 undefined를 반환한다.

```
console.log(num);//undefined

num = 100;

console.log(num);100

var num;
```

**var 변수 호이스팅의 문제점**

변수 선언문 이전에 변수를 참조하는 것은 변수 호이스팅에 의해 에러를 발생시키지는 않는다 하지만 다음과 같은 문제가 있다.

- 프로그램의 흐름상 맞지 않다.
- 가독성을 떨어뜨린다.
- 오류 발생 가능성이 높아진다.

## 2. let 키워드

**let 과 const의 도입**

var 키워드의 여러 문제점을 보완하기 위해서 ES6에서는 새로운 변수 선언 키워드가 추가 되었다.

- let
- const

var 키워드와의 차이를 알아보자

### 2.1 변수 중복 선언 금지

**let 키워드는 중복 선언 미허용**

var 키워드로 이름이 동일한 변수를 중복 선언하면 아무런 에러를 발생하지 않는다. 인간은 실수하는 동물이기에 의도치않게, 실수로 값을 재할당 할 수도 있다. 즉, 오류 발생 가능성이 높아진다.

let 키워드의 경우 이름이 같은 변수를 중복 선언 하면 문법 에러(SyntaxError) 를 발생시킨다.

```
var num1 = 100;
var num1 = 200;
//var 키워드로 선언된 변수는 중복선언 허용
//중복 선언시 var 키워드가 없는 것처럼 동작


let num2 = 123;
let num2 = 456;
 // let이나 const 키워드로 선언한 변수는 중복선언을 허용하지 않는다.
```

### 2.2 블록 레벨 스코프

**let , const 키워드는 블록 레벨 스코프를 따른다**

var 키워드로 선언된 변수는 오로지 함수의 코드 블록만을 지역 스코프를 따른다. 하지만 let 키워드로 선언한 변수는 모든 코드블록을 지역 스코프로 인정한다. (함수, if 문, while 문, try/catch) 등을 지역 스코프로 인정하는 블록레벨 스코프를 따른다.

```
let num = 1;
{
	let num = 2;
	let bar = 3;
}

console.log(num); //2
console.log(bar); // ReferenceError


```

### 2.3 변수 호이스팅

**let 키워드로 선언한 변수의 호이스팅**

var 키워드로 선언한 변수와 달리 let 키워드로 선언한 변수는 변수호이스팅이 발생하지 않는 것처럼 동작한다.

```
console.log(a); //ReferenceError
let foo;
```

위와 같이 let 키워드로 선언한 변수를 선언문 이전에 참조하면 참조에러가 발생한다.

**이유**

**기존의 var 키워드의 변수 선언**

var 키워드로 선언한 변수는 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 선언단계와 초기화단계가 **한번에** 진행된다

1. 선언 단계에서 실행 컨텍스트의 렉시컬 환경에 변수 식별자를 등록해 자바스크립트 엔진에 변수의 존재를 알린다.
2. 초기화 단계에서 undefined로 변수를 초기화한다.

따라서 변수 선언문 이전에 변수에 접근해도 에러가 발생하지 않는다. 다만 의도한 값대신 undefined가 할당되어 있다.

**let 키워드의 선언단계와 초기화 단계**

let 키워드로 선언한 변수는 선언단계와 초기화 단계가 분리되어 진행된다.

1. 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 선언 단계 실행
2. **런타임**이 되어 변수선언문에 도달했을때 초기화 단계 실행

런타임 이전에 초기화 단계를 실행 하지않으므로 변수선언문 이전에 참조하려고 하면 참조 에러가 발생한다.

**일시적 사각지대란**

let 키워드로 선언한 변수는 스코프의 시작 지점부터 초기화단계 시작 지점까지 변수를 참조할 수 없다.

스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간을 **일시적 사각지대(Temporal Dead Zone; TDZ)**라고 부른다.

```
//일시적 사각지대
console.log(foo); //ReferenceError

// ""
let foo;

```

**let 키워드의 변수 호이스팅**

let 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는 것 같지만 그렇지 않다.

```
let bar = 1;

{
	console.log(bar); //ReferenceError

	let bar =10;
}

```

만일 변수 호이스팅이 발생하지 않는다면 bar를 출력했을때 전역에서 할당한 1이 출력되어야 정상이지만, 참조에러가 발생한다.

let 키워드도 스코프 시작전에 선언단계, 초기화단계 중 선언단계는 진행하기 때문이다.

### 2.4 전역 객체와 let

**var 키워드로 선언한 변수는 전역 객체의 프로퍼티가 된다.**

var 키워드로 선언한 전역 변수, 전역 함수와 암묵적 전역은 전역 객체 window or global의 프로퍼티가 된다. 전역 객체의 프로퍼티를 참조할 땐 window를 생략가능하다.

```
// 전역변수
var foo;

// 전역 함수
fuction bar()

// 암묵적 전역
x = 1

//위 모두 전역 객체 window의 프로퍼티
//선언 및 참조 시 window 식별자는 생략 가능
```

**let 키워드는 전역 객체의 프로퍼티가 아니다.**

let 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아닌, 전역 렉시컬 환경의 선언적 환경 레코드에 존재하게 된다.

## 3. const 키워드

### 3.1 선언과 초기화

**const 키워드로 선언한 변수는 선언과 동시에 초기화한다.**

```
const foo = 1;

const bar; // SyntaxError
```

초기화 없이 선언만 하면 문법 에러가 발생한다.

**const, 스코프와 호이스팅**

const 키워드로 선언한 변수는 블록레벨 스코프를 가지며, 변수호이스팅이 발생하지 않는 것처럼 동작한다.

### 3.2 재할당 금지

**const 키워드로 선언한 변수는 재할당이 금지된다.**

```
const foo = 10;

foo = 5;// TypeError
```

### 3.3 상수

**const 키워드의 이용**

원시값은 immutable value 이다. 그리고 const 키워드로 선언한 변수에 원시값을 할당한다면 **재할당 없이** 변수값을 변경할 수 없다. 그렇기 때문에 const 키워드를 이용해 상수를 표현할 수 있다.

**상수의 뜻**

변수의 상대 개념인 상수는 재할당이 금지된 변수를 말한다. 상수도 값을 저장하기 위한 메모리 공간이 필요하므로 변수이다. 일반적인 변수와는 달리 재할당이 금지된다.

**상수의 장점**

- 상태를 유지한다
- 가독성이 높아진다
- 유지보수가 편하다.

```
// 세율같은 경우 쉽게 변하지 않으며, 고정값을 사용해야 한다.
const TAX_RATE = 0,1;
let preTaxPrice = 100;

let afterTaxPrice = preTaxPrice + (preTaxPrice * TAX_RATE)
```

const 키워드로 선언한 변수에 원시값을 할당한다면 선언문 이후에 값을 변경할 수 없으며 상태가 유지된다.

또한 세율을 상수로 정의하여 의미를 쉽게 알 수 있다. 즉 가독성이 높아진다.

세율이 변경된다면 상수만을 변경하면 되므로 유지 보수성이 향상된다.

**상수의 일반적인 표기**

상수의 이름은 대문자로 선언해 상수임을 명확히 나타낸다.

여러개의 단어로 이루어진 경우 언더스코어로 구분한 스네이크 케이스로 표현한다.

### 3.3 const 키워드와 객체

**객체의 경우 값의 변경이 가능하다.**

원시값의 경우 불변값이기 때문에 재할당없이 값의 변경이 불가하며, const로 선언한 경우 재할당까지도 불가하다.

하지만, 객체의 경우 가변 값 (mutable value) 이기 때문에 재할당없이도 값을 변경할 수 있다.

const 키워드는 재할당을 금지할 뿐이다. 객체는 자유롭게 변경될 수 있다.

```
const student = {
	name: 'Jiman',
	age: 23
};

student.age = 24;
console.log(student)// {name: 'jiman', age: 24}
```

## 4. var vs. let vs. const

**const 사용을 지향하자**

변수 선언에는 기본적으로 const를 사용하고 let은 재할당이 필요한 경우에만 사용하도록 하자.

**이유**

- 변수를 선언하는 시점에는 재할당이 필요할 지 잘모르는 경우가 많다.
- 객체는 재할당하는 경우가 드물다
- 재할당이 꼭 필요하다면 그때 let 으로 바꾸자

**ES6 이상인 경우 var은 사용하지 말자**
