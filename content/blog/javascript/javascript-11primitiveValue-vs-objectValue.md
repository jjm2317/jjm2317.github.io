---
title: javascript 11primitiveValue vs objectValue
date: 2020-09-01 22:08:08
category: "javascript"
draft: false
---

# 원시값과 객체의 비교

자바스크립트에는 7가지 데이터 타입이 있었다. 그리고 그 데이터 타입은 **원시타입(primitive type)** 과 **객체타입(object/reference type)** 으로 분류되었다.

- 원시 타입
  - number
  - string
  - boolean
  - undefined
  - null
  - symbol
- 객체 타입
  - 함수, 객체 등등

원시 타입에서도 number, string 등 데이터 타입을 나누어 놓은 이유가 존재하였다. 자세한 내용은 데이터타입 포스팅에서 다루었다.

원시타입과 객체 타입을 나누어 놓은 이유는 무엇일까? 두 타입의 차이점을 먼저 짚어보자. 크게 3가지 측면에서 차이가 있다.

- 원시 타입의 값, 즉 원시값은 변경 불가능한 값(immutable value)이다. 객체는 변경 가능한 값(mutable value)이다.
  - 변수에 저장된 값을 변경하고자할때, 원시값은 변경불가하기때문에 재할당에 의해 변경해야되지만, 객체는 재할당없이 값을 변경 가능하다.
- 원시값을 변수에 할당하면 변수에 실제값이 저장된다. 이에 비해 객체를 변수에 할당하면 변수에는 참조값이 저장이된다.
  - 참조값은 객체 값을 저장한 메모리 주소를 가리킨다.
- 원시값을 갖는 변수를 다른 변수에 할당하면 원본의 **원시값이** **복사**되어 전달된다.이를 값에 의한 전달 (pass by value) 라고 한다. 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 **참조값이 복사**되어 전달된다. 이를 참조에 의한 전달(pass by reference) 이라고 한다.

즉 변경 가능성, 저장값, 전달 방식에서 차이가 있다.

이 관점에서 원시 값과 객체를 분석해보자

## 1. 원시값

### 1.1 원시값은 변경 불가능한 값이다.

원시타입(primitive type)의 값, 원시값은 변경 불가능한 값 (immutable value) 이다.

한번 생성된 원시 값은 읽기 전용(read only) 값으로서 변경할 수 없다.

`값을 변경할 수 없다?`

값은 표현식이 평가되어 생성된 결과로 메모리에 저장되어 있다. 메모리에 저장된 값은 변경 불가능하다는 뜻이다.

헷갈릴 수 있는 개념에 대해 짚고 넘어가보자. 변수와 값은 구분해서 생각해야하낟.

- 변수 : 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름
- 값 : 변수에 저장된 데이터로서 표현식이 평가되어 생성된 결과

변경 불가 하다는 것은 변수가 아니라 값에 대한 진술이다.

원시값은 변경 불가능하다는 말은 **원시값 자체를 변경할 수 없다**는 것이지 변수 값을 변경할 수 없다는 것이 아니다.

다만, **변수의 값이 변경**되는 것은 원시값 자체의 변화가 아닌, 재할당을 통해 **새로 생성된 원시값을 변수에 할당**하는 것이다. 즉 엄밀히 말해서는 변수의 값이 교체되는 것이다.

그렇다면 변수의 상대개념인 상수는 어떨까?

상수는 **재할당이 금지된 변수**이다. 상수도 값을 저장하기 위한 메모리 공간이 필요하므로 변수라고 할 수 있다. 다만 변수는 재할당을 통해 변수 값을 변경(교체)할 수 있지만 상수는 단 한번만 할당이 허용되므로 변수 값을 변경(교체)할 수 없다. 이처럼 상수는 재할당이 금지된 **변수**일 뿐이지, 변경 불가능한 값의 범주에 포함시키지는 않는다.

```
// 상수는 immutable한 값이 아닌 재할당이 금지된 변수이다.
// 상수에 객체를 할당할 시 변경 가능하다는 예시가 있다.

const obj = {};

obj.key = 'value';
console.log(obj);
//{key: value}
```

`변수의 재할당은 어떻게 일어날까?`

원시값은 변경 불가능한 값이다. 변수에 재할당을 하게되면 원시값이 저장된 메모리공간으로 접근해서 값을 변경하는 것이 아니다.

```
var num = 10;
//값의 재할당
num = 5;
```

num이라는 변수에 10이라는 숫자가 저장되어 있다. 5를 재할당 할 경우 10 이 저장되어 있는 메모리공간으로 접근해서 **값을 변경하는 것이 아니라 새로운 메모리 공간을 확보**해서 5를 저장한 후 num이라는 변수 이름을 연결해준다. 10은 가비지 컬렉터에 의해 메모리공간확보가 해제된다.

이렇게 처리하는 이유는 컴퓨터 입장에서 편하기 때문이다.

원시값의 이러한 특성을 불변성(immutaility)라고 한다. 불변성을 갖는 원시값을 할당한 변수는 재할당 의외에 변수 값을 변경할 수 있는 방법이 없다.

### 1.2 문자열과 불변성

원시값을 메모리 공간에 저장하기 위해서는, **확보해야 하는 메모리 공간의 크기를 결정해야한다**. 원시타입 별로 확보해야하는 메모리 공간의 크기가 정해져 있는 것이다. ECMAScript 사양을 보면 문자열 타입 (2byte)와 숫자타입(8byte)는 메모리공간의 크기가 명시되어있는 반면에 다른 원시타입은 명시 되어있지 않고 브라우저 제조사의 구현에따라 다를 수 있다.

문자열 값은 다른 원시값과 비교해 독특한 특징이 있다.

- 문자열은 0개 이상의 문자(character)로 이뤄진 집합이다.
- 1개의 문자는 2byte의 메모리 공간에 저장된다.
- 문자열은 몇 개의 문자로 이뤄졌느냐에 따라 필요한 메모리 공간의 크기가 결정된다.

즉, 문자열은 확보해야하는 메모리공간의 크기가 고정된 다른 원시값과 다르게 **문자의 개수에 따라 확보되는 메모리공간의 크기가 다르다**. 1개의 문자로 된 문자열은 2byte, 5개의 문자로 이뤄진 문자열은 10byte가 필요하다.(실제 계산은 다르긴하다.)

```
var str1 = '';
var str2 = 'jiman';
//필요한 메모리 공간의 크기가 다르다.
```

C와 자바에서는 문자열 데이터 타입이 따로 없다.

c에서는 문자타입(char)들의 배열로 문자열을 처리하고, 자바에서는 String 객체로 문자열을 처리한다.

자바스크립트에서는 string이라는 데이터 타입을 제공하는 것이다. 데이터의 신뢰성을 보장하는, 자바스크립트의 장점이다.

원시타입인 문자열 역시 변경 불가능하다.

문자열에는 독특한 특징이 하나 더 있는데 바로 유사 배열 객체 (array-like-object)라는 것이다.

**유사 배열 객체란?**

배열 처럼 인덱스로 프로퍼티 값에 접근할 수 있으며, length 프로퍼티를 갖는 객체이다.

즉 문자열은 인덱스로 각 문자 하나하나 에 접근할 수 있고 length 프로퍼티도 갖는다. for 문으로 순회하는 것도 가능하다.

다만 원시값인 문자열을 객체처럼 사용하면 원시값을 감싸는 래퍼 객체로 자동 변환된다.

**문자열은 변경 불가능한 원시값이다.**

```
var str = 'jiman';
str[0] = 'J';
console.log(str[0]);
//jiman

//원시값이기때문에 개별문자의 변경이 불가하다.
```

### 1.3 값에 의한 전달(pass by value)

어떤 변수에 기존에 원시값을 할당했던 변수를 할당하면 어떻게 될까?

```
var original = 10;
var copy = original;

console.log(original, copy);// 10 10

original = 20;

console.log(original, copy); 20 10
```

copy에 original을 할당할때 original이 10으로 평가되어 새로운메모리 공간을 확보하고 10을 저장한 후 copy를 연결한다. 즉, copy에는 original의 원시값이 복사되어 전달된다. 이를 값에의한전달 이라고 한다.

```
var original = 10;
var copy = original;

console.log( original, copy); // 10 10
console.log(original === copy); // true

orignal = 20;
console.log( original === copy); // false
```

original 과 copy는 평가되었을때 동일한 숫자 값이지만, 두 값을 저장한 메모리공간의 위치는 다르다. 즉 orignal과 copy에 저장된 값은 별개의 값이다.

ECMAScript 사양에 변수를 통한 메모리 관리가 명확히 정의되지 않아서 값에 의한 전달시 두가지 경우가 있을 수 있다.

- 식별자를 할당했을때 같은 원시값을 참조하였다가 재할당시 새로운 생성값을 참조
- 식별자 할당시부터 새로운 메모리공간 생성후 평가값저장후 참조

파이썬은 전자처럼 동작한다고 한다. 할당 시점에 두 변수가 기억하는 메모리주소가 같느냐 다르냐이다.

**중요한것은 두 변수의 원시값이 결국엔 서로다른 메모리 공간에 저장된 다는 것이다.** 서로 간섭하지 않는다.

## 2. 객체

객체 값을 생성할때 메모리공간의 크기는 어떻게 될까?

객체는 다음과 같은 특징이있다.

- 객체는 프로퍼티의 개수가 고정되어 있지 않고, 동적으로 추가되고 삭제될 수 있다.
- 프로퍼티 값에 제약이 없다.
- 즉, 원시값과 같이 확보해야할 메모리 공간의 크기를 사전에 정해 둘 수 없다.

객체는 복합적인 자료구조이다. 원시값과 비교하였을 때 복잡하고 브라우저 제조사마다 구현방식이 다를 수 있댜. 소비하는 메모리가 상대적으로 적은 원시값에 비해, 객체는 소비하는 메모리가 경우에 따라 매우 클 수 있다.

객체를 생성하고 프로퍼티에 접근하는 것도 원시값과 비교할 때 비용이 많이든다.

### 2.1 객체는 변경 가능한 값이다.

객체는 변경 가능한 값(mutable value) 이다. 변수에 원시값을 할당하면, 변수를 통해 해당 메모리공간에 저장된 값으로 직접 접근한다. 하지만, 객체를 할당한다면, 변수를 통해서 **참조값(reference value)**에 접근한다.

참조값은 **객체가 저장된 메모리공간의 메모리 주소**이다. 이 참조값을 통해 객체가 저장된 메모리공간에 접근할 수 있다. 그래서 원시값을 할당한 변수의 경우 변수는 ~~값을 갖는다 라고 표현하지만, 객체의 경우 변수는 객체를 가리키고(point) 있다 라고 표현한다.

```
var object = {
	key: 'value'
}
//변수 objdect 는 객체{key: 'value'}를 가리키고(참조하고) 있다.
```

변수의 값을 변경해보자. 원시값은 재할당 외에는 방법이 없다.

하지만 객체는 변경 가능한 값이므로 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있다.

- 프로퍼티 동적 추가
- 프로퍼티 값 갱신
- 프로퍼티 삭제

위 사항 모두 가능하다.

```
var object = {
	key: 'value'
}
//object 변수에 객체 할당

//프로퍼티 키 동적 추가
object.addedKey='value1';

//프로퍼티 값 갱신
object.key = 'modifiedValue';

console.log(object);
//{ key: 'modifiedValue', addedKey: 'value1' }
```

변수에는 객체의 참조값이 할당되어 있다. 프로퍼티 값을 조작할때 변수에 재할당은 하지 않았으므로 변수의 참조값이 변경되지않는다.

객체가 새로이 생성되지 않고 변경가능하게 설계된 이유는 무엇일까?

객체를 생성하고 관리하는 방식이 복잡하고 비용이 많이 드는일이다. 객체는 크기가 매우 클 수도 있고 원시값처럼 크기가 일정하지도 않으며 프로퍼티 값이 객체일 수 도있다. 그렇기때문에 복사해서 생성하는 비용이 많이든다. 메모리의 효율적 소비가 어렵고 성능이 나빠진다.

그렇기때문에 원시값 처럼 이전값을 복사해서 새롭게 생성하지 않는다. 객체는 메모리를 효율적으로 사용하고, 복사 및 생성비용을 절약하기 위해 변경가능한 값으로 설계되어 있다. 데이터의 신뢰성이 원시값에 비해 떨어지지만, 메모리 사용의 효율성과 성능을 고려한 것이다.

결론적으로 메모리 관점에서 효율성을 얻었지만 구조적인 단점도 가지고 있다.

이러한 단점에 따른 부작용이 있다.

바로 여러 개의 식별자가 하나의 객체를 공유할 수 있다는 것이다.

얕은 복사와 깊은 복사의 개념을 짚고 넘어가자.

객체의 프로퍼티 값으로 객체를 가지고 있다고 했을 때,

- 얕은복사 : 한단계 까지만 복사하는 것을 말한다.
- 깊은복사 : 객체에 중첩되어 있는 객체 까지 복사하는 것

```
const o = {
	a: {
		b: 2
	},
	f(){}
};

// 얕은 복사1
let c = { ...o}; // 35. 스프레드 문법에 있다고 한다.
console.log(o===c); //false
console.log(o.a === c.a); // true
// 한단계까지는 복사 하였지만 내부의 객체는 참조값을 전달했다.

//얕은 복사2
c = Object.assign({},o);
console.log(o === c); // false
console.log(o.a === c.a); // true
// 마찬가지로 한단계까지 복사하고 내부의 객체는 참조값을 전달

// 깊은복사 1
// JSON.parse 와 JSON.stringify를 사용한 깊은복사
c = JSON.parse(JSON.stringify(o));
console.log(o === c); // false
console.log(o.a === c.a); // false
// 메서드가 사라지는 문제가있다.
console.log(c.f);// undefined

// 깊은 복사 2
// "npm install lodash"로 lodash를 설치한 후, Node.js 환경에서 실행
const _ = require('lodash');

c = _cloneDeep(o);
console.log( o === c); false
console.log( o.a === c.a); //false
console.log(c.f); // f
```

참고로, **원시값을 할당한 변수를 다른 변수에 할당**하는 것을 깊은복사, **객체를 할당한 변수를 다른변수에 할당**하는 것을 얕은 복사라고 하는 경우도 있다.

```
//깊은 복사
const v = 1;
const c1 = v;
console.log(c1 === v); // true

//얕은 복사
const o = { x: 1};
const c2 = o;
consol.log(c2 === o); //true
```

### 2.2 참조에 의한 전달
