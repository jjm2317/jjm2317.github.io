<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jjm2317.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="원시값과 객체의 비교자바스크립트에는 7가지 데이터 타입이 있었다. 그리고 그 데이터 타입은 원시타입(primitive type) 과 객체타입(object&#x2F;reference type) 으로 분류되었다.  원시 타입 number string boolean undefined null symbol   객체 타입 함수, 객체 등등    원시 타입에서도 number,">
<meta property="og:type" content="article">
<meta property="og:title" content="javascript 11primitiveValue vs objectValue">
<meta property="og:url" content="https://jjm2317.github.io/2020/09/01/javascript-11primitiveValue-vs-objectValue/index.html">
<meta property="og:site_name" content="Jeong Jiman&#39;s blog">
<meta property="og:description" content="원시값과 객체의 비교자바스크립트에는 7가지 데이터 타입이 있었다. 그리고 그 데이터 타입은 원시타입(primitive type) 과 객체타입(object&#x2F;reference type) 으로 분류되었다.  원시 타입 number string boolean undefined null symbol   객체 타입 함수, 객체 등등    원시 타입에서도 number,">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-09-01T13:08:08.000Z">
<meta property="article:modified_time" content="2020-09-02T03:05:48.669Z">
<meta property="article:author" content="Jeong Jiman">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://jjm2317.github.io/2020/09/01/javascript-11primitiveValue-vs-objectValue/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>javascript 11primitiveValue vs objectValue | Jeong Jiman's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jeong Jiman's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Awesome node.jser..</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jjm2317.github.io/2020/09/01/javascript-11primitiveValue-vs-objectValue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jeong Jiman">
      <meta itemprop="description" content="All Dev stories found in here.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeong Jiman's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          javascript 11primitiveValue vs objectValue
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-01 22:08:08" itemprop="dateCreated datePublished" datetime="2020-09-01T22:08:08+09:00">2020-09-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-02 12:05:48" itemprop="dateModified" datetime="2020-09-02T12:05:48+09:00">2020-09-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="원시값과-객체의-비교"><a href="#원시값과-객체의-비교" class="headerlink" title="원시값과 객체의 비교"></a>원시값과 객체의 비교</h1><p>자바스크립트에는 7가지 데이터 타입이 있었다. 그리고 그 데이터 타입은 <strong>원시타입(primitive type)</strong> 과 <strong>객체타입(object/reference type)</strong> 으로 분류되었다.</p>
<ul>
<li>원시 타입<ul>
<li>number</li>
<li>string</li>
<li>boolean</li>
<li>undefined</li>
<li>null</li>
<li>symbol</li>
</ul>
</li>
<li>객체 타입<ul>
<li>함수, 객체 등등</li>
</ul>
</li>
</ul>
<p>원시 타입에서도 number, string 등 데이터 타입을 나누어 놓은 이유가 존재하였다. 자세한 내용은 데이터타입 포스팅에서 다루었다. </p>
<p>원시타입과 객체 타입을 나누어 놓은 이유는 무엇일까? 두 타입의 차이점을 먼저 짚어보자. 크게 3가지 측면에서 차이가 있다. </p>
<ul>
<li>원시 타입의 값, 즉 원시값은 변경 불가능한 값(immutable value)이다. 객체는 변경 가능한 값(mutable value)이다. <ul>
<li>변수에 저장된 값을 변경하고자할때, 원시값은 변경불가하기때문에 재할당에 의해 변경해야되지만, 객체는 재할당없이 값을 변경 가능하다.</li>
</ul>
</li>
<li>원시값을 변수에 할당하면 변수에 실제값이 저장된다. 이에 비해 객체를 변수에 할당하면 변수에는 참조값이 저장이된다. <ul>
<li>참조값은 객체 값을 저장한 메모리 주소를 가리킨다.</li>
</ul>
</li>
<li>원시값을 갖는 변수를 다른 변수에 할당하면 원본의 <strong>원시값이</strong> <strong>복사</strong>되어 전달된다.이를 값에 의한 전달 (pass by value) 라고 한다.  객체를 가리키는 변수를 다른 변수에 할당하면 원본의 <strong>참조값이 복사</strong>되어 전달된다. 이를 참조에 의한 전달(pass by reference) 이라고 한다.  </li>
</ul>
<p>즉 변경 가능성, 저장값, 전달 방식에서 차이가 있다.</p>
<p> 이 관점에서 원시 값과 객체를 분석해보자</p>
<h2 id="1-원시값"><a href="#1-원시값" class="headerlink" title="1. 원시값"></a>1. 원시값</h2><h3 id="1-1-원시값은-변경-불가능한-값이다"><a href="#1-1-원시값은-변경-불가능한-값이다" class="headerlink" title="1.1 원시값은 변경 불가능한 값이다."></a>1.1 원시값은 변경 불가능한 값이다.</h3><p>원시타입(primitive type)의 값, 원시값은 변경 불가능한 값 (immutable value) 이다. </p>
<p>한번 생성된 원시 값은 읽기 전용(read only) 값으로서 변경할 수 없다.</p>
<p><code>값을 변경할 수 없다?</code></p>
<p>값은 표현식이 평가되어 생성된 결과로 메모리에 저장되어 있다. 메모리에 저장된 값은 변경 불가능하다는 뜻이다. </p>
<p>헷갈릴 수 있는 개념에 대해 짚고 넘어가보자. 변수와 값은 구분해서 생각해야하낟. </p>
<ul>
<li>변수 : 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름</li>
<li>값 : 변수에 저장된 데이터로서 표현식이 평가되어 생성된 결과</li>
</ul>
<p>변경 불가 하다는 것은 변수가 아니라 값에 대한 진술이다.</p>
<p>원시값은 변경 불가능하다는 말은 <strong>원시값 자체를 변경할 수 없다</strong>는 것이지 변수 값을 변경할 수 없다는 것이 아니다. </p>
<p>다만, <strong>변수의 값이 변경</strong>되는 것은 원시값 자체의 변화가 아닌, 재할당을 통해 <strong>새로 생성된 원시값을 변수에 할당</strong>하는 것이다. 즉 엄밀히 말해서는 변수의 값이 교체되는 것이다.  </p>
<p>그렇다면 변수의 상대개념인 상수는 어떨까?</p>
<p>상수는 <strong>재할당이 금지된 변수</strong>이다. 상수도 값을 저장하기 위한 메모리 공간이 필요하므로 변수라고 할 수 있다. 다만 변수는 재할당을 통해 변수 값을 변경(교체)할 수 있지만 상수는 단 한번만 할당이 허용되므로 변수 값을 변경(교체)할 수 없다.  이처럼 상수는 재할당이 금지된 <strong>변수</strong>일 뿐이지, 변경 불가능한 값의 범주에 포함시키지는 않는다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 상수는 immutable한 값이 아닌 재할당이 금지된 변수이다.</span><br><span class="line">&#x2F;&#x2F; 상수에 객체를 할당할 시 변경 가능하다는 예시가 있다.</span><br><span class="line"></span><br><span class="line">const obj &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj.key &#x3D; &#39;value&#39;;</span><br><span class="line">console.log(obj); </span><br><span class="line">&#x2F;&#x2F;&#123;key: value&#125;</span><br></pre></td></tr></table></figure>



<p><code>변수의 재할당은 어떻게 일어날까?</code></p>
<p>원시값은 변경 불가능한 값이다. 변수에 재할당을 하게되면 원시값이 저장된 메모리공간으로 접근해서 값을 변경하는 것이 아니다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var num &#x3D; 10;</span><br><span class="line">&#x2F;&#x2F;값의 재할당</span><br><span class="line">num &#x3D; 5;</span><br></pre></td></tr></table></figure>

<p>num이라는 변수에 10이라는 숫자가 저장되어 있다. 5를 재할당 할 경우 10 이 저장되어 있는 메모리공간으로 접근해서 <strong>값을 변경하는 것이 아니라 새로운 메모리 공간을 확보</strong>해서 5를 저장한 후 num이라는 변수 이름을 연결해준다.  10은 가비지 컬렉터에 의해 메모리공간확보가 해제된다. </p>
<p>이렇게 처리하는 이유는 컴퓨터 입장에서 편하기 때문이다. </p>
<p>원시값의 이러한 특성을 불변성(immutaility)라고 한다.  불변성을 갖는 원시값을 할당한 변수는 재할당 의외에 변수 값을 변경할 수 있는 방법이 없다. </p>
<h3 id="1-2-문자열과-불변성"><a href="#1-2-문자열과-불변성" class="headerlink" title="1.2 문자열과 불변성"></a>1.2 문자열과 불변성</h3><p>원시값을 메모리 공간에 저장하기 위해서는, <strong>확보해야 하는 메모리 공간의 크기를 결정해야한다</strong>.  원시타입 별로 확보해야하는 메모리 공간의 크기가 정해져 있는 것이다.  ECMAScript 사양을 보면 문자열 타입 (2byte)와 숫자타입(8byte)는 메모리공간의 크기가 명시되어있는 반면에 다른 원시타입은 명시 되어있지 않고 브라우저 제조사의 구현에따라 다를 수 있다. </p>
<p>문자열 값은 다른 원시값과 비교해 독특한 특징이 있다.</p>
<ul>
<li>문자열은 0개 이상의 문자(character)로 이뤄진 집합이다.</li>
<li>1개의 문자는 2byte의 메모리 공간에 저장된다.</li>
<li>문자열은 몇 개의 문자로 이뤄졌느냐에 따라 필요한 메모리 공간의 크기가 결정된다.</li>
</ul>
<p>즉, 문자열은 확보해야하는 메모리공간의 크기가 고정된 다른 원시값과 다르게 <strong>문자의 개수에 따라 확보되는 메모리공간의 크기가 다르다</strong>. 1개의 문자로 된 문자열은 2byte, 5개의 문자로 이뤄진 문자열은 10byte가 필요하다.(실제 계산은 다르긴하다.)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str1 &#x3D; &#39;&#39;;</span><br><span class="line">var str2 &#x3D; &#39;jiman&#39;;</span><br><span class="line">&#x2F;&#x2F;필요한 메모리 공간의 크기가 다르다.</span><br></pre></td></tr></table></figure>

<p>C와 자바에서는 문자열 데이터 타입이 따로 없다. </p>
<p>c에서는 문자타입(char)들의 배열로 문자열을 처리하고, 자바에서는 String 객체로 문자열을 처리한다. </p>
<p>자바스크립트에서는 string이라는 데이터 타입을 제공하는 것이다. 데이터의 신뢰성을 보장하는, 자바스크립트의 장점이다.  </p>
<p>원시타입인 문자열 역시 변경 불가능하다. </p>
<p>문자열에는 독특한 특징이 하나 더 있는데 바로 유사 배열 객체 (array-like-object)라는 것이다. </p>
<p><strong>유사 배열 객체란?</strong></p>
<p>배열 처럼 인덱스로 프로퍼티 값에 접근할 수 있으며, length 프로퍼티를 갖는 객체이다. </p>
<p>즉 문자열은 인덱스로 각 문자 하나하나 에 접근할 수 있고 length 프로퍼티도 갖는다. for 문으로 순회하는 것도 가능하다. </p>
<p>다만 원시값인 문자열을 객체처럼 사용하면 원시값을 감싸는 래퍼 객체로 자동 변환된다. </p>
<p><strong>문자열은 변경 불가능한 원시값이다.</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var str &#x3D; &#39;jiman&#39;;</span><br><span class="line">str[0] &#x3D; &#39;J&#39;;</span><br><span class="line">console.log(str[0]);</span><br><span class="line">&#x2F;&#x2F;jiman</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;원시값이기때문에 개별문자의 변경이 불가하다. </span><br></pre></td></tr></table></figure>



<h3 id="1-3-값에-의한-전달-pass-by-value"><a href="#1-3-값에-의한-전달-pass-by-value" class="headerlink" title="1.3 값에 의한 전달(pass by value)"></a>1.3 값에 의한 전달(pass by value)</h3><p>어떤 변수에 기존에 원시값을 할당했던 변수를 할당하면 어떻게 될까?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var original &#x3D; 10;</span><br><span class="line">var copy &#x3D; original;</span><br><span class="line"></span><br><span class="line">console.log(original, copy);&#x2F;&#x2F; 10 10</span><br><span class="line"></span><br><span class="line">original &#x3D; 20;</span><br><span class="line"></span><br><span class="line">console.log(original, copy); 20 10</span><br></pre></td></tr></table></figure>

<p>copy에 original을 할당할때 original이 10으로 평가되어 새로운메모리 공간을 확보하고 10을 저장한 후 copy를 연결한다. 즉,  copy에는 original의 원시값이 복사되어 전달된다. 이를 값에의한전달 이라고 한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var original &#x3D; 10;</span><br><span class="line">var copy &#x3D; original;</span><br><span class="line"></span><br><span class="line">console.log( original, copy); &#x2F;&#x2F; 10 10</span><br><span class="line">console.log(original &#x3D;&#x3D;&#x3D; copy); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">orignal &#x3D; 20;</span><br><span class="line">console.log( original &#x3D;&#x3D;&#x3D; copy); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p>original 과 copy는 평가되었을때 동일한 숫자 값이지만, 두 값을 저장한 메모리공간의 위치는 다르다. 즉 orignal과 copy에 저장된 값은 별개의 값이다. </p>
<p>ECMAScript 사양에 변수를 통한 메모리 관리가 명확히 정의되지 않아서 값에 의한 전달시 두가지 경우가 있을 수 있다. </p>
<ul>
<li>식별자를 할당했을때 같은 원시값을 참조하였다가 재할당시 새로운 생성값을 참조</li>
<li>식별자 할당시부터 새로운 메모리공간 생성후 평가값저장후 참조</li>
</ul>
<p>파이썬은 전자처럼 동작한다고 한다. 할당 시점에 두 변수가 기억하는 메모리주소가 같느냐 다르냐이다. </p>
<p><strong>중요한것은 두 변수의 원시값이 결국엔 서로다른 메모리 공간에 저장된 다는 것이다.</strong>  서로 간섭하지 않는다.  </p>
<h2 id="2-객체"><a href="#2-객체" class="headerlink" title="2. 객체"></a>2. 객체</h2><p>객체 값을 생성할때 메모리공간의 크기는 어떻게 될까?</p>
<p>객체는 다음과 같은 특징이있다.</p>
<ul>
<li>객체는 프로퍼티의 개수가 고정되어 있지 않고, 동적으로 추가되고 삭제될 수 있다.</li>
<li>프로퍼티 값에 제약이 없다. </li>
<li>즉, 원시값과 같이 확보해야할 메모리 공간의 크기를 사전에 정해 둘 수 없다. </li>
</ul>
<p>객체는 복합적인 자료구조이다. 원시값과 비교하였을 때 복잡하고 브라우저 제조사마다 구현방식이 다를 수 있댜. 소비하는 메모리가 상대적으로 적은 원시값에 비해, 객체는 소비하는 메모리가 경우에 따라 매우 클 수 있다. </p>
<p>객체를 생성하고 프로퍼티에 접근하는 것도 원시값과 비교할 때 비용이 많이든다. </p>
<h3 id="2-1-객체는-변경-가능한-값이다"><a href="#2-1-객체는-변경-가능한-값이다" class="headerlink" title="2.1 객체는 변경 가능한 값이다."></a>2.1 객체는 변경 가능한 값이다.</h3><p>객체는 변경 가능한 값(mutable value) 이다.  변수에 원시값을 할당하면, 변수를 통해 해당 메모리공간에 저장된 값으로 직접 접근한다. 하지만, 객체를 할당한다면, 변수를 통해서 **참조값(reference value)**에 접근한다. </p>
<p>참조값은 <strong>객체가 저장된 메모리공간의 메모리 주소</strong>이다. 이 참조값을 통해 객체가 저장된 메모리공간에 접근할 수 있다.  그래서 원시값을 할당한 변수의 경우 변수는 ~~값을 갖는다 라고 표현하지만, 객체의 경우 변수는 객체를 가리키고(point) 있다 라고 표현한다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var object &#x3D; &#123;</span><br><span class="line">    key: &#39;value&#39;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;변수 objdect 는 객체&#123;key: &#39;value&#39;&#125;를 가리키고(참조하고) 있다.</span><br></pre></td></tr></table></figure>

<p>변수의 값을 변경해보자. 원시값은 재할당 외에는 방법이 없다. </p>
<p>하지만 객체는 변경 가능한 값이므로 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있다. </p>
<ul>
<li>프로퍼티 동적 추가</li>
<li>프로퍼티 값 갱신 </li>
<li>프로퍼티 삭제</li>
</ul>
<p>위 사항 모두 가능하다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var object &#x3D; &#123;</span><br><span class="line">    key: &#39;value&#39;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;object 변수에 객체 할당</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;프로퍼티 키 동적 추가</span><br><span class="line">object.addedKey&#x3D;&#39;value1&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;프로퍼티 값 갱신</span><br><span class="line">object.key &#x3D; &#39;modifiedValue&#39;;</span><br><span class="line"></span><br><span class="line">console.log(object);</span><br><span class="line">&#x2F;&#x2F;&#123; key: &#39;modifiedValue&#39;, addedKey: &#39;value1&#39; &#125;</span><br></pre></td></tr></table></figure>

<p>변수에는 객체의 참조값이 할당되어 있다.  프로퍼티 값을 조작할때 변수에 재할당은 하지 않았으므로 변수의 참조값이 변경되지않는다. </p>
<p>객체가 새로이 생성되지 않고 변경가능하게 설계된 이유는 무엇일까?</p>
<p>객체를 생성하고 관리하는 방식이 복잡하고 비용이 많이 드는일이다. 객체는 크기가 매우 클 수도 있고 원시값처럼 크기가 일정하지도 않으며 프로퍼티 값이 객체일 수 도있다. 그렇기때문에 복사해서 생성하는 비용이 많이든다. 메모리의 효율적 소비가 어렵고 성능이 나빠진다. </p>
<p>그렇기때문에 원시값 처럼 이전값을 복사해서 새롭게 생성하지 않는다. 객체는 메모리를 효율적으로 사용하고, 복사 및 생성비용을 절약하기 위해 변경가능한 값으로 설계되어 있다. 데이터의 신뢰성이 원시값에 비해 떨어지지만, 메모리 사용의 효율성과 성능을 고려한 것이다. </p>
<p>결론적으로 메모리 관점에서 효율성을 얻었지만 구조적인 단점도 가지고 있다.</p>
<p>이러한 단점에 따른 부작용이 있다.</p>
<p>바로 여러 개의 식별자가 하나의 객체를 공유할 수 있다는 것이다. </p>
<p>얕은 복사와 깊은 복사의 개념을 짚고 넘어가자.</p>
<p>객체의 프로퍼티 값으로 객체를 가지고 있다고 했을 때,</p>
<ul>
<li>얕은복사 : 한단계 까지만 복사하는 것을 말한다.</li>
<li>깊은복사 : 객체에 중첩되어 있는 객체 까지 복사하는 것</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">const o &#x3D; &#123;</span><br><span class="line">    a: &#123;</span><br><span class="line">        b: 2</span><br><span class="line">    &#125;,</span><br><span class="line">    f()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 얕은 복사1</span><br><span class="line">let c &#x3D; &#123; ...o&#125;; &#x2F;&#x2F; 35. 스프레드 문법에 있다고 한다.</span><br><span class="line">console.log(o&#x3D;&#x3D;&#x3D;c); &#x2F;&#x2F;false</span><br><span class="line">console.log(o.a &#x3D;&#x3D;&#x3D; c.a); &#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F; 한단계까지는 복사 하였지만 내부의 객체는 참조값을 전달했다.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;얕은 복사2 </span><br><span class="line">c &#x3D; Object.assign(&#123;&#125;,o);</span><br><span class="line">console.log(o &#x3D;&#x3D;&#x3D; c); &#x2F;&#x2F; false</span><br><span class="line">console.log(o.a &#x3D;&#x3D;&#x3D; c.a); &#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F; 마찬가지로 한단계까지 복사하고 내부의 객체는 참조값을 전달</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 깊은복사 1</span><br><span class="line">&#x2F;&#x2F; JSON.parse 와 JSON.stringify를 사용한 깊은복사</span><br><span class="line">c &#x3D; JSON.parse(JSON.stringify(o));</span><br><span class="line">console.log(o &#x3D;&#x3D;&#x3D; c); &#x2F;&#x2F; false</span><br><span class="line">console.log(o.a &#x3D;&#x3D;&#x3D; c.a); &#x2F;&#x2F; false</span><br><span class="line">&#x2F;&#x2F; 메서드가 사라지는 문제가있다.</span><br><span class="line">console.log(c.f);&#x2F;&#x2F; undefined</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 깊은 복사 2</span><br><span class="line">&#x2F;&#x2F; &quot;npm install lodash&quot;로 lodash를 설치한 후, Node.js 환경에서 실행</span><br><span class="line">const _ &#x3D; require(&#39;lodash&#39;);</span><br><span class="line"></span><br><span class="line">c &#x3D; _cloneDeep(o);</span><br><span class="line">console.log( o &#x3D;&#x3D;&#x3D; c); false</span><br><span class="line">console.log( o.a &#x3D;&#x3D;&#x3D; c.a); &#x2F;&#x2F;false</span><br><span class="line">console.log(c.f); &#x2F;&#x2F; f</span><br></pre></td></tr></table></figure>



<p>참고로, <strong>원시값을 할당한 변수를 다른 변수에 할당</strong>하는 것을 깊은복사, <strong>객체를 할당한 변수를 다른변수에 할당</strong>하는 것을 얕은 복사라고 하는 경우도 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;깊은 복사</span><br><span class="line">const v &#x3D; 1;</span><br><span class="line">const c1 &#x3D; v;</span><br><span class="line">console.log(c1 &#x3D;&#x3D;&#x3D; v); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;얕은 복사</span><br><span class="line">const o &#x3D; &#123; x: 1&#125;;</span><br><span class="line">const c2 &#x3D; o;</span><br><span class="line">consol.log(c2 &#x3D;&#x3D;&#x3D; o); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>



<h3 id="2-2-참조에-의한-전달"><a href="#2-2-참조에-의한-전달" class="headerlink" title="2.2 참조에 의한 전달"></a>2.2 참조에 의한 전달</h3>
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/08/28/javascript-ASCII-Unicode/" rel="prev" title="javascript ASCII, Unicode">
      <i class="fa fa-chevron-left"></i> javascript ASCII, Unicode
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/09/01/0824-0828-TIL/" rel="next" title="0824~0828 TIL">
      0824~0828 TIL <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%EC%9B%90%EC%8B%9C%EA%B0%92%EA%B3%BC-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EB%B9%84%EA%B5%90"><span class="nav-number">1.</span> <span class="nav-text">원시값과 객체의 비교</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%EC%9B%90%EC%8B%9C%EA%B0%92"><span class="nav-number">1.1.</span> <span class="nav-text">1. 원시값</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%EC%9B%90%EC%8B%9C%EA%B0%92%EC%9D%80-%EB%B3%80%EA%B2%BD-%EB%B6%88%EA%B0%80%EB%8A%A5%ED%95%9C-%EA%B0%92%EC%9D%B4%EB%8B%A4"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1 원시값은 변경 불가능한 값이다.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%EB%AC%B8%EC%9E%90%EC%97%B4%EA%B3%BC-%EB%B6%88%EB%B3%80%EC%84%B1"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.2 문자열과 불변성</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%EA%B0%92%EC%97%90-%EC%9D%98%ED%95%9C-%EC%A0%84%EB%8B%AC-pass-by-value"><span class="nav-number">1.1.3.</span> <span class="nav-text">1.3 값에 의한 전달(pass by value)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%EA%B0%9D%EC%B2%B4"><span class="nav-number">1.2.</span> <span class="nav-text">2. 객체</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%EA%B0%9D%EC%B2%B4%EB%8A%94-%EB%B3%80%EA%B2%BD-%EA%B0%80%EB%8A%A5%ED%95%9C-%EA%B0%92%EC%9D%B4%EB%8B%A4"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1 객체는 변경 가능한 값이다.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%EC%B0%B8%EC%A1%B0%EC%97%90-%EC%9D%98%ED%95%9C-%EC%A0%84%EB%8B%AC"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2 참조에 의한 전달</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jeong Jiman</p>
  <div class="site-description" itemprop="description">All Dev stories found in here.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jeong Jiman</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
