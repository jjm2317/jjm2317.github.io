<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jjm2317.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="All Dev stories found in here.">
<meta property="og:type" content="website">
<meta property="og:title" content="Jeong Jiman&#39;s blog">
<meta property="og:url" content="https://jjm2317.github.io/page/4/index.html">
<meta property="og:site_name" content="Jeong Jiman&#39;s blog">
<meta property="og:description" content="All Dev stories found in here.">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jeong Jiman">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://jjm2317.github.io/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Jeong Jiman's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jeong Jiman's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Awesome node.jser..</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jjm2317.github.io/2020/10/22/javascript-Spread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jeong Jiman">
      <meta itemprop="description" content="All Dev stories found in here.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeong Jiman's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/22/javascript-Spread/" class="post-title-link" itemprop="url">javascript Spread</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-22 16:13:32" itemprop="dateCreated datePublished" datetime="2020-10-22T16:13:32+09:00">2020-10-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-30 13:39:16" itemprop="dateModified" datetime="2021-03-30T13:39:16+09:00">2021-03-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="스프레드-문법"><a href="#스프레드-문법" class="headerlink" title="스프레드 문법"></a>스프레드 문법</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">console.log(... [1, 2, 3]); &#x2F;&#x2F;1 2 3</span><br><span class="line"></span><br><span class="line">console.log(...&#39;Hello&#39;); &#x2F;&#x2F; H e l l o</span><br><span class="line"></span><br><span class="line">console.log(...new Map([[&#39;a&#39;, &#39;1&#39;], [&#39;b&#39;, &#39;2&#39;]]))&#x2F;&#x2F; [&#39;a&#39;, &#39;1&#39;] [&#39;b&#39;, &#39;2&#39;]</span><br><span class="line">console.log(...new Set([1, 2, 3])); &#x2F;&#x2F;1 2 3</span><br><span class="line"></span><br><span class="line">console.log(...&#123;a: 1, b: 2&#125;);</span><br><span class="line">&#x2F;&#x2F; TypeError</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const list &#x3D; ...[1, 2, 3]; &#x2F;&#x2F;SyntaxError</span><br></pre></td></tr></table></figure>



<h2 id="1-함수-호출문의-인수-목록에서-사용하는-경우"><a href="#1-함수-호출문의-인수-목록에서-사용하는-경우" class="headerlink" title="1. 함수 호출문의 인수 목록에서 사용하는 경우"></a>1. 함수 호출문의 인수 목록에서 사용하는 경우</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, 2, 3];</span><br><span class="line">const max &#x3D; Math.max(arr); &#x2F;&#x2F;NaN</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Math.max(1); &#x2F;&#x2F;1</span><br><span class="line">Math.max(1, 2); &#x2F;&#x2F;2</span><br><span class="line">Math.max(1, 2, 3); &#x2F;&#x2F;3</span><br><span class="line">Math.max(); &#x2F;&#x2F;-Infinity</span><br><span class="line"></span><br><span class="line">Math.max([1,2,3]); &#x2F;&#x2F;NaN</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [1, 2, 3];</span><br><span class="line"></span><br><span class="line">var max &#x3D; Math.max.apply(null, arr); &#x2F;&#x2F;3</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const max &#x3D; Math.max(...arr)</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Rest 파라미터</span><br><span class="line"></span><br><span class="line">function foo(...rest) &#123;</span><br><span class="line">    console.log(rest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(...[1, 2, 3]);</span><br></pre></td></tr></table></figure>



<h2 id="2-배열-리터럴-내부에서-사용하는-경우"><a href="#2-배열-리터럴-내부에서-사용하는-경우" class="headerlink" title="2. 배열 리터럴 내부에서 사용하는 경우"></a>2. 배열 리터럴 내부에서 사용하는 경우</h2><h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [1, 2].concat([3, 4]);</span><br><span class="line">console.log(arr); &#x2F;&#x2F;[1, 2, 3, 4]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr&#x3D; [...[1, 2], ...[3, 4]];</span><br><span class="line">console.log(arr); &#x2F;&#x2F;[1, 2, 3, 4]</span><br></pre></td></tr></table></figure>



<h3 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr1 &#x3D; [1,4];</span><br><span class="line">var arr2 &#x3D; [2, 3];</span><br><span class="line"></span><br><span class="line">arr1.splice(1, 0, arr2);</span><br><span class="line"></span><br><span class="line">console.log(arr1); &#x2F;&#x2F;[1,[2, 3], 4]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr1&#x3D; [1, 4];</span><br><span class="line">var arr2 &#x3D; [2, 3];</span><br><span class="line"></span><br><span class="line">Array.prototype.splice.apply(arr1, [1, 0].concat(arr2));</span><br><span class="line">console.log(arr1);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const arr1 &#x3D; [1, 4];</span><br><span class="line">const arr2 &#x3D; [2, 3];</span><br><span class="line"></span><br><span class="line">arr1.splice(1, 0, ...arr2);</span><br><span class="line">console.log(arr1); &#x2F;&#x2F;[1, 2, 3, 4]</span><br></pre></td></tr></table></figure>



<h3 id="배열-복사"><a href="#배열-복사" class="headerlink" title="배열 복사"></a>배열 복사</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var origin &#x3D; [1, 2];</span><br><span class="line">var copy &#x3D; origin.slice();</span><br><span class="line"></span><br><span class="line">console.log(copy);</span><br><span class="line">console.log(copy &#x3D;&#x3D;&#x3D; origin); &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const origin &#x3D; [1, 2];</span><br><span class="line">const copy &#x3D; [...origin];</span><br><span class="line"></span><br><span class="line">console.log(copy); [1, 2]</span><br><span class="line">console.log(copy &#x3D;&#x3D;&#x3D; origin); &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>



<h3 id="이터러블을-배열로-변환"><a href="#이터러블을-배열로-변환" class="headerlink" title="이터러블을 배열로 변환"></a>이터러블을 배열로 변환</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function sum() &#123;</span><br><span class="line">    var args &#x3D; Array.prototype.slice.call(arguments);</span><br><span class="line">    </span><br><span class="line">    return args.reduce(function (pre, cur)&#123;</span><br><span class="line">        return pre + cur;</span><br><span class="line">    &#125;, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(sum(1, 2, 3)); &#x2F;&#x2F; 6</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const arrayLike &#x3D; &#123;</span><br><span class="line">    0: 1,</span><br><span class="line">    1: 2,</span><br><span class="line">    2: 3,</span><br><span class="line">    length: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const arr &#x3D; Array.prototype.slice.call(arrayLike); &#x2F;&#x2F;[1, 2, 3]</span><br><span class="line">console.log(Array.isArray(arr));</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function sum() &#123;</span><br><span class="line">    return [...arguments].reduce((pre, cur) &#x3D;&gt; pre + cur, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(sum(1, 2, 3)); &#x2F;&#x2F; 6</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const sum &#x3D; (...args) &#x3D;&gt; args.reduce((pre, cur) &#x3D;&gt; pre + cur, 0);</span><br><span class="line"></span><br><span class="line">console.log(sum(1, 2, 3));</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const arrayLike &#x3D; &#123;</span><br><span class="line">    0: 1,</span><br><span class="line">    1: 2,</span><br><span class="line">    2: 3,</span><br><span class="line">    length: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const arr &#x3D; [...arrayLike]</span><br><span class="line">&#x2F;&#x2F;TypeError</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.from(arrayLike); &#x2F;&#x2F; [1, 2, 3]</span><br></pre></td></tr></table></figure>



<h3 id="객체-리터럴-내부에서-사용하는-경우"><a href="#객체-리터럴-내부에서-사용하는-경우" class="headerlink" title="객체 리터럴 내부에서 사용하는 경우"></a>객체 리터럴 내부에서 사용하는 경우</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; &#123; x: 1, y: 2&#125;; </span><br><span class="line">const copy &#x3D; &#123;...obj&#125;;</span><br><span class="line">console.log(copy); &#x2F;&#x2F;&#123;x: 1, y: 2&#125;</span><br><span class="line">console.log(obj &#x3D;&#x3D;&#x3D; copy); &#x2F;&#x2F;false</span><br><span class="line"></span><br><span class="line">const merged &#x3D; &#123;x: 1, y: 2, ...&#123;a: 3, b: 4&#125;&#125;;</span><br><span class="line">console.log(merged); &#x2F;&#x2F; &#123;x: 1, y: 2, a: 3, b: 4&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const merged &#x3D; Object.assign(&#123;&#125;, &#123;x: 1, y: 2&#125;, &#123;y: 10, z: 3&#125;);</span><br><span class="line">console.log(merged)l &#x2F;&#x2F;&#123;x: 1, y: 10, z: 3&#125;</span><br><span class="line"></span><br><span class="line">const changed &#x3D; Object.assign(&#123;&#125;, &#123;x: 1, y: 2&#125;, &#123;y: 100&#125;);</span><br><span class="line">console.log(changed); &#x2F;&#x2F;&#123;x: 1, y: 100&#125;</span><br><span class="line"></span><br><span class="line">const added &#x3D; Object.assigin(&#123;&#125;, &#123;x: 1, y: 2&#125;, &#123;z: 0&#125;);</span><br><span class="line">console.log(added); &#x2F;&#x2F; &#123;x: 1, y: 2, z: 0&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const merged &#x3D; &#123;...&#123;x: 1, y: 2&#125;, ...&#123;y: 10, z: 3&#125;&#125;;</span><br><span class="line">console.log(merged); &#x2F;&#x2F;&#123;x: 1, y: 10, z: 3&#125;</span><br><span class="line"></span><br><span class="line">const changed &#x3D; &#123;...&#123;x: 1, y: 2&#125;, y: 100&#125;;</span><br><span class="line"></span><br><span class="line">console.log(changed); &#x2F;&#x2F;&#123;x: 1, y: 100&#125;</span><br><span class="line"></span><br><span class="line">const added &#x3D; &#123;...&#123;x: 1, y: 2&#125;, z: 0&#125;;</span><br><span class="line"></span><br><span class="line">console.log(added); &#x2F;&#x2F;&#123;x: 1, y: 2, z: 0&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jjm2317.github.io/2020/10/22/javascript-Number/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jeong Jiman">
      <meta itemprop="description" content="All Dev stories found in here.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeong Jiman's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/22/javascript-Number/" class="post-title-link" itemprop="url">javascript Number</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-22 15:43:43" itemprop="dateCreated datePublished" datetime="2020-10-22T15:43:43+09:00">2020-10-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-30 13:39:16" itemprop="dateModified" datetime="2021-03-30T13:39:16+09:00">2021-03-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h1><h2 id="1-Number-생성자-함수"><a href="#1-Number-생성자-함수" class="headerlink" title="1. Number 생성자 함수"></a>1. Number 생성자 함수</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const numObj &#x3D; new Number();</span><br><span class="line">console.log(numObj); &#x2F;&#x2F; Number &#123;[[PrimitiveValue]]: 0&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const numObj &#x3D; new Number(10);</span><br><span class="line">console.log(numObj); &#x2F;&#x2F;Number &#123;[[PrimitiveValue]] : 10&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let numObj &#x3D; new Number(&#39;10&#39;);</span><br><span class="line">console.log(numObj); &#x2F;&#x2F; Number &#123;[[PrimitiveValue]]: 10&#125;</span><br><span class="line">numObj &#x3D; new Number(&#39;Hello&#39;);</span><br><span class="line">console.log(numObj); &#x2F;&#x2F; Number &#123;[[PrimitiveValue]]: NaN&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-Number-프로퍼티"><a href="#2-Number-프로퍼티" class="headerlink" title="2. Number 프로퍼티"></a>2. Number 프로퍼티</h2><h3 id="2-1-Number-EPSILON"><a href="#2-1-Number-EPSILON" class="headerlink" title="2.1 Number.EPSILON"></a>2.1 Number.EPSILON</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0.1 + 0.2;&#x2F;&#x2F;0.30000000000000004</span><br><span class="line">0.1 + 0.2 &#x3D;&#x3D;&#x3D; 0.3;&#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function isEqual(a,b)&#123;</span><br><span class="line">    return Math.abs(a-b) &lt; Number.EPSILON;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isEqual(0.1 + 0.2, 0.3); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>



<h3 id="2-2-Number-MAX-VALUE"><a href="#2-2-Number-MAX-VALUE" class="headerlink" title="2.2 Number.MAX_VALUE"></a>2.2 Number.MAX_VALUE</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number.MAX_VALUE; &#x2F;&#x2F; 1.7976931348623157e+308</span><br><span class="line">Infinity &gt; Number.MAX_VALUE</span><br></pre></td></tr></table></figure>



<h3 id="2-3-Number-MIN-VALUE"><a href="#2-3-Number-MIN-VALUE" class="headerlink" title="2.3 Number.MIN_VALUE"></a>2.3 Number.MIN_VALUE</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number.MIN_VALUE; &#x2F;&#x2F; 5e-324</span><br><span class="line">NUMBER.MIN_VALUE &gt; 0;&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>



<h3 id="2-4-NUMBER-MAX-SAFE-INTEGER"><a href="#2-4-NUMBER-MAX-SAFE-INTEGER" class="headerlink" title="2.4 NUMBER.MAX_SAFE_INTEGER"></a>2.4 NUMBER.MAX_SAFE_INTEGER</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Number.MAX_SAFE_INTEGER; &#x2F;&#x2F; 9007199254740991</span><br></pre></td></tr></table></figure>



<h3 id="2-5-Number-MIN-SAFE-INTEGER"><a href="#2-5-Number-MIN-SAFE-INTEGER" class="headerlink" title="2.5 Number.MIN_SAFE_INTEGER"></a>2.5 Number.MIN_SAFE_INTEGER</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Number.MIN_SAFE_INTEGER; &#x2F;&#x2F;-9007199254740991</span><br></pre></td></tr></table></figure>



<h3 id="2-6-Number-POSITIVE-INFINITY"><a href="#2-6-Number-POSITIVE-INFINITY" class="headerlink" title="2.6 Number.POSITIVE_INFINITY"></a>2.6 Number.POSITIVE_INFINITY</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Number.POSITIVE_INFINITY; &#x2F;&#x2F;Infinity</span><br></pre></td></tr></table></figure>



<h3 id="2-7-Number-NEGATIVE-INFINITY"><a href="#2-7-Number-NEGATIVE-INFINITY" class="headerlink" title="2.7 Number.NEGATIVE_INFINITY"></a>2.7 Number.NEGATIVE_INFINITY</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Number.NEGATIVE_INFINITY; &#x2F;&#x2F; -Infinity</span><br></pre></td></tr></table></figure>



<h3 id="2-8-Number-NaN"><a href="#2-8-Number-NaN" class="headerlink" title="2.8 Number.NaN"></a>2.8 Number.NaN</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Number.NaN; &#x2F;&#x2F; NaN</span><br></pre></td></tr></table></figure>



<h2 id="3-Number-메서드"><a href="#3-Number-메서드" class="headerlink" title="3. Number 메서드"></a>3. Number 메서드</h2><h3 id="3-1-Number-isFinite"><a href="#3-1-Number-isFinite" class="headerlink" title="3.1 Number.isFinite"></a>3.1 Number.isFinite</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Number.isFinite(0);</span><br><span class="line">Number.isFinite(Number.MAX_VALUE); &#x2F;&#x2F;true</span><br><span class="line">Number.isFinite(Number.MIN_VALUE)l &#x2F;&#x2F;true</span><br><span class="line"></span><br><span class="line">Number.isFinite(Infinity); &#x2F;&#x2F;false</span><br><span class="line">Number.isFinite(-Infinity); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Number.isFinite(NaN); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Number.isFinite(null) ;&#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">isFinite(null); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>



<h3 id="3-2-Number-isInteger"><a href="#3-2-Number-isInteger" class="headerlink" title="3.2 Number.isInteger"></a>3.2 Number.isInteger</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Number.isInteger(0); &#x2F;&#x2F; true</span><br><span class="line">Number.isInteger(123); &#x2F;&#x2F;true</span><br><span class="line">Number.isInteger(-123); &#x2F;&#x2F;true</span><br><span class="line"></span><br><span class="line">Number.isInteger(0.5); &#x2F;&#x2F;false</span><br><span class="line">Number.isInteger(&#39;123&#39;); &#x2F;&#x2F;false</span><br><span class="line">Number.isInteger(false); &#x2F;&#x2F;false</span><br><span class="line">Number.isInteger(Infinity); &#x2F;&#x2F;false</span><br><span class="line">Number.isInteger(-Infinity); &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>



<h3 id="3-3-Number-isNaN"><a href="#3-3-Number-isNaN" class="headerlink" title="3.3 Number.isNaN"></a>3.3 Number.isNaN</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Number.isNaN(NaN); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number.isNaN(undefined); &#x2F;&#x2F;false</span><br><span class="line">isNaN(undefined); &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jjm2317.github.io/2020/10/21/27Array/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jeong Jiman">
      <meta itemprop="description" content="All Dev stories found in here.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeong Jiman's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/21/27Array/" class="post-title-link" itemprop="url">27Array</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-21 18:36:12" itemprop="dateCreated datePublished" datetime="2020-10-21T18:36:12+09:00">2020-10-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-30 13:39:16" itemprop="dateModified" datetime="2021-03-30T13:39:16+09:00">2021-03-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="배열"><a href="#배열" class="headerlink" title="배열"></a>배열</h1><ul>
<li><p>동일한 메모리공간을 연속적으로 확보한다.</p>
</li>
<li><p>random access가빠르다 O(1);</p>
</li>
<li><p>유사배열객체와는 속도의 차이가 있다.</p>
</li>
<li><p>자료구조 사용이유</p>
<ul>
<li>관련있는 것들끼리 모으기 위해</li>
</ul>
</li>
<li><p>배열을 만들때 요소의 타입이 갖도록 해야한다.</p>
<ul>
<li>최적화가 일어나기 때문</li>
</ul>
</li>
</ul>
<h2 id="배열-메서드"><a href="#배열-메서드" class="headerlink" title="배열 메서드"></a>배열 메서드</h2><h3 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray"></a>Array.isArray</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;true</span><br><span class="line">Array.isArray([]); &#x2F;&#x2F;true</span><br><span class="line">Array.isArray([1,2]);</span><br><span class="line">Array.isArray(new Array());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;false</span><br><span class="line">Array.isArray();</span><br><span class="line">Array.isArray(&#123;&#125;);</span><br><span class="line">Array.isArray(null);</span><br><span class="line">Array.isArray(undefined);</span><br><span class="line">Array.isArray(1);</span><br><span class="line">Array.isArray(&#39;Array&#39;);</span><br><span class="line">Array.isArray(true);</span><br><span class="line">Array.isArray(false);</span><br><span class="line">Array.isArray(&#123;0 : 1, length: 1&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="Array-prototype-indexOf"><a href="#Array-prototype-indexOf" class="headerlink" title="Array.prototype.indexOf"></a>Array.prototype.indexOf</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1,2,3,4];</span><br><span class="line"></span><br><span class="line">arr.indexOf(2); &#x2F;&#x2F;1</span><br><span class="line">arr.indexOf(4); &#x2F;&#x2F;-1</span><br><span class="line">arr.indexOf(2,2);&#x2F;&#x2F;2</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const foods &#x3D; [&#39;apple&#39;, &#39;banana&#39;, &#39;orange&#39;];</span><br><span class="line"></span><br><span class="line">if (foods.indexOf(&#39;orange&#39;) &#x3D;&#x3D;&#x3D; -1) &#123;</span><br><span class="line">    foods.push(&#39;orange&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(foods);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Array-prototype-push"><a href="#Array-prototype-push" class="headerlink" title="Array.prototype.push"></a>Array.prototype.push</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1,2];</span><br><span class="line"></span><br><span class="line">let result &#x3D; arr.push(3, 4);</span><br><span class="line">console.log(result);&#x2F;&#x2F;4</span><br><span class="line"></span><br><span class="line">console.log(arr); &#x2F;&#x2F; [1, 2, 3, 4];</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, 2];</span><br><span class="line"></span><br><span class="line">arr[arr.length] &#x3D; 3;</span><br><span class="line">console.log(arr); &#x2F;&#x2F; [1, 2, 3]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, 2];</span><br><span class="line"></span><br><span class="line">const newArr &#x3D; [...arr, 3];</span><br><span class="line">console.log(newArr); &#x2F;&#x2F; [1, 2, 3]</span><br></pre></td></tr></table></figure>



<h3 id="Array-prototype-pop"><a href="#Array-prototype-pop" class="headerlink" title="Array.prototype.pop"></a>Array.prototype.pop</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, 2];</span><br><span class="line"></span><br><span class="line">let result &#x3D; arr.pop();</span><br><span class="line">console.log(result); &#x2F;&#x2F;2</span><br><span class="line"></span><br><span class="line">console.log(arr); &#x2F;&#x2F;[1]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">const Stack &#x3D; (function () &#123;</span><br><span class="line">    function Stack(array &#x3D; []) &#123;</span><br><span class="line">        if (!Array.isArray(array))&#123;</span><br><span class="line">            throw new TypeError(&#96;$&#123;array&#125; is not an array.&#96;);</span><br><span class="line">        &#125;</span><br><span class="line">        this.array &#x3D; arrayp</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Stack.prototype &#x3D; &#123;</span><br><span class="line">        constructor: Stack,</span><br><span class="line">        </span><br><span class="line">        push(value) &#123;</span><br><span class="line">            return this.array.push(value);</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        pop() &#123;</span><br><span class="line">            return this.array.pop();</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        entries() &#123;</span><br><span class="line">            return [... this.array]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    return Stack</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">const Stack &#x3D; new Stack ([1, 2]);</span><br><span class="line">console.log(stack.entries()); &#x2F;&#x2F; [1, 2]</span><br><span class="line"></span><br><span class="line">stack.push(3);</span><br><span class="line">console.log(stack.entries()); &#x2F;&#x2F; [1, 2, 3]</span><br><span class="line"></span><br><span class="line">stack.pop();</span><br><span class="line">console.log(stack.entries()); &#x2F;&#x2F; [1, 2]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Stack &#123;</span><br><span class="line">    #array; &#x2F;&#x2F; private class member</span><br><span class="line">    </span><br><span class="line">    constructor(array &#x3D; []) &#123;</span><br><span class="line">        if (!Array.isArray(array)) &#123;</span><br><span class="line">            throw new TypeError(&#96;$&#123;array&#125; is not an array.&#96;);</span><br><span class="line">        &#125;</span><br><span class="line">        this.#array &#x3D; array;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    push(value) &#123;</span><br><span class="line">        return this.#array.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pop() &#123;</span><br><span class="line">        return this.#array.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    entries() &#123;</span><br><span class="line">        return [...this.#array];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Array-prototype-unshift"><a href="#Array-prototype-unshift" class="headerlink" title="Array.prototype.unshift"></a>Array.prototype.unshift</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, 2];</span><br><span class="line"></span><br><span class="line">let result &#x3D; arr.unshift(3, 4);</span><br><span class="line"></span><br><span class="line">console.log(result); &#x2F;&#x2F;4</span><br><span class="line"></span><br><span class="line">console.log(arr); &#x2F;&#x2F; [3, 4, 1, 2]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, 2];</span><br><span class="line"></span><br><span class="line">const newArr &#x3D; [3, ...arr];</span><br><span class="line">console.log(newArr); &#x2F;&#x2F; [3, 1, 2]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const arr1 &#x3D; [1, 2];</span><br><span class="line">console.log(arr1.unshift(3));&#x2F;&#x2F;3</span><br><span class="line">console.log(arr1);&#x2F;&#x2F; [3, 1, 2]</span><br><span class="line"></span><br><span class="line">arr1.unshift([1, 2]);</span><br><span class="line">console.log(arr1); &#x2F;&#x2F;[ [ 1, 2 ], 3, 1, 2 ] 전달 받은 배열을 그대로 저장</span><br><span class="line"></span><br><span class="line">const arr2 &#x3D; [1, 2];</span><br><span class="line">arr2.unshift([3, 4], 1);</span><br><span class="line">console.log(arr2); &#x2F;&#x2F;[ [ 3, 4 ], 1, 1, 2 ] 숫자 배열 혼합도 그대로 저장</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="8-6-Array-prototype-shift"><a href="#8-6-Array-prototype-shift" class="headerlink" title="8.6 Array.prototype.shift"></a>8.6 Array.prototype.shift</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, 2];</span><br><span class="line"></span><br><span class="line">let result &#x3D; arr.shift();</span><br><span class="line">console.log(result); &#x2F;&#x2F; 1</span><br><span class="line"></span><br><span class="line">console.log(arr); &#x2F;&#x2F; [2]</span><br></pre></td></tr></table></figure>





<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 큐 생성자 함수</span><br><span class="line">const Queue &#x3D; (function () &#123;</span><br><span class="line">    function Queue(array &#x3D; []) &#123;</span><br><span class="line">        this.array &#x3D; array;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue.prototype &#x3D; &#123;</span><br><span class="line">        constructor: Queue,</span><br><span class="line">        </span><br><span class="line">        enqueue(element) &#123;</span><br><span class="line">            this.array.push(element);</span><br><span class="line">        &#125;</span><br><span class="line">        dequeue(element) &#123;</span><br><span class="line">            this.array.shift();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        entries()&#123;</span><br><span class="line">            return [...this.array];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return Queue;</span><br><span class="line">    </span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 큐 클래스</span><br><span class="line">class Queue &#123;</span><br><span class="line">    #array;</span><br><span class="line">    </span><br><span class="line">    constructor(array &#x3D; []) &#123;</span><br><span class="line">        if(!(array instanceof Array)) &#123;</span><br><span class="line">            throw new TypeError(&#96;$&#123;array&#125; is not array&#96;);</span><br><span class="line">        &#125;</span><br><span class="line">        this.#array &#x3D; array;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    enqueue (element) &#123;</span><br><span class="line">        this.#array.push(element);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dequeue () &#123;</span><br><span class="line">        this.#array.shift();</span><br><span class="line">    &#125;</span><br><span class="line">    entries() &#123;</span><br><span class="line">        return [...this.aray];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return Queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="Array-prototype-concat"><a href="#Array-prototype-concat" class="headerlink" title="Array.prototype.concat"></a>Array.prototype.concat</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const arr1 &#x3D; [1, 2];</span><br><span class="line">const arr2 &#x3D; [3, 4];</span><br><span class="line"></span><br><span class="line">let result &#x3D; arr.concat(arr2);</span><br><span class="line">console.log(result); [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">result &#x3D; arr1.concat(3);</span><br><span class="line">console.log(result); &#x2F;&#x2F; [1, 2, 3]</span><br><span class="line"></span><br><span class="line">result &#x3D; arr1.concat(arr2, 5);</span><br><span class="line">console.log(result); &#x2F;&#x2F;[1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">consol.log(arr1); &#x2F;&#x2F; [1, 2]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const arr1 &#x3D; [1, 2, 3];</span><br><span class="line"></span><br><span class="line">const arr2 &#x3D; arr1.concat(1,2,3);</span><br><span class="line"></span><br><span class="line">console.log(arr2);&#x2F;&#x2F;[ 1, 2, 3, 1, 2, 3 ]</span><br><span class="line">console.log(arr1);&#x2F;&#x2F;[ 1, 2, 3 ] 원본 배열 안 변한다.</span><br><span class="line"></span><br><span class="line">console.log(arr1.concat([1,2]));&#x2F;&#x2F;[ 1, 2, 3, 1, 2 ] &#x2F;&#x2F;배열 인수도 가능</span><br><span class="line">console.log([1, 2].concat(arr1, 3));&#x2F;&#x2F;[ 1, 2, 1, 2, 3, 3 ] 배열과 숫자 혼합 가능</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const arr1 &#x3D; [3, 4];</span><br><span class="line"></span><br><span class="line">arr.unshift(1, 2);</span><br><span class="line"></span><br><span class="line">console.log(arr1); &#x2F;&#x2F; [1,2,3,4]</span><br><span class="line"></span><br><span class="line">arr1.push(5, 6);</span><br><span class="line"></span><br><span class="line">console.log(arr1); &#x2F;&#x2F; [1, 2, 3, 4, 5, 6]</span><br><span class="line"></span><br><span class="line">const arr2 &#x3D; [3, 4];</span><br><span class="line"></span><br><span class="line">let result &#x3D; [1, 2].concat(arr2);</span><br><span class="line"></span><br><span class="line">console.log(result); &#x2F;&#x2F;[1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">result &#x3D; result.concat(5, 6);</span><br><span class="line">console.log(result); &#x2F;&#x2F; [1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Array.prototype.concat 메서드 스프레드 문법 대체</span><br><span class="line">const arr1 &#x3D; [1, 2];</span><br><span class="line"></span><br><span class="line">let result &#x3D; [0, ...arr1, 3, 4];</span><br><span class="line">console.log(result); &#x2F;&#x2F; [0, 1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">result &#x3D; [...result, ...[5, 6]];</span><br><span class="line"></span><br><span class="line">console.log(result); &#x2F;&#x2F; [0, 1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure>



<h3 id="Array-prototype-splice"><a href="#Array-prototype-splice" class="headerlink" title="Array.prototype.splice"></a>Array.prototype.splice</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, 2, 3, 4];</span><br><span class="line"></span><br><span class="line">const result &#x3D; arr.splice(1, 2, 20, 30);</span><br><span class="line"></span><br><span class="line">console.log(result); &#x2F;&#x2F; [2, 3]</span><br><span class="line"></span><br><span class="line">console.log(arr);[1, 20, 30, 4]</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const arr1 &#x3D; [1, 2, 3];</span><br><span class="line"></span><br><span class="line">console.log(arr1.splice(1,1,1)); &#x2F;&#x2F; [2] 제거한 요소를 배열로 반환</span><br><span class="line">console.log(arr1); &#x2F;&#x2F; [ 1, 1, 3 ] 원본 배열 직접 변경</span><br><span class="line"></span><br><span class="line">arr1.splice(1,0, [3,4]);</span><br><span class="line">console.log(arr1); &#x2F;&#x2F;[ 1, [ 3, 4 ], 1, 3 ] 배열 요소 전달시 그대로 저장</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 특정 요소 모두 제거</span><br><span class="line">function remove(arr, item) &#123;</span><br><span class="line">  if(!(Array.isArray(arr))) &#123;</span><br><span class="line">    throw new TypeError(&#96;$&#123;arr&#125; is not array&#96;);</span><br><span class="line">  &#125;</span><br><span class="line">  let index &#x3D; arr.indexOf(item);</span><br><span class="line"></span><br><span class="line">  if(!(index &#x3D;&#x3D;&#x3D; -1)) &#123;</span><br><span class="line">    arr.splice(index, 1);</span><br><span class="line">    return remove(arr, item);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(remove([1, 2, 3, 2, 4, 5, 2], 2)); &#x2F;&#x2F; [1, 3, 4, 5]</span><br></pre></td></tr></table></figure>



<h3 id="Array-prototype-slice"><a href="#Array-prototype-slice" class="headerlink" title="Array.prototype.slice"></a>Array.prototype.slice</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Array-prototype-join"><a href="#Array-prototype-join" class="headerlink" title="Array.prototype.join"></a>Array.prototype.join</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, 2, 3, 4];</span><br><span class="line"></span><br><span class="line">arr.join(); &#x2F;&#x2F; 1, 2, 3, 4</span><br><span class="line"></span><br><span class="line">console.log(arr);</span><br><span class="line">&#x2F;&#x2F;[1, 2, 3, 4]</span><br></pre></td></tr></table></figure>



<h3 id="Array-prototype-reverse"><a href="#Array-prototype-reverse" class="headerlink" title="Array.prototype.reverse"></a>Array.prototype.reverse</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, 2, 3];</span><br><span class="line"></span><br><span class="line">const result &#x3D; arr.reverse();</span><br><span class="line"></span><br><span class="line">console.log(arr); [3, 2, 1];</span><br><span class="line">console.log(result); [3, 2, 1]</span><br></pre></td></tr></table></figure>





<h3 id="Array-prototype-fill"><a href="#Array-prototype-fill" class="headerlink" title="Array.prototype.fill"></a>Array.prototype.fill</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, 2, 3];</span><br><span class="line"></span><br><span class="line">const res &#x3D; arr.fill(0);</span><br><span class="line"></span><br><span class="line">console.log(arr); &#x2F;&#x2F; [0, 0, 0]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, 2, 3];</span><br><span class="line"></span><br><span class="line">arr.fill(0, 1);</span><br><span class="line"></span><br><span class="line">console.log(arr); &#x2F;&#x2F; [1, 0, 0]</span><br></pre></td></tr></table></figure>







<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const todos &#x3D; [</span><br><span class="line">    &#123; id: 4, content: &#39;JavaScript&#39;&#125;,</span><br><span class="line">    &#123; id: 1, content: &#39;HTML&#39;&#125;,</span><br><span class="line">    &#123; id: 2, content: &#39;CSS&#39;&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">function compare(key) &#123;</span><br><span class="line">    return (a, b) &#x3D;&gt; (a[key] &gt; b[key] ? 1 : (a[key] &gt; b[key] ? -1 : 0));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">todos.sort(compare(&#39;content&#39;));</span><br><span class="line">console.log(todos);</span><br><span class="line"></span><br><span class="line">todos.sort(compare(&#39;content&#39;));</span><br><span class="line">console.log(todos);</span><br></pre></td></tr></table></figure>



<h3 id="Array-prototype-forEach"><a href="#Array-prototype-forEach" class="headerlink" title="Array.prototype.forEach"></a>Array.prototype.forEach</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const numbers &#x3D; [1, 2, 3];</span><br><span class="line">let pows &#x3D; [];</span><br><span class="line"></span><br><span class="line">for(let i &#x3D; 0; i &lt; numbers.length; i++) &#123;</span><br><span class="line">    pows.push(numbers[i] ** 2);</span><br><span class="line">&#125;</span><br><span class="line">console.log(pows); [1, 4, 9]</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const numbers &#x3D; [1, 2, 3];</span><br><span class="line">let pows &#x3D; [];</span><br><span class="line"></span><br><span class="line">numbers.forEach(item &#x3D;&gt; pows.push(item ** 2));</span><br><span class="line">console.log(pows);</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].forEach((item, index, arr) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#96;요소값: $&#123;item&#125;, 인덱스: $&#123;index&#125;, this: $&#123;JSON.stringify(arr)&#125;&#96;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const numbers &#x3D; [1, 2, 3];</span><br><span class="line"></span><br><span class="line">numbers.forEach((item, index, arr) &#x3D;&gt; &#123; arr[index] &#x3D; item ** 2;&#125;);</span><br><span class="line">console.log(numbers);</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Numbers &#123;</span><br><span class="line">    numberArray &#x3D; [];</span><br><span class="line">    </span><br><span class="line">    multiply(arr) &#123;</span><br><span class="line">        arr.forEach(function (item)&#123;</span><br><span class="line">            this.numberArray.push(item * item);</span><br><span class="line">        &#125;); &#x2F;&#x2F;TypeError</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const numbers &#x3D; new Numbers();</span><br><span class="line">numbers.multiply([1, 2, 3]);</span><br></pre></td></tr></table></figure>



<h3 id="Array-prototype-map"><a href="#Array-prototype-map" class="headerlink" title="Array.prototype.map"></a>Array.prototype.map</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const numbers &#x3D; [1, 4, 9];</span><br><span class="line"></span><br><span class="line">const roots &#x3D; numbers.map(item &#x3D;&gt; Math.sqrt(item));</span><br><span class="line"></span><br><span class="line">console.log(roots);</span><br><span class="line"></span><br><span class="line">console.log(numbers);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].map((item, index, arr) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#96;item, index, JSON.stringify(arr)&#96;);</span><br><span class="line">    return item;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Prefixer &#123;</span><br><span class="line">    constructor(prefix) &#123;</span><br><span class="line">        this.prefix &#x3D; prefix;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    add(arr) &#123;</span><br><span class="line">        return arr.map(function (item) &#123;</span><br><span class="line">            return this.prefix + item;</span><br><span class="line">        &#125;, this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const prefixer &#x3D; new Prefixer(&#39;-webkit-&#39;);</span><br><span class="line">console.log(prefixer.add([&#39;transition&#39;, &#39;user-select&#39;]));</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Prefixer &#123;</span><br><span class="line">    constructor(prefix) &#123;</span><br><span class="line">        this.prefix &#x3D; prefix;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    add(arr) &#123;</span><br><span class="line">        arr.map((item) &#x3D;&gt; this.prefix + item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Array-prototype-filter"><a href="#Array-prototype-filter" class="headerlink" title="Array.prototype.filter"></a>Array.prototype.filter</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const numbers &#x3D; [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">const odds &#x3D; numbers.filter(item &#x3D;&gt; item % 2);</span><br><span class="line"></span><br><span class="line">console.log(odds);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].filter((item, index, arr) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#96;$&#123;item, index, JSON.stringify(arr)&#125;&#96;);</span><br><span class="line">    return item % 2;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Users &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.users &#x3D; [</span><br><span class="line">            &#123; id: 1, name: &#39;Lee&#39;&#125;,</span><br><span class="line">            &#123; id: 2, name: &#39;Kim&#39;&#125;</span><br><span class="line">        ];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    findById(id) &#123;</span><br><span class="line">        return this.users.filter(user &#x3D;&gt; user.id &#x3D;&#x3D;&#x3D; id);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    remove(id) &#123;</span><br><span class="line">        this.users &#x3D; this.user.filter(user.id !&#x3D;&#x3D; id)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Array-prototype-reduce"><a href="#Array-prototype-reduce" class="headerlink" title="Array.prototype.reduce"></a>Array.prototype.reduce</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const sum &#x3D; [1, 2, 3, 4].reduce((accumulator, currentValue, index, array) &#x3D;&gt; accumulator + currentValue, 0);</span><br><span class="line"></span><br><span class="line">console.log(sum); &#x2F;&#x2F;10</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const values &#x3D; [1, 2, 3, 4, 5, 6];</span><br><span class="line"></span><br><span class="line">const average &#x3D; values.reduce((acc, cur, i, &#123; length&#125;) &#x3D;&gt; &#123;</span><br><span class="line">    return i &#x3D;&#x3D;&#x3D; length - 1 ? (acc + cur) &#x2F; length : acc + cur;</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">console.log(average);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const values &#x3D; [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">const max &#x3D; values.reduce((acc, cur) &#x3D;&gt; (acc &gt; cur ? acc : cur), 0);</span><br><span class="line"></span><br><span class="line">console.log(max);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const values &#x3D; [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">const max &#x3D; Math.max(...values);</span><br><span class="line"></span><br><span class="line">console.log(max);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const fruits &#x3D; [&#39;banana&#39;, &#39;apple&#39;, &#39;orange&#39;, &#39;orange&#39;, &#39;apple&#39;];</span><br><span class="line"></span><br><span class="line">const count &#x3D; fruits.reduce((acc, cur) &#x3D;&gt; &#123;</span><br><span class="line">    acc[cur] &#x3D; (acc[cur] || 0) + 1;</span><br><span class="line">    return acc;</span><br><span class="line">&#125;, &#123;&#125;);</span><br><span class="line"></span><br><span class="line">console.log(count);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const values &#x3D; [1, [2, 3], 4, [5, 6]];</span><br><span class="line">const flatten &#x3D; values.reduce((acc, cur) &#x3D;&gt; acc.concat(cur), []);</span><br><span class="line">console.log(flatten);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1, [2, 3], 4, [5, 6]].flat();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const values &#x3D; [1, 2, 1, 3, 5, 4, 5, 3, 4, 4];</span><br><span class="line"></span><br><span class="line">const result &#x3D; [... Set(values)];</span><br><span class="line">console.log</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const values &#x3D; [1, 2, 1, 3, 5, 4, 5, 3, 4, 4];</span><br><span class="line"></span><br><span class="line">const result &#x3D; values.filter((acc, cur, i, arr) &#x3D;&gt; &#123;&#125;)</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const values &#x3D; [1, 2, 1, 3, 5, 4, 5, 3, 4, 4];</span><br><span class="line"></span><br><span class="line">const result &#x3D; values.reduce((acc, cur, i, arr) &#x3D;&gt; &#123;</span><br><span class="line">    if (arr.indexOf(cur) &#x3D;&#x3D;&#x3D; i)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>





<h3 id="Array-prototype-map-1"><a href="#Array-prototype-map-1" class="headerlink" title="Array.prototype.map"></a>Array.prototype.map</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const numbers &#x3D; [1, 4, 9]</span><br><span class="line"></span><br><span class="line">const roots &#x3D; numbers.map(item &#x3D;&gt; Math.sqrt(item));</span><br><span class="line"></span><br><span class="line">console.log(roots);</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3]</span><br><span class="line"></span><br><span class="line">console.log(numbers); [1, 4, 9]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].map((item,index, arr) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#96;$&#123;item, index, JSON.stringify(arr)&#125;&#96;);</span><br><span class="line">    return item;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Prefixer &#123;</span><br><span class="line">    constructor(prefix) &#123;</span><br><span class="line">        this.prefix &#x3D; prefix;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    add(arr) &#123;</span><br><span class="line">        return arr.map(item &#x3D;&gt; this.prefix + item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="Array-prototype-filter-1"><a href="#Array-prototype-filter-1" class="headerlink" title="Array.prototype.filter"></a>Array.prototype.filter</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const numbers &#x3D; [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">const odds &#x3D; numbers.filter(item &#x3D;&gt; item % 2);</span><br><span class="line">console.log(odds);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].filter((item, index, arr) &#x3D;&gt; &#123;</span><br><span class="line">    return item %2;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Users &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.users &#x3D; [</span><br><span class="line">            &#123;id : 1, name: &#39;Lee&#39;&#125;,</span><br><span class="line">            &#123;id : 2, name: &#39;Kim&#39;&#125;</span><br><span class="line">        ];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    findById(id) &#123;</span><br><span class="line">        return this.users.filter(item &#x3D;&gt; item.id &#x3D;&#x3D;&#x3D; id);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    remove(id) &#123;</span><br><span class="line">        this.users &#x3D; this.users.filter(item &#x3D;&gt; item.id !&#x3D;&#x3D; id);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jjm2317.github.io/2020/10/21/javascript-ArrayPractice/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jeong Jiman">
      <meta itemprop="description" content="All Dev stories found in here.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeong Jiman's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/21/javascript-ArrayPractice/" class="post-title-link" itemprop="url">javascript ArrayPractice</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-21 18:35:43" itemprop="dateCreated datePublished" datetime="2020-10-21T18:35:43+09:00">2020-10-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-30 13:39:16" itemprop="dateModified" datetime="2021-03-30T13:39:16+09:00">2021-03-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-html-생성"><a href="#1-html-생성" class="headerlink" title="1. html 생성"></a>1. html 생성</h1><p>아래 배열을 사용하여 html을 생성하는 함수를 작성하라.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> todos = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">content</span>: <span class="string">&#x27;HTML&#x27;</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">content</span>: <span class="string">&#x27;CSS&#x27;</span>, <span class="attr">completed</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">content</span>: <span class="string">&#x27;Javascript&#x27;</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> html = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  todos.forEach(<span class="function"><span class="params">todo</span> =&gt;</span> &#123;</span><br><span class="line">    html += <span class="string">`&lt;li id = <span class="subst">$&#123;todo.id&#125;</span>&gt;</span></span><br><span class="line"><span class="string">    &lt;label&gt;&lt;input type =&quot;checkbox&quot; <span class="subst">$&#123;todo.completed === <span class="literal">true</span> ? <span class="string">&#x27;checked&#x27;</span> : <span class="string">&#x27;&#x27;</span>&#125;</span>&gt;<span class="subst">$&#123;todo.content&#125;</span>&lt;/label&gt;</span></span><br><span class="line"><span class="string">&lt;/li&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(render());</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt;li id=&quot;3&quot;&gt;</span></span><br><span class="line"><span class="comment">  &lt;label&gt;&lt;input type=&quot;checkbox&quot;&gt;HTML&lt;/label&gt;</span></span><br><span class="line"><span class="comment">&lt;/li&gt;</span></span><br><span class="line"><span class="comment">&lt;li id=&quot;2&quot;&gt;</span></span><br><span class="line"><span class="comment">  &lt;label&gt;&lt;input type=&quot;checkbox&quot; checked&gt;CSS&lt;/label&gt;</span></span><br><span class="line"><span class="comment">&lt;/li&gt;</span></span><br><span class="line"><span class="comment">&lt;li id=&quot;1&quot;&gt;</span></span><br><span class="line"><span class="comment">  &lt;label&gt;&lt;input type=&quot;checkbox&quot;&gt;Javascript&lt;/label&gt;</span></span><br><span class="line"><span class="comment">&lt;/li&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>







<h1 id="2-특정-프로퍼티-값-추출"><a href="#2-특정-프로퍼티-값-추출" class="headerlink" title="2. 특정 프로퍼티 값 추출"></a>2. 특정 프로퍼티 값 추출</h1><p>요소의 프로퍼티(id, content, completed)를 문자열 인수로 전달하면 todos의 각 요소 중, 해당 프로퍼티의 값만을 추출한 배열을 반환하는 함수를 작성하라.</p>
<p>단, for 문이나 Array#forEach는 사용하지 않도록 하자.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> todos = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">content</span>: <span class="string">&#x27;HTML&#x27;</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">content</span>: <span class="string">&#x27;CSS&#x27;</span>, <span class="attr">completed</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">content</span>: <span class="string">&#x27;Javascript&#x27;</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValues</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> todos.map(<span class="function"><span class="params">todo</span> =&gt;</span> todo[key]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getValues(<span class="string">&#x27;id&#x27;</span>)); <span class="comment">// [3, 2, 1]</span></span><br><span class="line"><span class="built_in">console</span>.log(getValues(<span class="string">&#x27;content&#x27;</span>)); <span class="comment">// [&#x27;HTML&#x27;, &#x27;CSS&#x27;, &#x27;Javascript&#x27;]</span></span><br><span class="line"><span class="built_in">console</span>.log(getValues(<span class="string">&#x27;completed&#x27;</span>)); <span class="comment">// [false, true, false]</span></span><br></pre></td></tr></table></figure>



<h1 id="3-프로퍼티-정렬"><a href="#3-프로퍼티-정렬" class="headerlink" title="3. 프로퍼티 정렬"></a>3. 프로퍼티 정렬</h1><p>요소의 프로퍼티(id, content, completed)를 문자열 인수로 전달하면 todos의 요소를 정렬하는 함수를 작성하라.</p>
<p>단, todos는 변경되지 않도록 하자.</p>
<p>참고: <a target="_blank" rel="noopener" href="https://poiemaweb.com/fastcampus/array#91-arrayprototypesort">Array.prototype.sort</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> todos = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">content</span>: <span class="string">&#x27;HTML&#x27;</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">content</span>: <span class="string">&#x27;CSS&#x27;</span>, <span class="attr">completed</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">content</span>: <span class="string">&#x27;Javascript&#x27;</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortBy</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [...todos].sort(<span class="function">(<span class="params">v1, v2</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> v1[key] &gt; v2[key] ? <span class="number">1</span> : (v1[key] &lt; v2[key] ? <span class="number">-1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sortBy(<span class="string">&#x27;id&#x27;</span>));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  &#123; id: 1, content: &#x27;Javascript&#x27;, completed: false &#125;,</span></span><br><span class="line"><span class="comment">  &#123; id: 2, content: &#x27;CSS&#x27;, completed: true &#125;,</span></span><br><span class="line"><span class="comment">  &#123; id: 3, content: &#x27;HTML&#x27;, completed: false &#125;</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">console</span>.log(sortBy(<span class="string">&#x27;content&#x27;</span>));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  &#123; id: 2, content: &#x27;CSS&#x27;, completed: true &#125;,</span></span><br><span class="line"><span class="comment">  &#123; id: 3, content: &#x27;HTML&#x27;, completed: false &#125;,</span></span><br><span class="line"><span class="comment">  &#123; id: 1, content: &#x27;Javascript&#x27;, completed: false &#125;</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">console</span>.log(sortBy(<span class="string">&#x27;completed&#x27;</span>));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  &#123; id: 3, content: &#x27;HTML&#x27;, completed: false &#125;,</span></span><br><span class="line"><span class="comment">  &#123; id: 1, content: &#x27;Javascript&#x27;, completed: false &#125;,</span></span><br><span class="line"><span class="comment">  &#123; id: 2, content: &#x27;CSS&#x27;, completed: true &#125;</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>







<h1 id="4-새로운-요소-추가"><a href="#4-새로운-요소-추가" class="headerlink" title="4. 새로운 요소 추가"></a>4. 새로운 요소 추가</h1><p>새로운 요소(예를 들어 <code>&#123; id: 4, content: &#39;Test&#39;, completed: false &#125;</code>)를 인수로 전달하면 todos의 선두에 새로운 요소를 추가하는 함수를 작성하라. 단, Array#push는 사용하지 않도록 하자.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> todos = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">content</span>: <span class="string">&#x27;HTML&#x27;</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">content</span>: <span class="string">&#x27;CSS&#x27;</span>, <span class="attr">completed</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">content</span>: <span class="string">&#x27;Javascript&#x27;</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">newTodo</span>) </span>&#123;</span><br><span class="line">    todos = [newTodo,...todos];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addTodo(&#123; <span class="attr">id</span>: <span class="number">4</span>, <span class="attr">content</span>: <span class="string">&#x27;Test&#x27;</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(todos);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  &#123; id: 4, content: &#x27;Test&#x27;, completed: false &#125;,</span></span><br><span class="line"><span class="comment">  &#123; id: 3, content: &#x27;HTML&#x27;, completed: false &#125;,</span></span><br><span class="line"><span class="comment">  &#123; id: 2, content: &#x27;CSS&#x27;, completed: true &#125;,</span></span><br><span class="line"><span class="comment">  &#123; id: 1, content: &#x27;Javascript&#x27;, completed: false &#125;</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h1 id="5-특정-요소-삭제"><a href="#5-특정-요소-삭제" class="headerlink" title="5. 특정 요소 삭제"></a>5. 특정 요소 삭제</h1><p>todos에서 삭제할 요소의 id를 인수로 전달하면 해당 요소를 삭제하는 함수를 작성하라.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> todos = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">content</span>: <span class="string">&#x27;HTML&#x27;</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">content</span>: <span class="string">&#x27;CSS&#x27;</span>, <span class="attr">completed</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">content</span>: <span class="string">&#x27;Javascript&#x27;</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeTodo</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    todos = todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.id !== id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">removeTodo(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(todos);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  &#123; id: 3, content: &#x27;HTML&#x27;, completed: false &#125;,</span></span><br><span class="line"><span class="comment">  &#123; id: 1, content: &#x27;Javascript&#x27;, completed: false &#125;</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h1 id="6-특정-요소의-프로퍼티-값-반전"><a href="#6-특정-요소의-프로퍼티-값-반전" class="headerlink" title="6. 특정 요소의 프로퍼티 값 반전"></a>6. 특정 요소의 프로퍼티 값 반전</h1><p>todos에서 대상 요소의 id를 인수로 전달하면 해당 요소의 completed 프로퍼티 값을 반전하는 함수를 작성하라.</p>
<p>hint) 기존 객체의 특정 프로퍼티를 변경/추가하여 새로운 객체를 생성하려면 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">Object.assign</a> 또는 <a target="_blank" rel="noopener" href="https://poiemaweb.com/fastcampus/spread-syntax#3-%EA%B0%9D%EC%B2%B4-%EB%A6%AC%ED%84%B0%EB%9F%B4-%EB%82%B4%EB%B6%80%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EA%B2%BD%EC%9A%B0">스프레드 문법</a>을 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> todos = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">content</span>: <span class="string">&#x27;HTML&#x27;</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">content</span>: <span class="string">&#x27;CSS&#x27;</span>, <span class="attr">completed</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">content</span>: <span class="string">&#x27;Javascript&#x27;</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toggleCompletedById</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    todos = todos.map(<span class="function"><span class="params">todo</span> =&gt;</span> todo.id === id ? &#123;...todo, ...&#123;<span class="attr">completed</span>: !todo.completed&#125;&#125; : &#123;...todo&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">toggleCompletedById(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(todos);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  &#123; id: 3, content: &#x27;HTML&#x27;, completed: false &#125;,</span></span><br><span class="line"><span class="comment">  &#123; id: 2, content: &#x27;CSS&#x27;, completed: false &#125;,</span></span><br><span class="line"><span class="comment">  &#123; id: 1, content: &#x27;Javascript&#x27;, completed: false &#125;</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="7-모든-요소의-completed-프로퍼티-값을-true로-설정"><a href="#7-모든-요소의-completed-프로퍼티-값을-true로-설정" class="headerlink" title="7. 모든 요소의 completed 프로퍼티 값을 true로 설정"></a>7. 모든 요소의 completed 프로퍼티 값을 true로 설정</h1><p>todos의 모든 요소의 completed 프로퍼티 값을 true로 설정하는 함수를 작성하라.</p>
<p>hint) 기존 객체의 특정 프로퍼티를 변경/추가하여 새로운 객체를 생성하려면 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">Object.assign</a> 또는 <a target="_blank" rel="noopener" href="https://poiemaweb.com/fastcampus/spread-syntax#3-%EA%B0%9D%EC%B2%B4-%EB%A6%AC%ED%84%B0%EB%9F%B4-%EB%82%B4%EB%B6%80%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EA%B2%BD%EC%9A%B0">스프레드 문법</a>을 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> todos = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">content</span>: <span class="string">&#x27;HTML&#x27;</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">content</span>: <span class="string">&#x27;CSS&#x27;</span>, <span class="attr">completed</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">content</span>: <span class="string">&#x27;Javascript&#x27;</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toggleCompletedAll</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   todos = todos.map(<span class="function">(<span class="params">todo</span>) =&gt;</span> &#123;</span><br><span class="line">       todo = &#123;...todo,...&#123;<span class="attr">completed</span> : <span class="literal">true</span>&#125;&#125;;</span><br><span class="line">       <span class="keyword">return</span> todo;</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">toggleCompletedAll();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(todos);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  &#123; id: 3, content: &#x27;HTML&#x27;, completed: true &#125;,</span></span><br><span class="line"><span class="comment">  &#123; id: 2, content: &#x27;CSS&#x27;, completed: true &#125;,</span></span><br><span class="line"><span class="comment">  &#123; id: 1, content: &#x27;Javascript&#x27;, completed: true &#125;</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="8-completed-프로퍼티의-값이-true인-요소의-갯수-구하기"><a href="#8-completed-프로퍼티의-값이-true인-요소의-갯수-구하기" class="headerlink" title="8. completed 프로퍼티의 값이 true인 요소의 갯수 구하기"></a>8. completed 프로퍼티의 값이 true인 요소의 갯수 구하기</h1><p>todos에서 완료(completed: true)한 할일의 갯수를 구하는 함수를 작성하라.</p>
<p>단, for 문, Array#forEach는 사용하지 않도록 하자.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> todos = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">content</span>: <span class="string">&#x27;HTML&#x27;</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">content</span>: <span class="string">&#x27;CSS&#x27;</span>, <span class="attr">completed</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">content</span>: <span class="string">&#x27;Javascript&#x27;</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countCompletedTodos</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.completed === <span class="literal">true</span>).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(countCompletedTodos()); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h1 id="9-id-프로퍼티의-값-중에서-최대값-구하기"><a href="#9-id-프로퍼티의-값-중에서-최대값-구하기" class="headerlink" title="9. id 프로퍼티의 값 중에서 최대값 구하기"></a>9. id 프로퍼티의 값 중에서 최대값 구하기</h1><p>todos의 id 프로퍼티의 값 중에서 최대값을 구하는 함수를 작성하라.</p>
<p>단, for 문, Array#forEach는 사용하지 않도록 하자.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> todos = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">content</span>: <span class="string">&#x27;HTML&#x27;</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">content</span>: <span class="string">&#x27;CSS&#x27;</span>, <span class="attr">completed</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">content</span>: <span class="string">&#x27;Javascript&#x27;</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMaxId</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> todos.length ? <span class="built_in">Math</span>.max(...todos.map(<span class="function"><span class="params">todo</span> =&gt;</span> todo.id)) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getMaxId()); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jjm2317.github.io/2020/10/19/javascript-push-pop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jeong Jiman">
      <meta itemprop="description" content="All Dev stories found in here.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeong Jiman's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/19/javascript-push-pop/" class="post-title-link" itemprop="url">javascript push&pop</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-19 15:08:23" itemprop="dateCreated datePublished" datetime="2020-10-19T15:08:23+09:00">2020-10-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-30 13:39:16" itemprop="dateModified" datetime="2021-03-30T13:39:16+09:00">2021-03-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="javascript-push-pop"><a href="#javascript-push-pop" class="headerlink" title="javascript push, pop"></a>javascript push, pop</h1><h2 id="push-amp-pop"><a href="#push-amp-pop" class="headerlink" title="push &amp; pop"></a>push &amp; pop</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.myPush &#x3D; function( ...args) &#123;</span><br><span class="line">  for(let i &#x3D; 0; i&lt; args.length; i++)&#123;</span><br><span class="line">    this[this.length] &#x3D; args[i];</span><br><span class="line">  &#125;</span><br><span class="line">  return this.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array.prototype.myPop &#x3D; function() &#123;</span><br><span class="line">  let res;</span><br><span class="line">  res &#x3D; this[this.length-1];</span><br><span class="line">  this.length &#x3D; this.length - 1;</span><br><span class="line"></span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br><span class="line">const a &#x3D; [1, 2, 3]</span><br><span class="line"></span><br><span class="line">console.log(a.myPush(3,4));</span><br><span class="line">console.log(a);</span><br><span class="line">console.log(a.myPop());</span><br><span class="line">console.log(a);</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">5</span><br><span class="line">[ 1, 2, 3, 3, 4 ]</span><br><span class="line">4</span><br><span class="line">[ 1, 2, 3, 3 ]</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jjm2317.github.io/2020/09/29/javascript-19Prototype/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jeong Jiman">
      <meta itemprop="description" content="All Dev stories found in here.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeong Jiman's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/29/javascript-19Prototype/" class="post-title-link" itemprop="url">javascript 19Prototype</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-29 22:17:59" itemprop="dateCreated datePublished" datetime="2020-09-29T22:17:59+09:00">2020-09-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-30 13:39:16" itemprop="dateModified" datetime="2021-03-30T13:39:16+09:00">2021-03-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="프로토타입"><a href="#프로토타입" class="headerlink" title="프로토타입"></a>프로토타입</h1><p><strong>자바스크립트의 패러다임</strong></p>
<p>자바스크립트는 명령형(imperative), 함수형(functional), 프로토타입기반(prototype-based) 객체지향 프로그래밍(OOP;Object Oriented Programming)을 지원하는 멀티 패러다임 프로그래밍 언어다.</p>
<p><strong>다른 객체지향 언어와의 자이</strong></p>
<p>C++이나 JAVA 같은 클래스 기반 객체지향 프로그래밍 언어의 특징인 클래스와 상속, 캡슐화를 위한 키워드인 public, private, protected 등이 없어서 자바스크립트는 객체지향 언어가 아니라고 오해를 받ㄱ는 경우도 있다. 하지만 자바스크립트는 클래스 기반 객체지향 프로그래밍 언어보다 효율적이며 더 강력한 객체 지향 프로그래밍 능력을 지니고 있는 프로토타입 기반의 객체지향 프로그래밍 언어다. </p>
<p><strong>자바스크립트의 클래스(class)</strong></p>
<p>ES6에서 클래스가 도입되었다. 하지만 ES6의 클래스가 기존의 프로토타입 기반 객체지향 모델을 퍠지하고 새로운 객체지향 모델을 제공하는 것은 아니다. </p>
<p>사실 클래스도 함수이며, 기존 프로토타입 기반 패턴의 문법적 설탕(syntactic sugar)이라고 볼 수 있다. </p>
<p>클래스와 생성자 함수는 모두 프로토타입 기반의 인스턴스를 생성하지만 정확히 동일하게 동작하지는 않는다. 클래스는 생성자 함수보다 엄격하며 클래스는 생성자 함수에서는 제공하지 않는 기능도 제공한다. </p>
<p>따라서 클래스를 프로토타입 기반 객체 생성 패턴의 단순한 문법적 설탕으로 보기보다는 새로운 객체 생성 메커니즘으로 보는것이 더 합당하다.</p>
<p><strong>자바스크립트는 핵심 : 객체</strong></p>
<p>자바스크립트는 객체 기반의 프로그래밍 언어이며 자바스크립트를 이루고 있는 거의 모든것이 객체다. 원시타입(primitive type)의 값을 제외한 나머지 값들 (함수, 배열, 정규표현식 등)은 모두 객체다.</p>
<h2 id="1-객체-지향-프로그래밍"><a href="#1-객체-지향-프로그래밍" class="headerlink" title="1. 객체 지향 프로그래밍"></a>1. 객체 지향 프로그래밍</h2><p><strong>객체지향 프로그래밍이란</strong></p>
<p>객체지향 프로그래밍(Object Oriented Programming, OOP)은 프로그램을 명령어 또는 함수의 목록으로 보는 전통적인 명령형 프로그래밍(imperativie programming)의 절차지향적 관점에서 벗어나 여러 개의 독립적 단위인 객체(object)의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임을 말한다. </p>
<p><strong>객체의 의미</strong></p>
<p>객체지향 프로그래밍은 실세계의 실체(사물이나 개념)룰 인식하는 철학적 사고를 프로그래밍에 접목하려는 시도에서 시작한다. 실체는 특징이나 성질을 나타내는 속성(attribut/ property)를 가지고 있고, 이를 통해 실체를 인식하거나 구별할 수 있따. </p>
<p>예를들어, 사람은 다음과 같은 속성을 갖는다.</p>
<ul>
<li>이름</li>
<li>주소</li>
<li>성별</li>
<li>나이</li>
<li>신장</li>
<li>학력</li>
<li>직업</li>
<li>등등</li>
</ul>
<p>위의 속성들에 대응되는 구체적인 값을 넣어주면, 예를들어 “이름이 정지만, 나이는 23세, 성별은 남자인 사람”과 같이 속성을 구체적으로 표현하면 특정사람을 다른사람과 구별하여 인식할 수 있다. </p>
<p>이러한 방식을 프로그래밍에 접목시킨것이 객체지향 프로그래밍이다.</p>
<p>객체지향 프로그래밍 시 우리는 객체의 필요한 속성, 일부 속성만 추려내어 객체를 표현한다. 이를 추상화라고 한다. </p>
<p>**추상화 예시 **</p>
<p>사람을 구현하려고 한다. 사람에게는 위에서 기술한 것과 같이 수많은 속성을 가지고 있다. 하지만 우리가 구현하려는 프로그램은 사람의 이름과 나이만 관심을 가지고 있다고 가정한다. 이처럼 여러 속성 중에서 프로그램에 필요한 속성만 간추려내어 표현하는 것을 추상화(abstraction)이라고 한다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; &#123;</span><br><span class="line">    name: &#39;jiman&#39;,</span><br><span class="line">    age: 23</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>객체 지향 프로그래밍과 객체</strong></p>
<p>프로그래머는 객체(object)를 다루는 주체(subject)라고 할 수 있다. 우리는 위 예제에서 만든 person 객체의 속성인 이름과 나이를 보고 다른 객체와 구별하여 인식할 수 있다. </p>
<p>즉 객체는 속성을 통해 열 개의 값을 하나의 단위로 구성한 복합적인 자료구조를 말한다. 객체지향 프로그래밍은 독립적인 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임이다. </p>
<p><strong>객체의 상태(state)와 동작(behavior)</strong></p>
<p>원(Circle)이라는 개념을 객체로 만들어보자. 원에는 반지름이라는 속성이 있다. 이 반지름을 가지고 원의 지름, 둘레, 넓이를 구할 수 있다. 이때 반지름은 원의 상태를 나타내는 데이터이며, 원의 지름, 둘레, 넓이를 구하는 것은 동작이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const Circle &#x3D; &#123;</span><br><span class="line">    radius: 5,</span><br><span class="line">    </span><br><span class="line">    getDiameter() &#123;</span><br><span class="line">        return 2 * this.radius;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    getPerimeter() &#123;</span><br><span class="line">        return 2 * this.radius * Math.PI;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    getArea() &#123;</span><br><span class="line">        return Math.PI * this.radius ** 2;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>



<p>위 예제와 같이 객체지향 프로그래밍은 객체의 상태(state)를 나타내는 데이터와 상태 데이터를 조작할 수 있는 동작(behavior)을 하나의 논리적인 단위로 묶어 생각한다 </p>
<p>객체는 상태 데이터와 동작을 하나의 논리적인 단위로 묶은 복합적인 자료구조라고 할 수 있다. 객체의 상태 데이터를 property, 동작을 method라고 한다.</p>
<p><strong>객체의 관계성(relationship)</strong></p>
<p>각 객체는 고유의 기능을 갖는 독립적인 부품으로 볼 수 있지만 자신의 고유한 기능을 수행하면서 다른 객체와 관계성(relationship)을 가질 수 있다. 다른 객체와 메시지를 주고 받거나 데이터를 처리할 수도 있다.  또는 다른 객체의 상태 데이터나 동작을 상속받아 사용하기도 한다. </p>
<h2 id="2-상속과-프로토타입"><a href="#2-상속과-프로토타입" class="headerlink" title="2. 상속과 프로토타입"></a>2. 상속과 프로토타입</h2><p><strong>상속이란</strong></p>
<p>상속(inheritance)은 객체지향프로그래밍의 핵심 개념으로, 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것을 말한다. </p>
<p><strong>상속의 역할</strong></p>
<p>자바스크립트는 프로토타입을 기반으로 상속을 구현하여 불필요한 중복을 제거한다. 중복을 제거하는 방법은 기존의 코드를 적극적으로 재사용하는 것이다. 코드 재사용은 개발 비용을 현저히 줄일 수 있는 잠재력이 있으므로 매우 중요하다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;생성자 함수</span><br><span class="line">function Circle(radius) &#123;</span><br><span class="line">    this.radius &#x3D; radius;</span><br><span class="line">    </span><br><span class="line">    this.getDiameter &#x3D; function() &#123;</span><br><span class="line">        return 2 * this.radius;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    this.getPerimeter &#x3D; function() &#123;</span><br><span class="line">        return 2 * Math.PI * this.radius;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    this.getArea &#x3D; function() &#123;</span><br><span class="line">        return Math.PI * this.radius ** 2;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const circle1 &#x3D; new Circle(5);</span><br><span class="line">const circle2 &#x3D; new Circle(10);</span><br></pre></td></tr></table></figure>

<p>위 예제와 같이 생성자 함수는 동일한 프로퍼티 구조를 갖는 객체를 여러개 생성할 때 유용하다. </p>
<p><strong>위 예제 생성자 함수의 문제점</strong></p>
<p>Circle 생성자 함수가 생성하는 모든 객체(instance)는 radius 프로퍼티와 메서드들을 갖는다. radius 프로퍼티값은 보통 인스턴스마다 다르다. 하지만 getDiameter, getPerimeter, getArea 메서드는 모든 인스턴스들이 동일한 내용의 메서드를 사용하므로 단 하나만 생성하여 모든 인스턴스가 공유해서 사용하는 것이 바람직하다. </p>
<p>하지만, 위 예제의 Circle 생성자 함수의 경우 인스턴스를 생성할 때마다 메서드들을 중복 생성하고 모든 인스턴스가 중복해서 소유한다. </p>
<p>즉, 동일한 생성자 함수에 의해 생성된 모든 인스턴스가 동일한 메서드를 중복 소유하는 것은 메모리를 불필요하게 낭비한다. 또한 인스턴스를 생성할 때마다 메서드를 생성하므로 퍼포먼스에도 악영향을 준다. </p>
<p>즉 공간적, 시간적으로 손해가 생긴다.</p>
<p><strong>상속을 통한 중복 제거</strong></p>
<p>상속을 통해 위 예제의 Circle의 불필요한 중복을 제거해본다. 자바스크립트는 프로토타입(prototype)을 기반으로 상속을 구현한다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Circle(radius) &#123;</span><br><span class="line">    this.radius &#x3D; radius;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 중복 제거하고자 하는 프로퍼티 메서드는 프로토타입에 추가</span><br><span class="line">Circle.prototype.getDiameter &#x3D; function() &#123;</span><br><span class="line">    return 2 * this.radius;</span><br><span class="line">&#125;</span><br><span class="line"> Circle.prototype.getPerimeter &#x3D; function() &#123;</span><br><span class="line">    return Math.PI * 2 * this.radius;</span><br><span class="line">&#125;</span><br><span class="line">Circle.prototype.getArea &#x3D; function() &#123;</span><br><span class="line">    return Math.PI * this.radius ** 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;인스턴스 생성</span><br><span class="line">const circle1 &#x3D; new Circle(5);</span><br><span class="line">const circle2 &#x3D; new Circle(10);</span><br><span class="line"></span><br><span class="line">console.log(circle1.getArea &#x3D;&#x3D;&#x3D; circle2.getArea); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>



<p><strong>프로토타입 기반 상속의 원리</strong></p>
<p>Circle 생성자 함수가 생성한 모든 인스턴스는 자신의 프로토타입, 즉 상위 객체 역할을 하는 Circle.prototype의 모든 프로퍼티와 메서드를 상속받는다.</p>
<p>메서드들은 단 한번만 생성되어 프로토타입인 Circle.prototype의 메서드로 할당되어 있다. 따라서 Circle 생성자 함수가 생성하는 모든 인스턴스는 해당 메서드들을 상속받아 사용할 수 있다. 즉, 자신의 상태를 나타내는 radius 프로퍼티만 개별적으로 소유하고 내용이 동일한 메서드는 상속을 통해 공유하여 사용하는 것이다. </p>
<p><strong>상속의 장점</strong></p>
<p>상속은 코드의 재사용이란 관점에서 매우 유용하다. 생성자 함수가 생성할 모든 인스턴스가 공통적으로 사용할 프로퍼티나 메서드를 프로토타입에 미리 구현해 두면 생성자 함수가 생성할 모든 인스턴스는 별도의 구현없이 상위(부모)객체인 프로토타입의 자산을 공유하여 사용할 수 있다.</p>
<h2 id="3-프로토타입-객체"><a href="#3-프로토타입-객체" class="headerlink" title="3. 프로토타입 객체"></a>3. 프로토타입 객체</h2><p><strong>프로토타입 객체란</strong></p>
<p>프로토타입 객체란 객체지향 프로그래밍의 근간을 이루는 객체 간 상속(inheritance)을 구현하기 위해 사용된다. 프로토타입은 어떤 객체의 상위(부모) 객체의 역할을 하는 객체로서 다른 객체에 공유 프로퍼티(메서드 포함)를 제공한다. 프로토타입을 상속받은 하위 객체는 상위 객체의 프로퍼티를 자신의 프로퍼티처럼 자유롭게 사용할 수 있다. </p>
<p><strong>프로토타입 내부슬롯 [[Prototype]]</strong></p>
<p>모든 객체는 [[Prototype]]이라는 내부 슬롯을 가지며, 이 내부 슬롯의 값은 프로토타입의 참조([[Prototype]]의 값이 null 인 경우도 있다.)다. [[Prototype]]에 저장되는 프로토타입은 <strong>객체 생성 방식</strong>에 의해 결정된다. 즉 객체가 생성될 때 객체 생성 방식에 따라 프로토타입이 결정되고 [[Prototype]]에 저장된다.  </p>
<p><strong>객체 생성방식에 따른 prototype 객체</strong></p>
<p>예시로, 객체 리터럴에 의해 생성된 객체의 프로토타입은 Object.prototype 이고 생성자 함수에 의해 생성된 객체의 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체다. </p>
<p><strong>생성자 함수와 프로토타입</strong></p>
<p>모든 객체는 하나의 프로토타입을 갖는다.([[Prototype]]값이 null 인 객체는 프로토타입이 없다.)  그리고 모든 프로토타입은 생성자 함수와 연결되어 있다. </p>
<ul>
<li>생성자 함수의 prototype 프로퍼티는 생성자 함수의 prototype을 가리킨다.</li>
<li>생성자 함수.prototype의 constructor 프로퍼티는 생성자 함수를 가리킨다.</li>
<li>생성자 함수가 생성한 인스턴스는 포로토타입의 프로퍼티를 상속받는다</li>
<li>생성자 함수에서 <code>__proto__</code>접근자 프로퍼티로 프로토타입에 간접적으로 접근할 수 있다. </li>
</ul>
<p>[[Prototype]] 내부슬롯에 직접 접근할 수 없지만, 접근자 프로퍼티를 통해 자신의 프로토타입, 즉 [[Prototype]]내부슬롯이 가리키는 프로토타입에 간접적으로 접근 가능하다. </p>
<p>프로토타입은 자신의 constructor 프로퍼티를 통해 생성자 함수에 접근할 수 있고, 생성자 함수는 자신의 prototype 프로퍼티를 통해 프로토타입에 접근할 수 있다. </p>
<h3 id="3-1-proto-접근자-프로퍼티"><a href="#3-1-proto-접근자-프로퍼티" class="headerlink" title="3.1 __proto__접근자 프로퍼티"></a>3.1 <code>__proto__</code>접근자 프로퍼티</h3><p><strong><code>__proto__</code>접근자 프로퍼티의 기능</strong></p>
<p>모든 객체는 <code>__proto__</code>접근자 프로퍼티를 통해 자신의 프로토타입인  [[Prototype]]내부슬롯에 간접적으로 접근할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const student &#x3D; &#123;</span><br><span class="line">    name: &#39;jiman&#39;;</span><br><span class="line">&#125;;</span><br><span class="line">student.__proto;</span><br></pre></td></tr></table></figure>

<p>일반 객체에 <code>__proto__</code>접근자 프로퍼티를 사용하면  [[Prototype]]내부 슬롯이 가리키는 객체인 Object.prototype에 접근할 수 있다.</p>
<p>모든 객체는 이 접근자 프로퍼티를 통해 프로토타입을 가리키는 [[Prototype]] 내부슬롯에 접근할 수 있다.</p>
<p><strong><code>__proto__</code>는 접근자 프로퍼티다</strong></p>
<p><strong>[[Prototype]] 내부슬롯으로의 접근</strong></p>
<p>내부슬롯은 프로퍼티가 아니다. 자바스크립트는 원칙적으로 내부슬롯과 내부 메서드에 직접적으로 접근하거나 호출할 수 있는 방법을 제공하지 않는다. </p>
<p>단, 일부 내부 슬롯과 내부 메서드에 한하여 간접적으로 접근할 수 있는 수단을 제공한다. [[Prototype]] 내부 슬롯에도 직접 접근할 수 없으며 <code>__proto__</code>접근자 프로퍼티를 통해 간접적으로 [[Prototype]] 내부슬롯의 값, 즉 프로토타입에 접근할 수 있다.</p>
<p><strong>접근자 프로퍼티의 특징</strong></p>
<p>접근자 프로퍼티는 자체적으로 값([[Value]]프로퍼티 어트리뷰트)을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수(accessor function), 즉 [[Get]], [[Set]] 프로퍼티 어트리뷰트로 구성된 프로퍼티다.</p>
<p><strong><code>__proto__</code>접근자 프로퍼티의 이용</strong></p>
<p>Object.prototype의 접근자 프로퍼티인 <code>__proto__</code> getter / setter 함수라고 부르는 접근자 함수를 통해 [[Prototype]] 내부 슬롯의 값, 즉 프로토타입을 취득하거나 할당한다.</p>
<ul>
<li><code>__proto__</code>에 접근시<ul>
<li>getter 함수 [[Get]]이 호출</li>
</ul>
</li>
<li><code>__proto__</code>에 할당시<ul>
<li>setter 함수 [[Set]]이 호출</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; &#123;&#125;;</span><br><span class="line">const parentObj &#x3D; &#123;x: 1&#125;;</span><br><span class="line"></span><br><span class="line">console.log(obj.__proto__); &#x2F;&#x2F; object.prototype</span><br><span class="line">obj.__proto__ &#x3D; parentObj;</span><br><span class="line">console.log(obj.__proto__); &#x2F;&#x2F;&#123; x: 1 &#125;</span><br><span class="line"></span><br><span class="line">console.log(obj.x); &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>



<p>**<code>__proto__</code>접근자 프로퍼티는 상속을 통해 사용된다. **</p>
<p><code>__proto__</code>접근자 프로퍼티는 객체가 직접 소유하는 프로퍼티가 아니라 Object.prototype의 프로퍼티다. 모든 객체는 상속을 통해 Object.prototype.<code>__proto__</code>접근자 프로퍼티를 사용할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; &#123; name: &#39;Lee&#39;&#125;;</span><br><span class="line"></span><br><span class="line">console.log(person.hasOwnProperty(&#39;__proto__&#39;)); &#x2F;&#x2F;false</span><br><span class="line"></span><br><span class="line">console.log(Object.getOwnPropertyDescriptor(Object.prototype, &#39;__proto__&#39;));</span><br><span class="line">&#x2F;&#x2F;&#123;get: f, set: f, enumerable: false, configurable: false&#125;</span><br><span class="line"></span><br><span class="line">console.log(&#123;&#125;.__proto__ &#x3D;&#x3D;&#x3D; Object.prototype);</span><br><span class="line">&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<p><strong>Object.prototype</strong></p>
<p>모든 객체는 프로토타입의 계층 구조인 프로토타입 체인에 묶여 있다. 자바스크립트 엔진은 객체의 프로퍼티에 접근하려고 할때 해당 객체에 접근하려는 프로퍼티가 없다면 <code>__proto__</code> 접근자 프로퍼티가 가리키는 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다. 프로토타입 체인의 종점, 즉 프로토타입 체인의 최상위 객체는 Object.prototype이며, 이 객체의 프로퍼티와 메서드는 모든 객체에게 상속된다. </p>
<p><strong><code>__proto__</code>접근자 프로퍼티를 통해 프로토타입에 접근하는 이유</strong></p>
<p>[[Prototype]]  내부 슬롯의 값, 즉 프로토타입에 접근하기 위해 접근자 프로퍼티를 사용하는 이유는 상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지하기 위해서다. <code>__proto__</code> 접근자 프로퍼티는 상호 참조가 발생하면 에러를 발생시킨다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const parent &#x3D; &#123;&#125;;</span><br><span class="line">const child &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;상호 참조 시 에러</span><br><span class="line">child.__proto__ &#x3D; parent;</span><br><span class="line">parent,__proto__ &#x3D; child; &#x2F;&#x2F; TypeError: Cyclic __proto__ value</span><br></pre></td></tr></table></figure>

<p>만약 위 예제 코드가 에러없이 진행되어 각 객체가 서로의 프로토 타입이 된다면 객체 서로가 자신의 프로토타입이 되는 비정상적인 프로토타입 체인이 만들어 진다. <code>__proto__</code> 접근자 프로퍼티는 이 경우 에러를 발생시키도록 구현되어 있다.</p>
<p><strong>프로토타입 체인의 요구조건</strong></p>
<p>포로토타입 체인은 단방향 링크드 리스트로 구현되어야 한다. 즉, 프로퍼티 검색 방향이 하위에서 상위로, 한쪽 방향으로만 흘러가야한다. 종점에는 Object.prototype이 존재하는 구조로 이루어지게 되는데 서로가 자신의 프로토타입이 되는 순환 참조(circular reference) 구조가 만들어지게되면 종점이 존재하지 않게 된다. 종점이 존재하지 않는다면 존재하지 않는 프로퍼티를 검색할 때 무한 루프에 빠지게 된다. </p>
<p>이러한 상황이 발생하지 않도록 <code>__proto__</code> 접근자 프로퍼티가 구현되어 있다.</p>
<p><strong><code>__proto__</code>접근자 프로퍼티를 코드 내에서 직접 사용하는 것은 권장하지 않는다.</strong></p>
<ul>
<li>모든 객체가 <code>__proto__</code>접근자 프로퍼티를 상속받지는 않는다.</li>
</ul>
<p><code>__proto__</code> 접근자 프로퍼티는 ES5 까지 ECMAScript 사양에 포함되지 않은 비표준이었다. 하지만 일부 브라우저에서 <code>__proto__</code>를 지원하고 있었기 때문에 브라우저 호환성을 고려하여 ES6에서는 표준으로 채택되었다. 그래서 대부분 브라우저가 해당 접근자 프로퍼티를 지원한다.</p>
<p>하지만 모든 객체가 <code>__proto__</code> 접근자 프로퍼티를 사용할 수 있는 것이 아니다.</p>
<p>직접 상속을 통해 Object.prototype을 상속받지 않는 객체를 생성할 수도 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; Object.create(null);</span><br><span class="line"></span><br><span class="line">console.log(obj.__proto__); &#x2F;&#x2F;undefined</span><br><span class="line"></span><br><span class="line">console.log(Object.getPrototypeOf(obj)); &#x2F;&#x2F;null</span><br></pre></td></tr></table></figure>



<p><strong>getPrototypeOf / setPrototypeOf</strong></p>
<p><code>__proto__</code>접근자 프로퍼티 대신 프로토타입에 접근하고 싶은 경우 다음과 같은 방법을 사용한다.</p>
<ul>
<li>프로토타입의 참조를 취득<ul>
<li>Object.getPrototypeOf 메서드 사용</li>
</ul>
</li>
<li>프로토타입을 교체<ul>
<li>Object.setPrototypeOf 메서드 사용</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const child &#x3D; &#123;&#125;;</span><br><span class="line">const parent &#x3D; &#123; x: 1 &#125;;</span><br><span class="line"></span><br><span class="line">Object.getPrototypeOf(child); &#x2F;&#x2F; child.__proto__와 동일</span><br><span class="line"></span><br><span class="line">Object.setPrototypeOf(child, parent); &#x2F;&#x2F;child.__proto__ &#x3D; parent; 와 동일</span><br><span class="line"></span><br><span class="line">Object.setPrototypeOf(parent, child);</span><br><span class="line">&#x2F;&#x2F; 순환 참조 시 에러</span><br></pre></td></tr></table></figure>





<h3 id="3-2-함수-객체의-prototype-프로퍼티"><a href="#3-2-함수-객체의-prototype-프로퍼티" class="headerlink" title="3.2 함수 객체의 prototype 프로퍼티"></a>3.2 함수 객체의 prototype 프로퍼티</h3><p><strong>함수 객체만이 소유하는 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다.</strong></p>
<p>일반 객체의 경우 [[Prototype]] 내부슬롯은 존재하였지만 prototype 프로퍼티를 직접 소유하고 있지 않았다. 하지만 함수 객체는 prototype 프로퍼티를 소유한다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;&#125;).hasOwnProperty(&#39;prototype&#39;)&#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">(&#123;&#125;).hasOwnProperty(&#39;prototype&#39;) &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p>prototype 프로퍼티는 생성자 함수가 생성할 객체의 프로토타입을 가리킨다. 따라서 생성자 함수로서 호출할 수 없는 non-constructor인 함수는 prototype 프로퍼티를 소유하지 않고, 프로토타입도 생성하지 않는다. </p>
<p>단 [[Prototype]] 내부 슬롯은 모든 객체가 가지고 있으므로 내부 슬롯은 존재한다. </p>
<p>non-constructor</p>
<ul>
<li>화살표 함수</li>
<li>메서드 축약표현으로 정의된 메서드</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const Person &#x3D; name &#x3D;&gt; &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(Person.hasOwnProperty(&#39;prototype&#39;)); &#x2F;&#x2F;false</span><br><span class="line"></span><br><span class="line">console.log(Person.prototype)&#x2F;&#x2F; undefined</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;메서드 축약 표현</span><br><span class="line">const obj &#x3D; &#123;</span><br><span class="line">    foo() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(obj.foo.hasOwnProperty(&#39;prototype&#39;));&#x2F;&#x2F;false</span><br><span class="line"></span><br><span class="line">console.log((function()&#123;&#125;).prototype); &#x2F;&#x2F;&#123;&#125;</span><br><span class="line">console.log(obj.foo.prototype); &#x2F;&#x2F;undefined</span><br></pre></td></tr></table></figure>

<p>생성자 함수로 호출하기 위해 정의하지 않은 일반 함수(함수 선언문, 함수 표현식)도 prototype 프로퍼티를 소유하고 있다. 하지만 객체를 생성할 목적으로 만들어지지 않은 일반함수의 prototype 프로퍼티는 아무 의미가 없다.</p>
<p><strong><code>__proto__</code> 접근자 프로퍼티 vs 함수의 prototype 프로퍼티</strong></p>
<p>모든 객체가 가지고 있는 (Object.prototype으로부터 상속받은) <code>__proto__</code>접근자 프로퍼티와 함수 객체만이 가지고 있는 prototype 프로퍼티는 결국 동일한 프로토타입을 가리킨다.</p>
<p>하지만 사용 주체와 목적이 다르다.</p>
<table>
<thead>
<tr>
<th>구분</th>
<th>소유</th>
<th>값</th>
<th>사용 주체</th>
<th>사용 목적</th>
</tr>
</thead>
<tbody><tr>
<td><code>__proto__</code> 접근자 프로퍼티</td>
<td>모든 객체</td>
<td>프로토타입의 참조</td>
<td>모든 객체</td>
<td>객체가 자신의 프로토타입에 접근 또는 교체하기위해 사용</td>
</tr>
<tr>
<td>prototype 프로퍼티</td>
<td>constructor</td>
<td>프로토타입의 참조</td>
<td>생성자 함수</td>
<td>생성자 함수가 자신이 생성할 객체의 프로토타입을 할당하기 위해 사용</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const me &#x3D; new Person(&#39;Lee&#39;);</span><br><span class="line"></span><br><span class="line">console.log(Person.prototype &#x3D;&#x3D;&#x3D; me.__proto__) &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>



<h3 id="3-3-프로토타입의-constructor-프로퍼티와-생성자-함수"><a href="#3-3-프로토타입의-constructor-프로퍼티와-생성자-함수" class="headerlink" title="3.3 프로토타입의 constructor 프로퍼티와 생성자 함수"></a>3.3 프로토타입의 constructor 프로퍼티와 생성자 함수</h3><p><strong>모든 프로토타입은 constructor 프로퍼티를 갖는다</strong></p>
<p>constructor 프로퍼티는 prototype프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리킨다. 이 연결은 생성자 함수가 생성될때, 즉 함수 객체가 생성될 때 이루어진다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const you &#x3D; new Person(&#39;Kim&#39;);</span><br><span class="line"></span><br><span class="line">console.log(you.constructor &#x3D;&#x3D;&#x3D; Person); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<p>Person 생성자 함수는 you 객체를 생성하였다. 이때 you 객체는 프로토타입의 constructor 프로퍼티를 통해 생성자 함수와 연결된다. you객체에는 constructor 프로퍼티가 없지만 프로토타입으로부터 상속받아 you 객체도 constructor 프로퍼티를 사용할 수 있다.</p>
<h2 id="4-리터럴-표기법에-의해-생성된-객체의-생성자-함수와-프로토타입"><a href="#4-리터럴-표기법에-의해-생성된-객체의-생성자-함수와-프로토타입" class="headerlink" title="4, 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입"></a>4, 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입</h2><p><strong>생성자 함수로 생성한 객체</strong></p>
<p>생성자 함수에 의해 생성된 인스턴스는 프로토타입의 constructor 프로퍼티에 의해 생성자 함수와 연결된다.  constructor 프로퍼티가 가리키는 생성자 함수는 인스턴스를 생성한 생성자 함수이다. </p>
<p><strong>리터럴로 생성한 객체</strong></p>
<p>명시적으로 new 연산자와 함께 생성자 함수를 호출하여 인스턴스를 생성하지 않고, 리터럴 표기법에 의한 객체 생성방식과 같은 객체 생성방식도 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">const foo &#x3D; function()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">const arr &#x3D; [1, 2, 3];</span><br><span class="line"></span><br><span class="line">const regexp &#x3D; &#x2F;is&#x2F;ig;</span><br></pre></td></tr></table></figure>



<p><strong>리터럴로 생성한 객체의 생성자 함수</strong></p>
<p>모든 객체는 프로토타입 내부슬롯이 있으므로 리터럴 표기법에 의해 생성된 객체도 프로토타입이 존재한다. 하지만 리터럴 표기법에 의해 생성된 객체의 경우 프로토타입의 constructor 프로퍼티가 가리키는 생성자 함수가 반드시 객체를 생성한 생성자 함수라고 단정할 수 없다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">constole.log(obj.constructor &#x3D;&#x3D;&#x3D; Object); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<p>위 예제의 obj 객체는 Object 생성자 함수로 생성한 객체가 아니라 객체 리터럴에 의해 생성된 객체다. 하지만 obj 객체는 Object 생성자 함수와 constructor 프로퍼티로 연결되어 있다. 그렇다면 객체 리터럴에 의해 생성된 객체는 사실 Object 생성자 함수로 생성되는 것은 아닐지 하는 의문이 들 수 있다. </p>
<p><strong>Object 생성자 함수의 ECMAScript 사양</strong></p>
<p>Object 생성자 함수는 다음과 같이 구현되도록 정의되어 있다. </p>
<ol>
<li>new.target 이 undefined나 Object가 아닌 경우 인스턴스 -&gt; 인스턴스 생성자함수의 프로토타입 - &gt; Object.prototype 순으로 프로토타입 체인이 생성된다. </li>
<li>Object. 생성자 함수에 인수를 전달하지 않거나 undefined 또는 null을 인수로 전달하면서 new 연산자와 함께 호출하면 내부적으로는 추상연산 OrdinaryObjectCreate를 호출하여 Object.prototype을 프로토타입으로 갖는 빈 객체를 생성한다. </li>
</ol>
<p><strong>추상 연산(abstract operation)</strong></p>
<p>추상 연산은 ECMAScript 사양에서 내부 동작의 구현 알고리즘을 표현한 것이다. ECMAScript 사양에서 설명을 위해 사용되는 함수와 유사한 의사코드이다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;2. Object 생성자 함수에 의한 객체 생성</span><br><span class="line">&#x2F;&#x2F; Object 생성자 함수는 new 연산자와 함께 호출하지 않아도 new 연산자와 함께 호출한 것과 동일하게 동작한다. </span><br><span class="line">&#x2F;&#x2F;인수가 전달되지 않았을 때 추상연산 OrdinaryObjectCreate를 호출하여 빈 객체를 생성한다.</span><br><span class="line"></span><br><span class="line">let obj &#x3D; new Object();</span><br><span class="line">console.log(obj); &#x2F;&#x2F;&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;1. new.target이 undefined 나 Object 가 아닌 경우</span><br><span class="line">&#x2F;&#x2F;인스턴스 -&gt; Foo.prototype&amp;nbsp; -&gt; Object.prototype 순으로 프로토타입 체인이 생성된다. </span><br><span class="line">class Foo extends Object &#123;&#125;</span><br><span class="line">new Foo(); &#x2F;&#x2F; Foo&amp;nbsp;&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3. 인수가 전달된 경우에는 인수를 객체로 변환한다.</span><br><span class="line">&#x2F;&#x2F;Number 객체 생성</span><br><span class="line">obj &#x3D; new Object(123);</span><br><span class="line">console.log(obj); &#x2F;&#x2F;Number &#123;123&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;String 객체 생성</span><br><span class="line">obj &#x3D; new Object(&#39;123&#39;);</span><br><span class="line">console.log(obj);&#x2F;&#x2F; String&#123;&#39;123&#39;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>객체 리터럴이 평가될때의 추상연산</strong></p>
<p>객체 리터럴이 평가될 때는  추상연산 OrdinaryObjectCreate를 호출하여 빈 객체를 생성하고 프로퍼티를 추가하도록 정의되어 있다. </p>
<p>Object 생성자 함수 호출과 객체 리터럴의 평가는 추상 연산 OrdinaryObjectCreate를 호출하여 빈 객체를 생성하는 점에서 동일하다.하지만 new.target의 확인이나 프로퍼티를 추가하는 처리 등 세부 내용이 다르다. </p>
<p>따라서 객체 리터럴에 의해 생성된 객체는 Object 생성자 함수가 생성한 함수가 아니다. </p>
<p><strong>함수 리터럴과 함수 생성자함수</strong></p>
<p>함수 객체의 경우 차이가 더 명확하다. Function 생성자 함수를 호출하여 생성한 함수는 렉시컬 스코프를 만들지 않고 전역 함수인 것처럼 스코프를 생성하며  클로저도 만들지 않는다. 따라서 함수 선언문과 함수 표현식을 평가하여 함수 객체를 생성한 것은 Function 생성자 함수가 아니다. 하지만 constructor 프로퍼티를 통해 확인해보면 foo 함수의 생성자 함수는 Function 생성자 함수다</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function foo()&#123;&#125;</span><br><span class="line">console.log(foo.constructor &#x3D;&#x3D;&#x3D; Function); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<p><strong>리터럴로 생성된 객체의 생성자 함수</strong></p>
<p>리터럴 표기법에 의해 생성된 객체도 상속을 위해 프로토타입이 필요하다. 따라서 리터럴 표기법에 의해 생성된 객체도 가상적인 생성자 함수를 갖는다. 프로토타입은 생성자 함수와 더불어 생성되며 prototype, constructor 프로퍼티에 의해 연결되어 있기 때문이다. 다시 말해, 프로토타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍(pair)으로 존재한다.</p>
<p>리터럴 표기법(객체 리터럴, 함수 리터럴, 배열 리터럴, 정규 표현식 리터럴 등) 에 의해 생성된 객체는 생성자 함수에 의해 생성된 객체는 아니다. 하지만 큰 틀에서 생각해보면 리터럴 표기법으로 생성한 객체도 생성자 함수로 생성한 객체와 본질적인 면에서 큰 차이는 없다.</p>
<p>예를 들어, 객체 리터럴에 의해 생성한 객체와 Object 생성자 함수에 의해 생성한 객체는 생성과정에서 미묘한 차이는 있지만 결국 객체로서 동일한 특성을 갖는다. 함수 리터럴에 의해 생성한 함수와 Function 생성자 함수에 의해 생성한 함수는 생성 과정과 스코프, 클로저 등의 차이가 있지만 결국 함수로서 동일한 특성을 갖는다. </p>
<p><strong>리터럴로 생성한 객체의 생성자함수 취급</strong></p>
<p>프로토타입의 constructor 프로퍼티를 통해 연결되어 있는 생성자 함수를 리터럴 표기법으로 생성한 객체를 생성한 생성자 함수로 생각해도 크게 무리는 없다. 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입은 다음과 같다. </p>
<table>
<thead>
<tr>
<th>리터럴 표기법</th>
<th>생성자 함수</th>
<th>프로토타입</th>
</tr>
</thead>
<tbody><tr>
<td>객체 리터럴</td>
<td>Object</td>
<td>Object.prototype</td>
</tr>
<tr>
<td>함수 리터럴</td>
<td>Function</td>
<td>Function.prototype</td>
</tr>
<tr>
<td>배열 리터럴</td>
<td>Array</td>
<td>Array.prototype</td>
</tr>
<tr>
<td>정규 표현식 리터럴</td>
<td>RegExp</td>
<td>RegExp.prototype</td>
</tr>
</tbody></table>
<h2 id="5-프로토타입의-생성-시점"><a href="#5-프로토타입의-생성-시점" class="headerlink" title="5. 프로토타입의 생성 시점"></a>5. 프로토타입의 생성 시점</h2><p><strong>프로토타입은 생성자 함수가 생성되는 시점에 생성된다</strong></p>
<p>리터럴 표기법에 의해 생성된 객체도 생성자 함수와 연결되는 것을 보았다. 객체는 리터럴 표기법 또는 생성자 함수에 의해 생성되므로 결국 모든 객체는 생성자 함수와 연결되어 있다. </p>
<p>(Object.create 메서드와 클래스로 객체를 생성하는 방법도 있다.)</p>
<p>프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다. 프로토타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍으로 존재하기 때문이다.</p>
<p><strong>셍상지 힘수의 구분</strong></p>
<p>생성자 함수는 정의 주체에 따라 두가지로 구분할 수 있다.</p>
<ul>
<li>사용자 정의 생성자 함수<ul>
<li>사용자가 직접 정의한 생성자 함수</li>
</ul>
</li>
<li>빌트인 생성자 함수<ul>
<li>자바스크립트가 기본 제공하는 생성자 함수</li>
</ul>
</li>
</ul>
<p>두 생성자 함수의 프로토타입 생성시점에 대해 알아본다.</p>
<h3 id="5-1-사용자-정의-생성자-함수와-프로토타입-생성시점"><a href="#5-1-사용자-정의-생성자-함수와-프로토타입-생성시점" class="headerlink" title="5.1 사용자 정의 생성자 함수와 프로토타입 생성시점"></a>5.1 사용자 정의 생성자 함수와 프로토타입 생성시점</h3><p><strong>함수 정의가 평가되는 시점에 생성된다.</strong></p>
<p>내부 메서드 [[Construct]]를 갖는 함수 객체, 즉 화살표 함수나 ES6의 메서드 축약 표현으로 정의하지 않고 일반함수로 정의한 함수 객체는 new 연산자와 함께 생성자 함수로 호출할 수 있다.</p>
<p>생성자 함수로서 호출할 수 있는 함수, 즉 constructor는 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(Person.prototype); &#x2F;&#x2F; &#123;&#125;</span><br><span class="line"></span><br><span class="line">function Person()&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>non - constructor 는 프로토타입이 생성되지 않는다</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const Person &#x3D; name &#x3D;&gt; &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(Person.prototype); &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure>

<p><strong>함수 선언문이 평가되는 시점</strong></p>
<p>함수 선언문은 다른 코드가 실행되기 이전에 자바스크립트 엔진에 의해 먼저 실행된다. 따라서 함수 선언문으로 정의된 Person 생성자 함수는 어떤 코드보다 먼저 평가되어 함수 객체가 된다. </p>
<p>이때 프로토타입도 더불어 생성된다. 생성된 프로토타입은 Person 생성자 함수의 prototype 프로퍼티에 바인딩된다. </p>
<p>함수선언문에 의한 생성자 함수에 연결된 프로토타입 객체의 프로퍼티</p>
<ul>
<li>constructor: 생성자 함수의 참조</li>
<li><code>__proto__</code> : Object (상속받은 프로퍼티)</li>
</ul>
<p><strong>생성된 프로토타입의 프로퍼티</strong></p>
<p>생성된 프로토타입은 오직 constructor 프로퍼티만을 갖는 객체다. 프로토타입도 객체이고 모든 객체는 프로토타입을 가지므로 프로토타입도 자신의 프로토타입을 갖는다. 생성된 프로토타입의 프로토타입은 Object.prototype이다.</p>
<h3 id="5-2-빌트인-생성자-함수와-프로토타입-생성-시점"><a href="#5-2-빌트인-생성자-함수와-프로토타입-생성-시점" class="headerlink" title="5.2 빌트인 생성자 함수와 프로토타입 생성 시점"></a>5.2 빌트인 생성자 함수와 프로토타입 생성 시점</h3><p><strong>빌트인 생성자 함수가 생성되는 시점</strong></p>
<p>Object, String, Number, Function, Array, RegExp, Date, Promis 등과 같은 빌트인 생성자 함수도 일반 함수와 마찬가지로 빌트인 생성자 함수가 생성되는 시점에 프로토타입이 생성된다. 모든 빌트인 생성자 함수는 전역 객체가 생성되는 시점에 생성된다. 생성된 프로토타입은 빌트인 생성자 함수의 prototype 프로퍼티에 바인딩된다. </p>
<p><strong>전역 객체(global object)란</strong></p>
<p>전역 객체는코드가 실행되기이전 단계에 자바스크립트 엔진에의해 생성되는 특수한 객체이다. 전역 객체는 클라이언트 사이드 환경(브라우저)에서는window, 서버 사이드 환경(Node.js)에서는 global 객체를 의미한다.</p>
<p>전역 객체는표준 빌트인 객체(Object, String, Number, Function, Array 등) 들과 환경에 따른 호스트 객체(클라이언트 web API 또는Node.js의 호스트 API), 그리고 var 키워드로 선언한 전역 변수와 전역 함수를 프로퍼티로 갖는다. Math, Reflect, JSON을 제외한 표준 빌트인 객체는 모두 생성자 함수이다.</p>
<p><strong>객체가 생성되기 이전에 생성자 함수와 프로토타입은 이미 존재한다.</strong></p>
<p>표준 빌트인 객체인 Object도 전역객체의 프로퍼티이며, 전역 객체가 생성되는 시점에 생성된다. </p>
<p>이처럼 객체가 생성되기 이전에 생성자 함수와 프로토타입은 이미 객체화되어 존재한다. 이후 생성자 함수 또는 리터럴 표기법으로 객체를 생성하면 프로토타입은 생성된 객체의 [[Prototype]] 내부 슬롯에 할당된다. 생성된 객체는 프로토타입을 상속받는다.</p>
<h2 id="6-객체-생성-방식과-프로토타입의-결정"><a href="#6-객체-생성-방식과-프로토타입의-결정" class="headerlink" title="6. 객체 생성 방식과 프로토타입의 결정"></a>6. 객체 생성 방식과 프로토타입의 결정</h2><p><strong>객체의 생성방법</strong></p>
<ul>
<li>객체 리터럴</li>
<li>Object 생성자 함수</li>
<li>생성자 함수</li>
<li>Object.create 메서드</li>
<li>클래스</li>
</ul>
<p><strong>공통점</strong></p>
<p>이처럼 다양한 방식으로 생성된 모든 객체는 각 방식마다 세부적인 객체 생성방식의 차이는 있으나 추상 연산 OrdinaryObjectCreate에 의해 생성된다는 공통점이 있다. </p>
<p>**추상 연산 OrdinaryObjectCreate **</p>
<p>추상 연산 OrdinaryObjectCreate는 필수적으로 자신이 생성할 객체의 프로토타입을 인수로 전달받는다.</p>
<p>그리고 자신이 생성할 객체에 추가할 프로퍼티 목록을 옵션으로 전달할 수 있다. 추상 연산 OrdinaryObjectCreate는 빈 객체를 생성한 후, 객체에 추가할 프로퍼티 목록이 인수로 전달된 경우 프로퍼티를 객체에 추가한다. </p>
<p>그리고 인수로 전달받은 프로토타입을 자신이 생성한 객체의 [[Prototype]] 내부슬롯에 할당하고, 생성한 객체를 반환한다.</p>
<p>즉, 프로토타입은 추상 연산 OrdinaryObjectCreate에 전달되는 인수에 의해 결정된다. 이 인수는 객체가 생성되는 시점에 객체 생성방식에 의해 결정된다. </p>
<h3 id="6-1-객체-리터럴에-의해-생성된-객체의-프로토타입"><a href="#6-1-객체-리터럴에-의해-생성된-객체의-프로토타입" class="headerlink" title="6.1 객체 리터럴에 의해 생성된 객체의 프로토타입"></a>6.1 객체 리터럴에 의해 생성된 객체의 프로토타입</h3><p><strong>객체리터럴에 의한 프로토타입 연결</strong></p>
<p>자바스크립트 엔진은 객체 리터럴을 평가하여 객체를 생성할 때, 추상 연산 OrdinaryObjectCreate를 호출한다. 이때 추상 연산 OrdinaryObjectCreate에 전달되는 프로토타입은 Object.prototype이다. 즉, 객체리터럴에 의해 생성되는 객체의 프로토타입은 Object.prototype 이다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; &#123;x: 1&#125;;</span><br></pre></td></tr></table></figure>

<p>위 객체 리터럴이 평가되면 추상연산 OrdinaryObjectCreate에 의해 Object 생성자 함수와 Object.prototype과 생성된 객체 사이에 연결이 만들어 진다. </p>
<p><strong>Object.prototype을 상속받는다</strong></p>
<p>객체리터럴에 의해 생성된 obj 객체는 Object.prototype을 프로토타입으로 갖게 되며, 이로써 Object.prototype을 상속받는다. obj 객체는 constructor 프로퍼티와 hasOwnProperty 메서드 등을 소유하지 않지만 자신의 프로토타입인 Object.prototype의 constructor 프로퍼티와 hasOwnProperty 메서드를 자신의 자산인 것처럼 자유롭게 사용할 수 있다. 이는 obj 객체가 자신의 프로토타입인 Object.prototype 객체를 상속받았기 때문이다. </p>
<h3 id="6-2-Object-생성자-함수에-의해-생성된-객체의-프로토타입"><a href="#6-2-Object-생성자-함수에-의해-생성된-객체의-프로토타입" class="headerlink" title="6.2 Object 생성자 함수에 의해 생성된 객체의 프로토타입"></a>6.2 Object 생성자 함수에 의해 생성된 객체의 프로토타입</h3><p><strong>Object생성자 함수로 생성한 객체의 프로토타입 연결</strong></p>
<p>Object 생성자 함수를 인수 없이 호출하면 빈 객체가 생성된다. Object 생성자 함수를 호출하면 객체 리터럴과 마찬가지로 추상연산 OrdinaryObjectCreate가 호출된다. 인수로 전달되는 프로토타입은 Object.prototype이다. 객체리터럴과 마찬가지로, Object 생성자 함수에 의해 생성되는 객체의 프로토타입은 Object.prototype 이다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; new Object();</span><br><span class="line">obj.x &#x3D; 1;</span><br></pre></td></tr></table></figure>

<p> <strong>생성된 객체는 객체리터럴에 의해 생성된 객체와 동일한 구조를 갖는다.</strong></p>
<p>Object 생성자 함수로 생성된 객체 역시 추상 연산 OrdinaryObjectCreate 에 의해 인스턴스와 Object.prototype 간에 상속관계가 만들어진다. </p>
<p>Object.prototype을 프로토타입으로 가진 인스턴스는 프로토타입의 프로퍼티를 상속받아 사용할 수 있다.</p>
<p><strong>리터럴과 생성자 함수의 생성방식의 차이</strong></p>
<p>객체 리터럴과 Object 생성자 함수에 의한 객체 생성방식의 차이는 프로퍼티를 추가하는 방식에 있다. 객체 리터럴 방식은 객체 리터럴 내부에 프로퍼티를 추가하지만 Object 생성자 함수 방식은 일단 빈 객체를 생성한 이후 프로퍼티를 추가해야한다.</p>
<h3 id="6-3-생성자-함수에-의해-생성된-객체의-프로토타입"><a href="#6-3-생성자-함수에-의해-생성된-객체의-프로토타입" class="headerlink" title="6.3 생성자 함수에 의해 생성된 객체의 프로토타입"></a>6.3 생성자 함수에 의해 생성된 객체의 프로토타입</h3><p><strong>생성자 함수로 생성한 객체의 프로토타입 연결</strong></p>
<p>new 연산자와 함께 생성자 함수를 호출하여 인스턴스를 생성하면 다른 객체 생성 방식과 마찬가지로 추상 연산 OrdinaryObjectCreate가 호출된다. 이때 추상 연산 OrdinaryObjectCreate에 전달되는 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체다. 즉, 생성자 함수에 의해 생성되는 객체의 프로토타입은 생성자 함수의 prototype프로퍼티에 바인딩되어 있는 객체이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Student(age) &#123;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line">const me &#x3D; new Student(23);</span><br></pre></td></tr></table></figure>

<p>위 코드가 실행되면</p>
<ul>
<li>추상연산 OrdinaryObjectCreate 호출</li>
<li>인스턴스 다음 객체를 프로토타입으로 연결함<ul>
<li>생성자 함수의 prototype 프로퍼티에 바인딩 된 객체</li>
</ul>
</li>
</ul>
<p><strong>Object 생성자 함수와 사용자 정의 생성자 함수의 차이</strong></p>
<p>표준 빌트인 객체인 Object 생성자 함수와 더불어 생성된 프로토타입 Object.prototype 은 다양한 빌트인 메서드를 갖고 있다. 하지만 사용자 정의 생성자 함수 Student와 더불어 생성된 프로토타입 Student.prototype의 프로퍼티는 constructor 뿐이다.</p>
<p><strong>프로토타입 객체에 프로퍼티 추가</strong></p>
<p>프로토타입 Student.prototype에 프로퍼티를 추가하여 하위 객체가 상속받을 수 있도록 구현해본다. 프로토타입은 객체이므로 프로퍼티를 추가 삭제하여 프로토타입 체인에 반영시킬 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Student(age)&#123;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype.showInfo &#x3D; function()&#123;</span><br><span class="line">    console.log(this.age + &#39;세 입니다&#39;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const me &#x3D; new Student(23);</span><br><span class="line"></span><br><span class="line">me.showInfo();&#x2F;&#x2F;23세 입니다</span><br></pre></td></tr></table></figure>

<p>Student 생성자 함수를 통해 생성된 모든 객체는 Student.prototype에 추가된 프로퍼티를 상속받아 사용할 수 있다.</p>
<h2 id="7-프로토타입-체인"><a href="#7-프로토타입-체인" class="headerlink" title="7.프로토타입 체인"></a>7.프로토타입 체인</h2><p><strong>사용자 정의 생성자 함수에 의해 생성된 객체의 상속 관계</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Student(age)&#123;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype.showInfo &#x3D; function()&#123;</span><br><span class="line">    console.log(this.age + &#39;세 입니다&#39;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const me &#x3D; new Student(23);</span><br><span class="line">console.log(me.hasOwnProperty(&#39;age&#39;));&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<p>Student 생성자 함수에 의해 생성된 me 객체는 Object.prototype 메서드인 hasOwnProperty를 호출할 수 있따. 이것은 me 객체가 Person.prototype 뿐만 아니라 Object.prototype 도 상속받았다는 것을 의미한다. </p>
<p><strong>프로토타입의 프로토타입은 항상 Object.prototype 이다.</strong></p>
<p>me 객체의 프로토타입은 Student.prototype 이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.getPrototypeOf(me) &#x3D;&#x3D;&#x3D; Student.prototype ; &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>Student.prototype의 프로토타입은 Object.prototype이다. 프로토타입의 프로토타입은 항상 Object.prototype이다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.getPrototypeOf(Studnet.prototype) &#x3D;&#x3D;&#x3D; Object.prototype; &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>Student 생성자 함수로 생성한 객체의 프로토타입 체인 구조는 다음과 같다.</p>
<ul>
<li>Student 생성자 함수<ul>
<li>Function.prototype<ul>
<li>Object.prototype</li>
</ul>
</li>
</ul>
</li>
<li>me 인스턴스<ul>
<li>Student.prototype<ul>
<li>Object.prototype</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>프로토타입의 이용</strong></p>
<p>자바스크립트는 객체의 프로퍼티에 접근하려고 할 때 해당 객체에 프로퍼티가 없다면 [[Prototype]] 내부 슬롯의 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다. 이를 프로토타입 체인이라고 한다. 프로토타입 체인은 자바스크립트가 객체지향 프로그래밍의 상속을 구현하는 메커니즘이다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">me.hasOwnProperty(&#39;age&#39;); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<p>hasOwnProperty는 Object.prototype의 메서드이다. me 객체부터 Student.prototype , Object.prototype 순으로 프로토타입 체인을 거슬러 올라가며 프로퍼티를 검색한다. </p>
<p><strong>프로토타입 체인의 검색 과정</strong></p>
<p>me.hasOwnProperty(‘age’) 메서드를 호출하는 과정</p>
<ol>
<li>hasOwnProperty 메서드를 호출한 me 객체에서 해당 메서드를 검색한다. me 객체에는 hasOwnProperty 메서드가 없다. 프로토타입 체인을 따라, [[Prototype]]내부슬롯 에 바인딩된 프로토타입으로 이동한다. Student.prototype에서 해당 메서드를 검색한다.</li>
<li>Student.prototype에도 hasOwnProperty 메서드가 없으므로 프로토타입 체인을 따라 [[Prototype]]내부슬롯에 바인딩된 Object.prototype으로 이동하여 해당 메서드를 검색한다.</li>
<li>Object.prototype에는 hasOwnProperty 메서드가 존재한다. 자바스크립트 엔진은 Object.prototype.hasOwnProperty 메서드를 호출한다.  이때 해당 메서드의 this 에는 me 객체가 바인딩된다.</li>
</ol>
<p><strong>call 메서드에 의한 간접 호출</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.hasOwnProperty.call(me, &#39;age&#39;);</span><br></pre></td></tr></table></figure>

<p><strong>call 메서드</strong></p>
<p>call 메서드는 this로 사용할 객체를 전달하면서 함수를 호출한다. 위 코드에서는 this로 사용할 me 객체를 전달하면서 Object.prototype.hasOwnProperty 메서드를 호출하였다.</p>
<p><strong>프로토타입의 종점</strong></p>
<p>프로토타입 체인의 최상위에 위치하는 객체는 언제나 Object.prototype이다. 따라서 모든 객체는 Object.prototype을 상속받는다. Object.prototype을 프로토타입 체인의 종점 (end of prototype chain)이라 한다. Object.prototype 의 프로토타입 즉 [[Prototype]] 내부 슬롯의 값은 null 이다.</p>
<ul>
<li>프로토타입 체인의 종점인 Object.prototype 에서도 프로퍼티를 검색할 수 없는 경우, undefined 를 반환한다. 이때 에러가 발생하지 않는다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(me.hello); &#x2F;&#x2F;undefined</span><br></pre></td></tr></table></figure>

<p><strong>프로토타입 체인의 의의</strong></p>
<p>자바스크립트 엔진은 프로토타입 체인을 따라 프로퍼티 / 메서드를 검색한다. 즉, 자바스크립트 엔진은 객체 간의 상속 관계로 이루어진 프로토타입의 계층적인 구조에서 객체의 프로퍼티를 검색한다. 따라서 프로토타입 체인은 상속과 프로퍼티 검색을 위한 메커니즘이라고 할 수 있다. </p>
<p><strong>스코프 체인과의 차이</strong></p>
<p>프로토타입 체인이 프로퍼티 검색을 위한 메커니즘이라면, 프로퍼티가 아닌 식별자는 스코프 체인에서 검색한다. 즉, 자바스크립트 엔진은 함수의 중첩관계로 이루어진 스코프의 계층적 구조에서 식별자를 검색한다. 스코프 체인은 식별자 검색을 위한 메커니즘이라고 할 수 있다.</p>
<p><strong>메서드 호출시 동작 과정</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">me.hasOwnProperty(&#39;age&#39;);</span><br></pre></td></tr></table></figure>

<p>위 코드를 실행하게 되면 다음과 같은 순서로 동작한다.</p>
<ol>
<li>스코프 체인에서 me 식별자를 검색한다. me 스코프는 전역에서 선언되었으므로 전역 스코프에서 검색된다. </li>
<li>me 객체의 프로토타입 체인에서 hasOwnProperty 메서드를 검색한다. </li>
</ol>
<p>스코프 체인과 프로토타입 체인은 서로 연관없이 별도로 동작하는 것이 아니라 서로 협력하여 식별자와 프로퍼티를 검색하는 데 사용된다. </p>
<h2 id="8-오버라이딩과-프로퍼티-섀도잉"><a href="#8-오버라이딩과-프로퍼티-섀도잉" class="headerlink" title="8. 오버라이딩과 프로퍼티 섀도잉"></a>8. 오버라이딩과 프로퍼티 섀도잉</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const Student &#x3D; (function () &#123;</span><br><span class="line">    function Student(age) &#123;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Student.prototype.showInfo &#x3D; function()&#123;</span><br><span class="line">        console.log(this.age + &#39;세 입니다&#39;);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    return Student;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">const me &#x3D; new Student(23);</span><br><span class="line"></span><br><span class="line">me.showInfo &#x3D; function() &#123;</span><br><span class="line">    console.log(&#39;안녕하세요 &#39; + this.age + &#39;세 입니다&#39; );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">me.showInfo(); &#x2F;&#x2F; 안녕하세요 23세 입니다</span><br></pre></td></tr></table></figure>

<p><strong>상속 관계에 따른 프로퍼티 숨김</strong></p>
<p>프로토타입이 소유한 프로퍼티를 프로토타입 프로퍼티, 인스턴스가 소유한 프로퍼티를 인스턴스 프로퍼티라고 부른다. </p>
<p>프로토타입 프로퍼티와 같은 이름의 프로퍼티를 인스턴스에 추가하면 프로토타입 체인을 따라 프로토타입 프로퍼티를 검색하여 프로토타입 프로퍼티를 덮어쓰는 것이 아니라 인스턴스 프로퍼티로 추가한다. 이때 인스턴스 메서드 showInfo는 프로토타입 메서드 showInfo를 오버라이딩했다. 그리고 프로토타입 메서드 showInfo는 가려진다. 이처럼 상속 관계에 의해 프로퍼티가 가려지는 현상을 프로퍼티 섀도잉(property shadowing)이라 한다.</p>
<p><strong>오버라이딩(overrding)</strong></p>
<p>상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의하여 사용하는 방식이다.</p>
<p><strong>오버로딩(overloading)</strong></p>
<p>함수의 이름은 동일하지만 매개변수의 타입 또는 개수가 다른 메서드를 구현하고 매개변수에 의해 메서드를 구별하여 호출하는 방식이다. 자바스크립트는 오버로딩을 지원하지 않지만 arguments 객체를 사용하여 구현할 수는 있다. </p>
<p><strong>프로퍼티를 삭제하는 경우</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">delete me.showInfo;</span><br><span class="line"></span><br><span class="line">me.showInfo(); &#x2F;&#x2F;23세 입니다</span><br></pre></td></tr></table></figure>

<p>하위 객체를 통해 메서드를 삭제하면 인스턴스 메서드 showInfo가 삭제된다.  인스턴스 메서드를 삭제한 상태에서 메서드를 다시 삭제해본다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">delete me.showInfo;</span><br><span class="line"></span><br><span class="line">me.showInfo();&#x2F;&#x2F; 23세 입니다</span><br></pre></td></tr></table></figure>

<p><strong>하위 객체에서 프로토타입의 프로퍼티를 변경할 수 없다</strong></p>
<p>위 코드에서 알 수 있듯이 하위 객체를 통해 프로토타입의 프로퍼티를 변경 또는 삭제하는 것은 불가능하다. 다시 말해 하위 객체를 통해 프로토타입에 get 액세스는 허용되나 set액세스는 허용되지않는다. </p>
<p><strong>프로토타입 프로퍼티를 변경 / 삭제하는 방법</strong></p>
<p>프로토타입 프로퍼티를 변경 또는 삭제하려면 하위 객체를 통해 프로토타입 체인으로 접근하는 것이 아니라 프로토타입에 직접 접근해야 한다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Student.prototype.showInfo &#x3D; functioin() &#123;</span><br><span class="line">    console.log(&#39;안녕하세요 &#39; + this.age + &#39;입니다&#39;);</span><br><span class="line">&#125;;</span><br><span class="line">me.showInfo(); &#x2F;&#x2F; 안녕하세요 23세 입니다</span><br><span class="line"></span><br><span class="line">delete Student.prototype.showInfo; </span><br><span class="line">me.showInfo(); &#x2F;&#x2F; TypeError: me.showInfo is not a function </span><br></pre></td></tr></table></figure>



<h2 id="9-프로토타입의-교체"><a href="#9-프로토타입의-교체" class="headerlink" title="9. 프로토타입의 교체"></a>9. 프로토타입의 교체</h2><p><strong>프로토타입은 교체가능하다</strong></p>
<p>프로토타입은 임의의 다른 객체로 변경할 수 있다. 이것은 부모 객체인 프로토타입을 동적으로 변경할 수 있다는 것을 의미한다. 이러한 특징을 활용하여 객체 간의 상속 관계를 동적으로 변경할 수 있따. 프로토타입은 생성자 함수 또는 인스턴스에 의해 교체할 수 있다.</p>
<h3 id="9-1-생성자-함수에-의한-프로토타입의-교체"><a href="#9-1-생성자-함수에-의한-프로토타입의-교체" class="headerlink" title="9.1 생성자 함수에 의한 프로토타입의 교체"></a>9.1 생성자 함수에 의한 프로토타입의 교체</h3><p><strong>프로토타입을 직접 할당</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const Student &#x3D; (function() &#123;</span><br><span class="line">    function Student(age) &#123;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Student.prototype &#x3D; &#123;</span><br><span class="line">        showInfo() &#123;</span><br><span class="line">            console.log(this.age + &#39;세 입니다&#39;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    return Student;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">const me &#x3D; new Student(23);</span><br></pre></td></tr></table></figure>

<p>Student.prototype에 객체리터럴을 할당했다. 이는 Student 생성자 함수가 생성할 객체의 프로톹아ㅣㅂ을 객체 리터럴로 교체한 것이다.</p>
<p><strong>프로토타입 교체 시 유의점</strong></p>
<p>프로토타입으로 교체한 객체 리터럴에는 constructor 프로퍼티가 없다. constructor 프로퍼티는 자바스크립트 엔진이 프로토타입을 생성할 때 암묵적으로 추가한 프로퍼티다. 따라서 me 객체의 생성자 함수를 검색하면 프로토타입 체인을 거슬러 올라가 Object.prototype의 constructor 프로퍼티를 검색하게 되어 Student가아닌 Object가 나온다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(me.constructor &#x3D;&#x3D;&#x3D; Student); &#x2F;&#x2F;false</span><br><span class="line"></span><br><span class="line">console.log(me.constructor &#x3D;&#x3D;&#x3D; Object); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<ul>
<li>프로토타입을 교체하면 constructor 프로퍼티와 생성자 함수 간의 연결이 파괴된다.</li>
</ul>
<p>  <strong>constructor 프로퍼티와 생성자 함수간의 연결을 복구하는 법</strong></p>
<p>파괴된 constructor 프로퍼티와 생성자 함수 간의 연결을 되살리기 위해서는 다음 방법을 따른다.</p>
<ul>
<li>프로토타입으로 교체한 객체 리터럴에 constructor 프로퍼티를 추가하여 프로토타입의 constructor 프로퍼티를 되살린다. </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const Student &#x3D; (function() &#123;</span><br><span class="line">    function Student(age) &#123;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Student.prototype &#x3D; &#123;</span><br><span class="line">        constructor: Student,</span><br><span class="line">        showInfo() &#123;</span><br><span class="line">            console.log(this.age + &#39;세 입니다&#39;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    return Student;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">const me &#x3D; new Student(23);</span><br></pre></td></tr></table></figure>

<p><strong>결과</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(me.prototype &#x3D;&#x3D;&#x3D; Student); &#x2F;&#x2F;true</span><br><span class="line">console.log(me.prototype &#x3D;&#x3D;&#x3D; Object); &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>



<h3 id="9-2-인스턴스에-의한-프로토타입의-교체"><a href="#9-2-인스턴스에-의한-프로토타입의-교체" class="headerlink" title="9.2 인스턴스에 의한 프로토타입의 교체"></a>9.2 인스턴스에 의한 프로토타입의 교체</h3><p><strong>접근자 프로퍼티를 통한 프로토타입 교체</strong></p>
<p>프로토타입은 생성자 함수의 prototype 프로퍼티뿐만 아니라 인스턴스의 <code>__proto__</code> 접근자 프로퍼티나 빌트인 객체의 메서드를 통해 접근할 수 있다. </p>
<p><strong>프로퍼티에 직접 바인딩하는것과의 차이점</strong></p>
<p>생성자 함수의 prototype 프로퍼티에 다른 임의의 객체를 바인딩하는 것은 미래에 생성할 인스턴스의 프로토타입을 교체하는 것이다. <code>__proto__</code> 접근자 프로퍼티를 통해 프로토타입을 교체하는 것은 이미 생성된 객체의 프로토타입을 교체하는 것이다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Student(age) &#123;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const me &#x3D; new Student(23);</span><br><span class="line"></span><br><span class="line">const parent &#x3D; &#123;</span><br><span class="line">    showInfo() &#123;</span><br><span class="line">        console.log(&#96;$&#123;this.age&#125;세 입니다&#96;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.setPrototypeOf(me, parent);</span><br><span class="line"></span><br><span class="line">me.showInfo(); &#x2F;&#x2F; 23세 입니다</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 프로토타입으로 교체한 객체에는 constructro 프로퍼티가 없다.</span><br><span class="line">&#x2F;&#x2F; constructor 프로퍼티와 생성자 함수간의 연결이 파괴된다.</span><br><span class="line">&#x2F;&#x2F; 프로토타입의 constructor 프로퍼티로 me 객체의 생성자 함수를 검색하면 Person 이 아닌 Object가 나온다</span><br><span class="line"></span><br><span class="line">console.log(me.constructor &#x3D;&#x3D;&#x3D; Student); &#x2F;&#x2F; false</span><br><span class="line">console.log(me.constructro &#x3D;&#x3D;&#x3D; Object); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<p><strong>차이점 정리</strong></p>
<ul>
<li>생성자 함수에 의한 프로토타입 교체<ul>
<li>Student 생성자 함수의 prototpype 프로퍼티가 교체된 프로토타입을 가리킨다.</li>
</ul>
</li>
<li>인스턴스에 의한 프로토타입 교체<ul>
<li>Student 생성자 함수의 prototype 프로퍼티가 교체된 프로토타입을 가리키지 않는다.</li>
</ul>
</li>
</ul>
<p><strong>인스턴스에 의한 프로토타입 교체 - 생성자 함수와의 연결 되살리기</strong></p>
<p>프로토타입으로 교체한 객체 리터럴에 constructor 프로퍼티를 추가하고 생성자 함수의 prototype 프로퍼티를 재설정하여 파괴된 생성자 함수와 프로토타입 간의 연결을 되살려 보자.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function Student(age) &#123;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const me &#x3D; new Student(23);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;constructor 프로퍼티 추가</span><br><span class="line">const parent &#x3D; &#123;</span><br><span class="line">    constructor: Student,</span><br><span class="line">    showInfo() &#123;</span><br><span class="line">        console.log(&#96;$&#123;this.age&#125;세 입니다&#96;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; prototype 연결</span><br><span class="line">Student.prototype &#x3D; parent;</span><br><span class="line"></span><br><span class="line">Object.setPrototypeOf(me, parent);</span><br><span class="line"></span><br><span class="line">me.showInfo(); &#x2F;&#x2F; 23세 입니다</span><br><span class="line"></span><br><span class="line">console.log(me.constructor &#x3D;&#x3D;&#x3D; Student); &#x2F;&#x2F; true</span><br><span class="line">console.log(me.constructor &#x3D;&#x3D;&#x3D; Object); &#x2F;&#x2F;false</span><br><span class="line"></span><br><span class="line">console.log(Student.prototype &#x3D;&#x3D;&#x3D; Object.getPrototypeOf(me)); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>



<p><strong>클래스의 도입</strong></p>
<p>프로토타입 교체를 통해 객체 간의 상속 관계를 동적으로 변경하는 것은 꽤나 번거롭다. 하지만 ES6에서 도입된 클래스를 사용하면 간편하고 직관적으로 상속 관계를 구현할 수 있다. </p>
<p>프로토타입 교체를 통해 객체 간의 상속 관계를 동적으로 변경하는 것은 번거롭다. 따라서 프로토타입은 직접 교체하지 않는 것이 좋다. 상속관계를 인위적으로 설정하려면 직접 상속이 더 편리하고 안전하다. 또는 ES6에서 도입된 클래스를 사용하면 간편하고 직관적으로 상속 관계를 구현할 수 있다. </p>
<h2 id="10-instanceof-연산자"><a href="#10-instanceof-연산자" class="headerlink" title="10. instanceof 연산자"></a>10. instanceof 연산자</h2><p><strong>instanceof 연산자란</strong></p>
<p>instanceof 연산자는 이항 연산자로서 좌변에 객체를 가리키는 식별자, 우변에 생성자 함수를 가리키는 식별자를 피연산자로 받는다. 만약 우변의 피연산자가 함수가 아닌 경우 TypeError가 발생한다</p>
<p><strong>instanceof 연산자 표현식의 평가값</strong></p>
<ul>
<li>Student.prototype이 me 객체의 프로토타입 체인 상에 존재하므로 true로 평가된다.</li>
<li>Object.prototype이 me 객체의 프로토타입 체인 상에 존재하므로 true 로 평가된다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Student(age) &#123;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const me &#x3D; new Student(23);</span><br><span class="line"></span><br><span class="line">console.log(me instanceof Student); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">console.log(me instanceof Object); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>



<p><strong>instanceof 연산자의 동작과정</strong></p>
<p>instanceof 연산자가 어떻게 상속 관계를 파악하는지, 인스턴스에 읳 프로토타입을 교체해보며 알아본다</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Student(age) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const me &#x3D; new Student(23);</span><br><span class="line"></span><br><span class="line">const parent &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Object.setPrototypeOf(me, parent);</span><br><span class="line"></span><br><span class="line">console.log(Student.prototype &#x3D;&#x3D;&#x3D; parent);&#x2F;&#x2F;false</span><br><span class="line">console.log(parent.constructor &#x3D;&#x3D;&#x3D; Student);&#x2F;&#x2F;false</span><br><span class="line"></span><br><span class="line">console.log(me instanceof Student); &#x2F;&#x2F;false</span><br><span class="line"></span><br><span class="line">console.log(me instanceof Object); &#x2F;&#x2F;true</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>프로토타입 교체시 생성자 함수와의 연결</strong></p>
<p>me 객체는 비록 프로토타입이 교체되어 프로토타입과 생성자 함수간의 연결이 Student 생성자 함수에 의해 생성된 인스턴스임에 틀림이 없다. 그러나 me instanceof Student 는 false 로 평가된다.</p>
<p>이는 Student.prototype이 me 객체의 프로토타입 체인상에 존재하지 않기 때문이다. 따라서 프로토타입으로 교체한 객체 parent 객체를 Student 생성자 함수의 prototype 프로퍼티에 바인딩하면 me instanceof Student는 true로 평가될 것이다.</p>
<p><strong>교체한 프로토타입과 생성자 함수와의 연결</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Student(age) &#123;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const me &#x3D; new Student(23);</span><br><span class="line"></span><br><span class="line">const parent &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Object.setPrototypeOf(me, parent);</span><br><span class="line"></span><br><span class="line">console.log(Student.prototype &#x3D;&#x3D;&#x3D; parent);&#x2F;&#x2F;false</span><br><span class="line">console.log(parent.constructor &#x3D;&#x3D;&#x3D; Student);&#x2F;&#x2F;false</span><br><span class="line"></span><br><span class="line">Student.prototype &#x3D; parent;</span><br><span class="line"></span><br><span class="line">console.log(me instanceof Student); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">console.log(me instanceof Object); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>



<p><strong>instanceof 연산자의 원리</strong></p>
<p>이처럼 instanceof 연산자는 프로토타입의 constructor 프로퍼티가 가리키는 생성자 함수를 찾는 것이 아니라, 생성자 함수의 prototype 에 바인딩된 객체가 프로토타입 체인 상에 존재하는지 확인한다.</p>
<p>instanceof 연산자는 좌변 피연산자의 프로토타입 체인 상에 우변의 피연산자, 즉 생성자 함수의 prototype 프로퍼티에 바인딩된 객체가 존재하는 지 검색한다.</p>
<p>me instanceof Student의 경우, me 객체의 프로토타입 체인 상에 Student.prototype에 바인딩된 객체가  존재하는지 확인한다.</p>
<p>me instnaceof Object 의 경우 me 객체의 프로토타입 체인 상에 Object.prototype에 바인딩된 객체가 존재하는지 확인한다. instanceof 연산자를 함수로 표현하면 다음과 같다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function isInstanceof(instance, constructor) &#123;</span><br><span class="line">    const prototype &#x3D; Object.getPrototypeOf(instance);</span><br><span class="line">    </span><br><span class="line">    if(prototype &#x3D;&#x3D;&#x3D; null) return false;</span><br><span class="line">    </span><br><span class="line">    return prototype &#x3D;&#x3D;&#x3D; constructor.prototype || isInstanceof(prototype, constructor);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> console.log(isInstanceof(me, Student)) ; &#x2F;&#x2F;true</span><br><span class="line"> console.log(isInstanceof(me, Object)); true</span><br><span class="line"> console.log(isInstanceof(me, Array)); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>



<h2 id="11-직접-상속"><a href="#11-직접-상속" class="headerlink" title="11. 직접 상속"></a>11. 직접 상속</h2><h3 id="11-1-Object-create에-의한-직접-상속"><a href="#11-1-Object-create에-의한-직접-상속" class="headerlink" title="11.1 Object.create에 의한 직접 상속"></a>11.1 Object.create에 의한 직접 상속</h3><p><strong>Object.create 메서드의 동작</strong></p>
<p>Object.create 메서드는 명시적으로 프로토타입을 지정하여 새로운 객체를 생성한다. Object.create 메서드도 다른 객체 생성 방식과 마찬가지로 추상연산 OrdinaryObjectCreate를 호출한다. </p>
<p>Object.create 메서드의 첫 번째 매개변수에는 생성할 객체의 프로토타입으로 지정할 객체를 전달한다. 두 번째 매개변수에는 생성할 객체의 프로퍼티 키와 프로퍼티 디스크립터 객체로 이뤄진 객체를 전달한다.  이 객체의 형식은 Object.definePRoperties 메서드의 두 번째 인수와 동일하다. 두 번째 인수는 옵션이므로 생략가능하다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.create(prototype, [propertiesObject])</span><br></pre></td></tr></table></figure>

<p><strong>사용 예시</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">let obj &#x3D; Object.create(null);</span><br><span class="line">console.log(Object.getPrototypeOf(obj) &#x3D;&#x3D;&#x3D; null);</span><br><span class="line"></span><br><span class="line">console.log(obj.toString()); &#x2F;&#x2F; TypeError</span><br><span class="line"></span><br><span class="line">obj &#x3D; Object.create(Object.prototype);</span><br><span class="line">console.log(Object.getPrototypeOf(obj) &#x3D;&#x3D;&#x3D; Object.prototype); &#x2F;&#x2F;true</span><br><span class="line"></span><br><span class="line">obj &#x3D; Object.create(Object.prototype,&#123;</span><br><span class="line">    x: &#123; value: 1, writable: true, enumerable: true, configurable: true&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(obj.x); &#x2F;&#x2F;1</span><br><span class="line">console.log(Object.getPrototypeOf(obj) &#x3D;&#x3D;&#x3D; Object.prototype); &#x2F;&#x2F;true</span><br><span class="line"></span><br><span class="line">const myProto &#x3D; &#123; x: 10&#125;;</span><br><span class="line"></span><br><span class="line">obj &#x3D; Object.create(myProto);</span><br><span class="line">console.log(obj.x);</span><br><span class="line">console.log(Object.getPrototypeOf(obj) &#x3D;&#x3D;&#x3D; myProto); &#x2F;&#x2F;true</span><br><span class="line"></span><br><span class="line">function Person(name) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj &#x3D; Object.create(Person.prototype);</span><br><span class="line">obj.name &#x3D; &#39;Lee&#39;;</span><br><span class="line">console.log(obj.name); &#x2F;&#x2F;Lee</span><br></pre></td></tr></table></figure>



<p><strong>Object.create 메서드의 장점</strong></p>
<p>Object.create 메서드는 첫 번째 매개변수에 전달한 객체의 프로토타입 체인에 속하는 객체를 생성한다. 즉, 객체를 생성하면서 직접적으로 상속을 구현하는 것이다. 이메서드의 장점은 다음과 같다. </p>
<ul>
<li>new 연산자가 없이도 객체를 생성할 수 있다.</li>
<li>프로토타입을 지정하면서 객체를 생성할 수 있다.</li>
<li>객체 리터럴에 의해 생성된 객체도 상속받을 수 있다.</li>
</ul>
<p><strong>Object.prototype의 상속</strong></p>
<p>Object.prototype의 빌트인 메서드인 Object.prototype.hasOwnProperty, Object.prototype.isPrototypeOf, Object.prototype.propertyIsEnumerable 등은 모든 객체의 프로토타입 체인의 종점, 즉 Object.[rototype의 메서드이므로 모든객체가 상속받아 호출할 수 잇다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; &#123;a: 1&#125;;</span><br><span class="line"></span><br><span class="line">obj.hasOwnProperty(&#39;a&#39;); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">obj.propertyISEnumerable(&#39;a&#39;);&#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p><strong>주의점</strong></p>
<p>그런데 ESLint에서는 앞의 예제와 같이 Object.prototype의 빌트인 메서드를 객체가 직접 호출하는 것을 권장하지 않는다. 그 이유는 Object.create메서드를 통해 프로토타입 체인의 종점에 위치하는 객체를 생성할 수 있기 때문이다. 프로토타입 체인으ㅢ 종점에 위치하는 객체는 Object.prototype의 빌트인 메서드를 사용할 수 없다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; Object.create(null);</span><br><span class="line">obj.a &#x3D; 1;</span><br><span class="line"></span><br><span class="line">console.log(Object.getPrototypeOf(obj)&#x3D;&#x3D;&#x3D; null) ; &#x2F;&#x2F;true</span><br><span class="line"></span><br><span class="line">console.log(obj.hasOwnProperty(&#39;a&#39;));&#x2F;&#x2F; TypeError: obj.hasOwnProperty is not a function</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Object.prototype 빌트인 메서드의 간접 호출</strong></p>
<p>따라서 이같은 에러를 발생시킬 위험을 없애기 위해 Object.prototype 의 빌트인 메서드는 다음과 같이 간접적으로 호출하는 것이 좋다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; Object.create(null);</span><br><span class="line">obj.a &#x3D; 1;</span><br><span class="line"></span><br><span class="line">console.log(Object.prototype.hasOwnProperty.call(obj,&#39;a&#39;)); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>



<h3 id="11-2-객체-리터럴-내부에서-proto-에-의한-직접-상속"><a href="#11-2-객체-리터럴-내부에서-proto-에-의한-직접-상속" class="headerlink" title="11.2 객체 리터럴 내부에서 __proto__에 의한 직접 상속"></a>11.2 객체 리터럴 내부에서 <code>__proto__</code>에 의한 직접 상속</h3><p><strong>Object.create의 단점</strong></p>
<p>Object.create 메서드에 의한 직접 상속은 앞에서 다룬 것과 같이 여러 장점이 있다. 하지만 두번째 인자로 프로퍼티를 정의하는 것은 번거롭다. 일단 객체를 생성한 이후 프로퍼티를 추가하는 방법도 있으나 깔끔하지는 않다.</p>
<p><strong>객체리터럴 내부에서의 직접상속 구현</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const myProto &#x3D; &#123; x: 10&#125;;</span><br><span class="line"></span><br><span class="line">const obj &#x3D; &#123;</span><br><span class="line">    y: 20,</span><br><span class="line">    </span><br><span class="line">    __proto__: myProto</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(obj.x, obj.y); &#x2F;&#x2F; 10 20</span><br><span class="line">console.log(Object.getPrototypeOf(obj) &#x3D;&#x3D;&#x3D; myProto); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>



<h2 id="12-정적-프로퍼티-메서드"><a href="#12-정적-프로퍼티-메서드" class="headerlink" title="12. 정적 프로퍼티 / 메서드"></a>12. 정적 프로퍼티 / 메서드</h2><p><strong>정적 프로퍼티 / 메서드란</strong></p>
<p>정적(static) 프로퍼티 / 메서드는 생성자 함수로 인스턴스를 생성하지 않아도 참조/호출할 수 있는 프로퍼티/메서드를 말한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function Student(age) &#123;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;프로토타입 메서드</span><br><span class="line">Student.prototype.showInfo &#x3D; function () &#123;</span><br><span class="line">    console.log(this.age + &#39;세 입니다&#39;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;정적 프로퍼티</span><br><span class="line">Student.staticProp &#x3D; &#39;statick prop&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;정적 메서드</span><br><span class="line">Student.staticMethod &#x3D; function () &#123;</span><br><span class="line">    console.log(&#39;staticMethod&#39;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const me &#x3D; new Student(23);</span><br><span class="line"></span><br><span class="line">Student.staticMethod();</span><br><span class="line"></span><br><span class="line">me.staticMethod(); &#x2F;&#x2F; TypeError</span><br></pre></td></tr></table></figure>

<p>Student 생성자 함수는 객체이므로 자신의 프로퍼티/메서드를 소유할 수 있다. Student 생성자 함수 객체가 소유한 프로퍼티/메서드를 정적 프로퍼티/메서드라고 한다. 정적 프로퍼티/메서드는 생성자 함수가 생성한 인스턴스로 참조/호출할 수 없다.</p>
<p><strong>정적 프로퍼티/메서드의 접근가능성</strong></p>
<p>생성자 함수가 생성한 인스턴스는 자신의 프로토타입 체인에 속한 객체의 프로퍼티/메서드에 접근할 수 있따. 하지만 정적 프로퍼티/메서드는 인스턴스의 프로토타입 체인에 속한 프로퍼티/ 메서드가 아니므로 인스턴스로 접근할 수 없다.</p>
<p><strong>예시</strong></p>
<p>앞에서 살펴본 Object.create 메서드는 Object 생성자 함수의 정적 메서드고 Object.prototype.hasOwnProperty 메서드는 Object.prototype의 메서드다. 따라서 Object.create 메서드는 인스턴스, 즉 Object 생성자 함수가 생성한 객체로 호출할 수 없다. </p>
<p>하지만 Object.prototype.hasOwnProperty 메서드는 모든 객체의 프로토타입 체인의 종점, 즉 Object.prototype의 메서드이므로 모든 객체가 호출할 수 있다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; Object.create(&#123; name: &#39;Lee&#39;&#125;);</span><br><span class="line"></span><br><span class="line">obj.hasOwnProperty(&#39;name&#39;);</span><br></pre></td></tr></table></figure>

<p><strong>정적 메서드 사용이유</strong></p>
<p>인스턴스에서 메서드는 다른 데이터프로퍼티를 참조하거나 변경하는데 사용된다.</p>
<p>만약 인스턴스 / 프로토타입 메서드 내에서 this를 사용하지 않는다면 그 메서드는 정적 메서드로 변경할 수 있다. 인스턴스가 호출한 인스턴스/ 프로토타입 메서드내에서 this는 인스턴스를 가리킨다. 메서드 내에서 인스턴스를 참조할 필요가 없다면 정적 메서드로 변경해도 동작한다. 프로토타입 메서드를 호출하려면 인스턴스를 생성해야하지만 정적 메서드는 인스턴스를 생성하지 않아도 호출할 수 있다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Foo() &#123;&#125;</span><br><span class="line">Foo.prototype.x &#x3D; function () &#123;</span><br><span class="line">    console.log(&#39;x&#39;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const foo &#x3D; new Foo();</span><br><span class="line">&#x2F;&#x2F;프로토타입 메서드를 호출하려면 인스턴스를 생성해야 한다.</span><br><span class="line"></span><br><span class="line">foo.x(); &#x2F;&#x2F;x</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;정적 메서드</span><br><span class="line">Foo.x &#x3D; function() &#123;</span><br><span class="line">    console.log(&#39;x&#39;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Foo.x();&#x2F;&#x2F; x</span><br><span class="line">&#x2F;&#x2F;인스턴스를 생성하지 않아도 메서드를 호출할 수 있다.</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="13-프로퍼티-존재-확인"><a href="#13-프로퍼티-존재-확인" class="headerlink" title="13. 프로퍼티 존재 확인"></a>13. 프로퍼티 존재 확인</h2><h3 id="13-1-in-연산자"><a href="#13-1-in-연산자" class="headerlink" title="13.1 in 연산자"></a>13.1 in 연산자</h3><p><strong>in 연산자의 기능</strong></p>
<p>in 연산자는 객체 내에 특정 프로퍼티가 존재하는 지 여부를 확인한다. in 연산자의 사용방법은 다음과 같다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key in object</span><br></pre></td></tr></table></figure>

<p><strong>사용 예시</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; &#123;</span><br><span class="line">    name: &#39;Lee&#39;,</span><br><span class="line">    address: &#39;Seoul&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(&#39;name&#39; in person); &#x2F;&#x2F; true</span><br><span class="line">console.log(&#39;address&#39; in person); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<p><strong>주의점</strong></p>
<p>in 연산자는 확인 대상 객체의 프로퍼티뿐만 아니라확인 대상 객체가상속받은 모든 프로토타입의 프로퍼티를 확인하므로 주의가 필요하다. person 객체에는 toString이라는 프로퍼티가 없지만 다음 코드의 실행 결과는 true다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#39;toString&#39; in person);</span><br></pre></td></tr></table></figure>

<p><strong>이유</strong></p>
<p>이는 in 연산자가 person 객체에 속한 프로토타입 체인상에 존재하는 모든 프로토타입에서 toString 프로퍼티를 검색했기 때문이다. toString은 Object.prototype의 메서드다.</p>
<p><strong>Reflect.has 메서드</strong></p>
<p>in 연산자 대신 ES6에서 도임된 Reflect.has 메서드를 사용할 수도 있다. Reflect.has 메서드는 in 연산자와 동일하게 동작한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; &#123; name: &#39;Lee&#39;&#125;;</span><br><span class="line"></span><br><span class="line">console.log(Reflect.has(person, &#39;name&#39;));&#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>



<h3 id="13-2-Object-prototype-hasOwnProperty-메서드"><a href="#13-2-Object-prototype-hasOwnProperty-메서드" class="headerlink" title="13.2 Object.prototype.hasOwnProperty 메서드"></a>13.2 Object.prototype.hasOwnProperty 메서드</h3><p>Object.prototype.hasOwnProperty 메서드를 사용해도 객체에 특정프로퍼티가 존재하는지 확인할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(person.hasOwnProperty(&#39;name&#39;)); &#x2F;&#x2F;true</span><br><span class="line">console.log(person.hasOwnProperty(&#39;age&#39;)); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p><strong>특징</strong></p>
<p>Object.hasOwnProperty 메서드는 이름에서 알 수 있듯이 인수로 전달받은 프로퍼티 키가 객체 고유의 프로퍼티 키인 경우에만 true를 반환하고 상속받은 프로토타입의 프로퍼티 키인 경우 false를 반환한다. </p>
<h2 id="14-프로퍼티-열거"><a href="#14-프로퍼티-열거" class="headerlink" title="14. 프로퍼티 열거"></a>14. 프로퍼티 열거</h2><h3 id="14-1-for…-in-문"><a href="#14-1-for…-in-문" class="headerlink" title="14.1 for… in 문"></a>14.1 for… in 문</h3><p><strong>기능</strong></p>
<p>객체의 모든 프로퍼티를 순회하며 열거(enumeration)하려면 for…in 문을 사용한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(변수선언문 in 객체) &#123;...&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; &#123;</span><br><span class="line">    name: &#39;Lee&#39;,</span><br><span class="line">    address: &#39;Seoul&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">for ( const key in person) &#123;</span><br><span class="line">    console.log(key + &#39;: &#39; + person[key]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;name: Lee</span><br><span class="line">&#x2F;&#x2F;address: Seoul</span><br></pre></td></tr></table></figure>

<p><strong>for … in 문의 원리</strong></p>
<p>for … in 문은 객체의 프로퍼티 개수만큼 순회하며 for… in 문의 변수 선언문에서 선언한 변수에 프로퍼티 키를 할당한다. 위 예제의 경우, person 객체에는 2개의 프로퍼티가 있으므로 객체를 2번 순회하면서 프로퍼티 키를 key 변수에 할당한 후 코드블록을 실행한다. 첫 번째 순회에서는 프로퍼티 키 ‘name’을 key 변수에 할당한 후 코드블록을 실행하고 두 번째 순회에서는 프로퍼티 키 ‘address’를 key 변수에 할당한 후 코드 블록을 실행한다.</p>
<p><strong>Object.prototype의 프로퍼티가 열거되지 않는이유</strong></p>
<p>for … in 문은 in 연산자 처럼 순회 대상 객체의 프로퍼티 뿐만 아니라 상속받은 프로토타입의 프로퍼티까지 열거한다. 하지만 toString 같은 Object.prototype의 프로퍼티가 열거되지 않는다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; &#123;</span><br><span class="line">    name: &#39;Lee&#39;,</span><br><span class="line">    address: &#39;Seoul&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(&#39;toString&#39; in person); &#x2F;&#x2F;true</span><br><span class="line"></span><br><span class="line">for (const key in person) &#123;</span><br><span class="line">    console.log(key + &#39;: &#39; + person[key]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;name: Lee</span><br><span class="line">&#x2F;&#x2F;address: Seoul</span><br></pre></td></tr></table></figure>

<p>이는 toString 메서드가 열거할 수 없도록 정의되어 있는 프로퍼티이기 때문이다. 다시말해, Object.prototype.string 프로퍼티의 프로퍼티 어트리뷰트 [[Enumerable]] 의 값이 false이기 때문이다. 프로퍼티 어트리뷰트 [[Enumerable]] 은 프로퍼티의 열거 가능 여부를 나타내며 불리언 값을 갖는다</p>
<p><strong>for … in 문의 기능에대한 정확한 표현</strong></p>
<p>for … in 문은 객체의 프로토타입 체인 상에 존재하는 모든 프로토타입의 프로퍼티 중에서 프로퍼티 어트리뷰트 [[Enumerabl]]의 값이 true인 프로퍼티를 순회하며 열거(enumeration) 한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; &#123;</span><br><span class="line">    name: &#39;Lee&#39;,</span><br><span class="line">    address: &#39;Seoul&#39;,</span><br><span class="line">    __proto__: &#123; age: 20&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">for (const key in person) &#123;</span><br><span class="line">    console.log(key + &#39;: &#39; + person[key]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;name: Lee</span><br><span class="line">&#x2F;&#x2F;address: Seoul</span><br><span class="line">&#x2F;&#x2F;age: 20</span><br></pre></td></tr></table></figure>

<p><strong>예외</strong></p>
<p>for … in 문은 프로퍼티 키가 심벌인 프로퍼티는 열거하지 않는다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const sym &#x3D; Symbol();</span><br><span class="line">const obj &#x3D; &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    [sym]: 10</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">for (const key in obj) &#123;</span><br><span class="line">    console.log(key + &#39;: &#39; + obj[key]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;a: 1</span><br></pre></td></tr></table></figure>

<p><strong>객체 자신의 프로퍼티만을 열거하는 방법</strong></p>
<p>상속받은 프로퍼티는 제외하고 객체 자신의 프로퍼티 만을 열거하려면 Object.prototype.hasOwnProperty 메서드를 사용하여 객체 자신의 프로퍼티인지 확인해야한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; &#123;</span><br><span class="line">    name: &#39;Lee&#39;,</span><br><span class="line">    address: &#39;Seoul&#39;,</span><br><span class="line">    __proto__: &#123;age: 23&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">for(const key in person) &#123;</span><br><span class="line">    if(!person.hasOwnProperty(key)) continue;</span><br><span class="line">    console.log( key + &#39;: &#39; + person[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>for … in 문의 순서</strong></p>
<p>위 예제의 결과는 person 객체의 프로퍼티가 정의된 순서대로 열거되었다. 하지만 for…in 문은 프로퍼티를 열거할 때 순서를 보장하지 않으므로 주의해야한다. 하지만 대부분의 모던 브라우저는 순서를 보장하고 숫자(사실은 문자열) 인 프로퍼티 키에 대해서는 정렬을 실시한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; &#123;</span><br><span class="line">    2: 2,</span><br><span class="line">    3: 3,</span><br><span class="line">    1: 1,</span><br><span class="line">    b: &#39;b&#39;,</span><br><span class="line">    a: &#39;a&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">for(const key in obj) &#123;</span><br><span class="line">    if(!person.hasOwnProperty(key)) continue;</span><br><span class="line">    console.log( key + &#39;: &#39; + obj[key]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*</span><br><span class="line">1: 1</span><br><span class="line">2: 2</span><br><span class="line">3: 3</span><br><span class="line">b: b</span><br><span class="line">a: a</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>



<p><strong>배열의 요소열거</strong></p>
<p>배열에는 for in 문을 사용하지말고 일반적인 for 문이나 for of 문 또는 Array.prototype.forEach 메서드를 사용하는것이좋다. 사실 배열도 객체이므로 프로퍼티와 상속받은 프로퍼티가 포함될 수 있다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, 2, 3];</span><br><span class="line">arr.x &#x3D; 10;</span><br><span class="line"></span><br><span class="line">for (const i in arr) &#123;</span><br><span class="line">    console.log(arr[i]); &#x2F;&#x2F; 1 2 3 10</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    console.log(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr.forEach(v &#x3D;&gt; console.log(v));</span><br><span class="line"></span><br><span class="line">for (const value of arr) &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="14-2-Object-keys-value-entries-메서드"><a href="#14-2-Object-keys-value-entries-메서드" class="headerlink" title="14.2 Object.keys/value/entries 메서드"></a>14.2 Object.keys/value/entries 메서드</h3><p><strong>객체 자신의 고유프로퍼티만을 열거</strong></p>
<p>for in 문은 객체 자신의 고유 프로퍼티 뿐만 아니라 상속받은 프로퍼티도 열거한다. 따라서 Object.prototype.hasOwnProperty 메서드를 사용하여 객체 자신의 프로퍼티인지 확인하는 추가 처리가 필요하다.</p>
<p>객체 자신의 고유 프로퍼티만을 열거하기위해서는 for in 문을 사용하는 것보다 Object.keys/value/entries 메서드를 사용하는것이 좋다.</p>
<p><strong>Object.keys 메서드</strong></p>
<p>Object.keys 메서드는 객체 자신의 열거 가능한(enumerable) 프로퍼티 키를 배열로 반환한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; &#123;</span><br><span class="line">    name: &#39;Lee&#39;,</span><br><span class="line">    address: &#39;Seoul&#39;,</span><br><span class="line">    __proto__: &#123; age: 20&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(Object.keys(person)); [&#39;name&#39;, &#39;address&#39;]</span><br></pre></td></tr></table></figure>



<p><strong>Object.values 메서드</strong></p>
<p>ES8에서 도입된 Object.values 메서드는 객체 자신의 열거 가능한 프로퍼티 값을 배열로 반환한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.values(person)); &#x2F;&#x2F; [&#39;Lee&#39;, &#39;Seoul&#39;]</span><br></pre></td></tr></table></figure>



<p><strong>Object.entries 메서드</strong></p>
<p>Object.entries 메서드는 객체 자신의 열거 가능한 프로퍼티 키와 값의 쌍의 배열을 배열에 담아 반환한다</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.entries(person));</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jjm2317.github.io/2020/09/28/javascript-Sorting-practice/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jeong Jiman">
      <meta itemprop="description" content="All Dev stories found in here.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeong Jiman's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/28/javascript-Sorting-practice/" class="post-title-link" itemprop="url">javascript Sorting practice</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-28 08:20:02" itemprop="dateCreated datePublished" datetime="2020-09-28T08:20:02+09:00">2020-09-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-30 13:39:16" itemprop="dateModified" datetime="2021-03-30T13:39:16+09:00">2021-03-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="정렬확인-버블정렬-과제"><a href="#정렬확인-버블정렬-과제" class="headerlink" title="정렬확인, 버블정렬 과제"></a>정렬확인, 버블정렬 과제</h1><h2 id="정렬-확인"><a href="#정렬-확인" class="headerlink" title="정렬 확인"></a>정렬 확인</h2><p>주어진 배열(array)이 정렬되어 있다면 true, 그렇지 않다면 false를 반환하는 함수를 구현하라. 단, 어떠한 빌트인 함수도 사용하지 않고 for 문을 사용하여 구현하여야 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isSorted</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isSorted([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isSorted([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>])); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>



<p><strong>Answer</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function isSorted(array)&#123;</span><br><span class="line">  if( !(array instanceof Array))&#123;</span><br><span class="line">    throw &#39;this argument is not array&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">  for(let i &#x3D; 0; i &lt; array.length - 1; i++)&#123;</span><br><span class="line">    if(array[i] &gt; array[i+1]) return false;</span><br><span class="line">  &#125;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(isSorted([1,3,2,4]));&#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>



<h2 id="버블정렬"><a href="#버블정렬" class="headerlink" title="버블정렬"></a>버블정렬</h2><ul>
<li>버블 정렬(buble sort)은 순차적으로 배열을 순회하면서 인접한 두 요소를 비교하여 작은 요소를 왼쪽으로, 큰 요소를 오른쪽으로 교환한다.</li>
<li>버블 정렬은 가장 간단하지만 가장 느린 정렬 알고리즘이다.</li>
<li>시간 복잡도: O(n2)</li>
</ul>
<p><img src="https://poiemaweb.com/assets/fs-images/bubble-sort.png" alt="img"></p>
<p>버블 정렬</p>
<p>버블 정렬을 통해 주어진 배열(array)을 정렬하는 함수를 구현하라. 단, 어떠한 빌트인 함수도 사용하지 않고 for 문을 사용하여 구현하여야 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bubbleSort([<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>]));     <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(bubbleSort([<span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>]));  <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="built_in">console</span>.log(bubbleSort([<span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">4</span>, <span class="number">2</span>])); <span class="comment">// [-1, 0, 1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>



<p><strong>Answer</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function bubbleSort(array)&#123;</span><br><span class="line">  let med;</span><br><span class="line">  if( !(array instanceof Array))&#123;</span><br><span class="line">    throw &#39;this argument is not array&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">  for(let i &#x3D; 0; i &lt; array.length - 1; i++)&#123;</span><br><span class="line">    if(array[i] &gt; array[i+1])&#123;</span><br><span class="line">      med &#x3D; array[i+1];</span><br><span class="line">      array[i+1] &#x3D; array[i];</span><br><span class="line">      array[i] &#x3D; med;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if(!isSorted(array))&#123;</span><br><span class="line">    bubbleSort(array);</span><br><span class="line">  &#125;</span><br><span class="line">  return array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(bubbleSort([2,4,5,1,3]));</span><br><span class="line">&#x2F;&#x2F;[ 1, 2, 3, 4, 5 ]</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jjm2317.github.io/2020/09/25/javascript-18FirstClassObject/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jeong Jiman">
      <meta itemprop="description" content="All Dev stories found in here.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeong Jiman's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/25/javascript-18FirstClassObject/" class="post-title-link" itemprop="url">javascript 18FirstClassObject</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-25 11:28:15" itemprop="dateCreated datePublished" datetime="2020-09-25T11:28:15+09:00">2020-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-30 13:39:16" itemprop="dateModified" datetime="2021-03-30T13:39:16+09:00">2021-03-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="함수와-일급-객체"><a href="#함수와-일급-객체" class="headerlink" title="함수와 일급 객체"></a>함수와 일급 객체</h1><h2 id="1-일급-객체"><a href="#1-일급-객체" class="headerlink" title="1. 일급 객체"></a>1. 일급 객체</h2><p><strong>일급 객체의 조건</strong></p>
<p>다음과 같은 조건을 만족하는 객체를 일급 객체(first-class object)라한다</p>
<ul>
<li>무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성가능하다</li>
<li>변수나 자료구조(객체, 배열 등) 에 저장할 수 있다</li>
<li>함수의 매개변수에게 전달할 수 있다.</li>
<li>함수의 반환값으로 사용할 수 있다.</li>
</ul>
<p><strong>함수는 일급 객체이다</strong></p>
<p>자바스크립트의 함수는 위의 조건을 모두 만족하므로 일급 객체이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="2-함수-객체의-프로퍼티"><a href="#2-함수-객체의-프로퍼티" class="headerlink" title="2. 함수 객체의 프로퍼티"></a>2. 함수 객체의 프로퍼티</h2><p><strong>함수는 프로퍼티를 가질 수 있다</strong></p>
<p>함수는 객체이다. 따라서 함수도 프로퍼티를 가질 수 있다. 브라우저 콘솔에서 console.dir 메서드 실행하면 프로퍼티가 내부에 존재하는 것을 알 수 있다.]</p>
<p><strong>함수의 프로퍼티의 프로퍼티어트리뷰트</strong></p>
<p>함수의 프로퍼티에 대해 Object.getOwnPropertyDescriptors 메서드로 확인해보면 다음의 프로퍼티가 존재한다</p>
<ul>
<li>데이터 프로퍼티<ul>
<li>arguments, caller, length, name, prototype</li>
<li>일반 객체에는 없는 함수객체 고유의 프로퍼티</li>
</ul>
</li>
<li>접근자 프로퍼티<ul>
<li><code>__proto__</code><ul>
<li>Object.prototype 객체의 프로퍼티를 상속받았다</li>
<li>모든 객체가 사용할 수 있다</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-1-arguments-프로퍼티"><a href="#2-1-arguments-프로퍼티" class="headerlink" title="2.1 arguments 프로퍼티"></a>2.1 arguments 프로퍼티</h3><p><strong>arguments의 프로퍼티 값</strong></p>
<p>함수 객체의 arguments 프로퍼티 값은 arguments 객체다. arguments 객체는 함수 호출 시 전달된 인수(argument)들의 정보를 담고 있는 순회 가능한(iterable) 유사 배열 객체이며, 함수 내부에서 지역변수처럼 사용된다. 함수외부에서는 참조할 수 없다.</p>
<p><strong>권장 사용법</strong></p>
<p>arguments 프로퍼티는 ES3 부터 표준에서 폐지되었다. </p>
<p>Function.arguments와 같은 사용법은 권장되지 않으며 함수 내부에서 지역 변수처럼 사용할 수 있는 arguments 객체를 참조하도록 하자</p>
<p><strong>arguments 객체의 기능</strong></p>
<p>함수를 정의할 때 선언한 매개변수는 함수 몸체 내부에서 변수와 동일하게 취급된다. 즉, 함수가 호출되면 함수 몸체 내에서 암묵적으로 매개변수가 선언되고 undefined로 초기화된 이후 인수가 할당된다.</p>
<p>선언된 매개변수의 개수보다 인수를 적게 전달했을 경우 인수가 전달되지 않은 매개변수는 undefined로 초기화된 상태를 유지한다. 매개변수의 개수보다 인수를 더 많이 전달한 경우 초과된 인수는 arguments 객체의 프로퍼티로 보관된다</p>
<p>arguments 객체는 인수를 프로퍼티 값으로 소유하며 프로퍼티 키는 인수의 순서를 나타낸다. arguents 객체의 callee 프로퍼티는 호출되어 arguments 객체를 생성한 함수, 즉 함수 자신을 가리키고 argumnets 객체의 length 프로퍼티는 인수의 개수를 가리킨다.</p>
<p><strong>arguments 객체의 Symbol(Symbol.iterator)프로퍼티</strong></p>
<p>arguments 객체의 Symbol 프로퍼티는 arguments 객체를 순회 가능한 자료구조인 iterable 로 만들기 위한 프로퍼티다. Symbol.iteraotr를 프로퍼티 키로 사용한 메서드를 구현하는 것에 의해 이터러블이 된다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function multiply(x,y )&#123;</span><br><span class="line">    &#x2F;&#x2F;이터레이터</span><br><span class="line">    const iterator &#x3D; argumnts[Symbol.iterator]();</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;이터레이터의 next 메서드를 호출하여 이터러블 객체 arguments를 순회</span><br><span class="line">    console.log(iterator.next());&#x2F;&#x2F; value: 1</span><br><span class="line">    console.log(iterator.next());&#x2F;&#x2F; value: 2</span><br><span class="line">    </span><br><span class="line">    return x * y;</span><br><span class="line">&#125;</span><br><span class="line">multiply(1,2,3);</span><br></pre></td></tr></table></figure>



<p><strong>arguments 객체를 통한 가변인자 함수 구현</strong></p>
<p>선언된 매개변수의 개수와 함수를 호출할 때 전달하는 인수의 개수를 확인하지 않는 자바스크립트의 특성 때문에 함수가 호출되면 인수 개수를 확인하고 이에 따라 함수의 동작을 달리 정의할 필요가 있을 수 있다. 이때 유용하게 사용되는 것이 arguments 객체다. </p>
<p>arguments 객체는 매개변수 개수를 확정할 수 없는 가변 인자 함수를 구현할 때 사용된다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function multiply()&#123;</span><br><span class="line">    let res &#x3D; 1;</span><br><span class="line">    for(let i &#x3D; 0; i &lt; arguments.length; i++)&#123;</span><br><span class="line">        res *&#x3D; arguments[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(multiply());&#x2F;&#x2F;1</span><br><span class="line">console.log(multiply(1,2,6)); &#x2F;&#x2F;12</span><br></pre></td></tr></table></figure>



<p><strong>arguments 객체는 유사배열 객체이다.</strong></p>
<p>arguments 객체는 배열 형태로 인자 정보를 담고 있지만 실제 배열이 아닌 유사 배열 객체 (array- like-object)다. 유사 배열 객체란 length 프로퍼티를 가진 객체로 for 문으로 순회가능한 객체를 말한다. </p>
<p><strong>유사 배열 객체와 이터러블</strong></p>
<p>ES6에서 도입된 이터레이션 프로토콜을 준수하면 순회가능한 자료구조인 이터러블이 된다. 이터러블의 개념이 없었던 ES5에서 arguments 객체는 유사배열객체로 구분되었다. 하지만 이터러블이 도입된 ES6부터 arguments 객체는 유사 배열 객체이면서 동시에 이터러블이다.</p>
<p><strong>유사 배열 객체의 특징</strong></p>
<p>유사 배열 객체는 배열이 아니므로 배열 메서드를 사용할 경우 에러가 발생한다. 따라서 배열 메서드를 사용하려면 Function.prototype.call, Function.prototype.apply 를 사용해 간접 호출해야하는 번거로움이 있다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function multiply()&#123;</span><br><span class="line">    const array &#x3D; Array.prototype.slice.call(arguments);</span><br><span class="line">    return array.reduce(function (pre, cur) &#123;</span><br><span class="line">        return pre * cur;</span><br><span class="line">    &#125;, 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(multiply());&#x2F;&#x2F;1</span><br><span class="line">console.log(multiply(1,2,6)); &#x2F;&#x2F;12</span><br></pre></td></tr></table></figure>



<p><strong>ES6의 Rest 파라미터</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function multiply(...args)&#123;</span><br><span class="line">    return args.reduce((pre, cur) &#x3D;&gt; pre * cur, 1);</span><br><span class="line">&#125;</span><br><span class="line">console.log(multiply(3,5,6));&#x2F;&#x2F;90</span><br></pre></td></tr></table></figure>



<h3 id="2-2-caller-프로퍼티"><a href="#2-2-caller-프로퍼티" class="headerlink" title="2.2 caller 프로퍼티"></a>2.2 caller 프로퍼티</h3><p><strong>caller 프로퍼티의 값</strong></p>
<p>caller 프로퍼티는 ECMAScript 사양에 포함되지 않은 비표준 프로퍼티다. 이후 표준화될 예정도 없는 프로퍼티이므로 참고로만 알아두자.</p>
<p>함수객체의 caller 프로퍼티는 함수 자신을 호출한 함수를 가리킨다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function foo(func) &#123;</span><br><span class="line">    return func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">    return &#39;caller: &#39; + bar.caller;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(foo(bar));&#x2F;&#x2F;caller: function foo(func) &#123;</span><br><span class="line">    return func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(bar());</span><br></pre></td></tr></table></figure>



<h3 id="2-3-length-프로퍼티"><a href="#2-3-length-프로퍼티" class="headerlink" title="2.3 length 프로퍼티"></a>2.3 length 프로퍼티</h3><p>함수 객체의 length 프로퍼티는 함수를 정의할 때 선언한 매개변수의 개수를 가리킨다. </p>
<h3 id="2-4-name-프로퍼티"><a href="#2-4-name-프로퍼티" class="headerlink" title="2.4 name 프로퍼티"></a>2.4 name 프로퍼티</h3><p>함수 객체의 name 프로퍼티는 함수 이름을 나타낸다 ES6부터 정식 표준이다.</p>
<p>익명함수 표현식에서, ES5에서는 빈문자열을 반환했지만, ES6에서는 함수객체를 가리키는 식별자를 반환한다.</p>
<h3 id="2-5-proto-접근자-프로퍼티"><a href="#2-5-proto-접근자-프로퍼티" class="headerlink" title="2.5 __proto__접근자 프로퍼티"></a>2.5 <code>__proto__</code>접근자 프로퍼티</h3><p>모든 객체는 [[Prototype]]이라는 내부 슬롯을 갖는다. [[Prototype] ]내부슬롯은 객체 지향 프로그래밍의 상속을 구현하는 프로토타입 객체를 가리킨다. </p>
<p><code>__proto__</code>접근자 프로퍼티는 [[Prototype]]내부 슬롯이 가리키는 프로토타입 객체에 접근하기 위해 사용하는 접근자 프로퍼티다.</p>
<h3 id="2-6-prototype-프로퍼티"><a href="#2-6-prototype-프로퍼티" class="headerlink" title="2.6 prototype 프로퍼티"></a>2.6 prototype 프로퍼티</h3><p>prototype 프로퍼티는 생성자 함수로 호출할 수 있는 함수 객체, 즉 constructor 만이 소유하는 프로퍼티다. 일반 객체와 생성자 함수로 호출할 수 없는 non-constructor 에는 prototype 프로퍼티가 없다. </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jjm2317.github.io/2020/09/24/javascript-17Constructor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jeong Jiman">
      <meta itemprop="description" content="All Dev stories found in here.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeong Jiman's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/24/javascript-17Constructor/" class="post-title-link" itemprop="url">javascript 17Constructor</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-24 21:26:53" itemprop="dateCreated datePublished" datetime="2020-09-24T21:26:53+09:00">2020-09-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-30 13:39:16" itemprop="dateModified" datetime="2021-03-30T13:39:16+09:00">2021-03-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="생성자-함수에-의한-객체-생성"><a href="#생성자-함수에-의한-객체-생성" class="headerlink" title="생성자 함수에 의한 객체 생성"></a>생성자 함수에 의한 객체 생성</h1><h2 id="1-Object-생성자-함수"><a href="#1-Object-생성자-함수" class="headerlink" title="1. Object 생성자 함수"></a>1. Object 생성자 함수</h2><p><strong>생성자 함수란</strong></p>
<p>생성자 함수(constructor)란 new 연산자와 함께 호출하여 객체(instance)를 생성하는 함수를 말한다. 생성자 함수에 의해 생성된 객체를 인스턴스(instance)라고 한다. </p>
<p><strong>Object 생성자 함수에 의한 객체 생성</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">person.name &#x3D; &#39;Jeong&#39;;</span><br><span class="line">person.sayHello &#x3D; function () &#123;</span><br><span class="line">    console.log(&#96;My name is $&#123;this.name&#125;&#96;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(person); &#x2F;&#x2F;&#123;name: &#39;Jeong&#39;, sayHello: f&#125;</span><br></pre></td></tr></table></figure>



<p><strong>자바스크립트의 빌트인(built in, 내장) 생성자 함수</strong></p>
<p>자바스크립트는 Object 생성자 함수 이외에도 String, Number, Boolean, Function, Array, Date, RegExp, Promise 등의 빌트인 생성자 함수를 제공한다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; String 생성자 함수</span><br><span class="line">const strObj &#x3D; new String(&#39;Jeong&#39;);</span><br><span class="line">console.log(strObj); &#x2F;&#x2F;[String: &#39;Jeong&#39;]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Number 생성자 함수</span><br><span class="line">const numObj &#x3D; new Number(111);</span><br><span class="line">console.log(numObj); &#x2F;&#x2F; [Number: 111]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Boolean 생성자 함수</span><br><span class="line">const boolObj &#x3D; new Boolean(true); &#x2F;&#x2F; [Boolean: true]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Function 생성자 함수</span><br><span class="line">const func &#x3D; new Function(&#39;x&#39;, &#39;return x * x&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Array 생성자 함수</span><br><span class="line">const arr &#x3D; new Array(1,3,5);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;RegExp 생성자 함수</span><br><span class="line">const regExp &#x3D; new RegExp(&#x2F;ab+c&#x2F;i);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Date 생성자 함수</span><br><span class="line">const date &#x3D; new Date();</span><br></pre></td></tr></table></figure>



<h2 id="2-생성자-함수"><a href="#2-생성자-함수" class="headerlink" title="2. 생성자 함수"></a>2. 생성자 함수</h2><h3 id="2-1-객체-리터럴에-의한-객체-생성-방식의-문제점"><a href="#2-1-객체-리터럴에-의한-객체-생성-방식의-문제점" class="headerlink" title="2.1 객체 리터럴에 의한 객체 생성 방식의 문제점"></a>2.1 객체 리터럴에 의한 객체 생성 방식의 문제점</h3><p><strong>객체를 여러개 생성하기 번거롭다</strong></p>
<p>객체 리터럴에 의한 객체 생성 방식은 직관적이고 간편하다. 하지만객체 리터럴에 의한 객체 생성 방식은 단 하나의 객체만 생성한다. </p>
<p>동일한 프로퍼티를 갖는 객체를 여러개 생성해야 하는 경우 매번 같은프로퍼티를 기술해야 하기 때문에 비효율적이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const circle1 &#x3D; &#123;</span><br><span class="line">    radius: 5,</span><br><span class="line">    getDiameter() &#123;</span><br><span class="line">        return 2 * this.radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(circle1.getDiameter()); &#x2F;&#x2F;10</span><br><span class="line"></span><br><span class="line">const circle2 &#x3D; &#123;</span><br><span class="line">    radius: 10,</span><br><span class="line">    getDiamter() &#123;</span><br><span class="line">        return 2 * this.radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(circle2.getDiameter()); &#x2F;&#x2F; 20</span><br></pre></td></tr></table></figure>

<p>동일한 객체를 여러개 생성한다면, 같은 내용의 메서드를 여러번 기술해야되는 번거로움이 있다. </p>
<p><strong>메서드는 동일한 경우가 많다</strong></p>
<p>객체는 프로퍼티를 통해 객체 고유의 상태(state)를 표현한다. 그리고 메서드를 통해 상태 데이터인 프로퍼티를 참조하고 조작하는 동작(behavior)을 표현한다. 객체마다 프로퍼티 값이 다를 수 있찌만 메서드는 내용이 동일한 경우가 일반적이다.</p>
<h3 id="2-2-생성자-함수에-의한-객체-생성-방식의-장점"><a href="#2-2-생성자-함수에-의한-객체-생성-방식의-장점" class="headerlink" title="2.2 생성자 함수에 의한 객체 생성 방식의 장점"></a>2.2 생성자 함수에 의한 객체 생성 방식의 장점</h3><p><strong>간편하게 동일한 구조의 객체를 여러개  생성 가능하다.</strong></p>
<p>생성자 함수에 의한 객체 생성 방식은 마치 객체(instance)를 생성하기 위한 템플릿 (클래스)처럼 생성자 함수를 사용하여 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Circle(radius) &#123;</span><br><span class="line">    this.radius &#x3D; radius;</span><br><span class="line">    this.getDiameter &#x3D; function () &#123;</span><br><span class="line">        return 2 * this.radius;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const circle1 &#x3D; new Circle(5);</span><br><span class="line">console.log(circle1.getDiameter());&#x2F;&#x2F; 10</span><br><span class="line"></span><br><span class="line">const circle2 &#x3D; new Circle(10);</span><br><span class="line">console.log(circle2.getDiameter()); &#x2F;&#x2F; 20</span><br></pre></td></tr></table></figure>



<p><strong>this 바인딩은 함수 호출 방식에 따라 결정된다.</strong></p>
<ul>
<li>일반 함수로 호출<ul>
<li>전역객체에 바인딩</li>
</ul>
</li>
<li>메서드로 호출<ul>
<li>메서드를 호출한 객체</li>
</ul>
</li>
<li>생성자 함수로 호출<ul>
<li>생성자 함수가 생성할 인스턴스</li>
</ul>
</li>
</ul>
<p><strong>생성자 함수는 일반함수와 호출 방식에 차이가 있다</strong></p>
<p>생성자 함수는 이름 그대로 객체(인스턴스)를 생성하는 함수다. 하지만 자바와 같은 클래스 기반 객체지향 언어의 생성자(constructor)와는 다르게 그 형식이 정해져 있는 것이 아니라 일반 함수와 동일한 방법으로 생성자 함수를 정의한다. </p>
<p>일반함수와는 호출방식에서 차이가 있다. </p>
<ul>
<li>new 연산자와 함께 호출<ul>
<li>생성자 함수로 동작</li>
</ul>
</li>
<li>new 연산자 없이 호출<ul>
<li>일반 함수로 동작</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Rectangle(width &#x3D; 1, height &#x3D; 1) &#123;</span><br><span class="line">    this.width &#x3D; width;</span><br><span class="line">    this.height &#x3D; height;</span><br><span class="line">    </span><br><span class="line">    this.getArea()&#123;</span><br><span class="line">        return this.width * this.height;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;일반함수로 호출 시 this는 전역 객체를 가리킨다.</span><br><span class="line">const rect1 &#x3D; Rectangle(2, 3);</span><br><span class="line">console.log(width); &#x2F;&#x2F; 2</span><br><span class="line">console.log(heigth); &#x2F;&#x2F; 3</span><br><span class="line">getArea();&#x2F;&#x2F; 6 </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2-3-생성자-함수의-인스턴스-생성-과정"><a href="#2-3-생성자-함수의-인스턴스-생성-과정" class="headerlink" title="2.3 생성자 함수의 인스턴스 생성 과정"></a>2.3 생성자 함수의 인스턴스 생성 과정</h3><p><strong>인스턴스 생성과 초기화</strong></p>
<p>생성자 함수의 함수 몸체에서 수행해야 하는 것이 무엇인지 생각해보자. 생성자 함수의 역할은 프로퍼티 구조가 동일한 인스턴스를 생성하기 위한 템플릿(클래스)으로서 동작하여 인스턴스를 생성하는 것과 생성된 인스턴스를 초기화(인스턴스 프로퍼티 추가 및 초기값 할당)하는 것이다. </p>
<p>생성자 함수가 인스턴스를 생성하는 것은 필수이고, 생성된 인스턴스를 초기화하는 것은 옵션이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Rectangle(width &#x3D; 1, height &#x3D; 1) &#123;</span><br><span class="line">    &#x2F;&#x2F;인스턴스 초기화</span><br><span class="line">    this.width &#x3D; width;</span><br><span class="line">    this.height &#x3D; height;</span><br><span class="line">    </span><br><span class="line">    this.getArea()&#123;</span><br><span class="line">        return this.width * this.height;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;인스턴스 생성</span><br><span class="line">const rect1 &#x3D; new Rectangle( 3, 4); 가로3 세로4인 객체 생성</span><br></pre></td></tr></table></figure>

<p><strong>인스턴스는 암묵적으로 생성되고 반환된다.</strong></p>
<p>생성자 함수의 내부 코드를 보면 this에 프로퍼티를 추가해서 초기화하는 것을 알 수 있다. 하지만 인스턴스를 생성하는 코드는 보이지 않는다.</p>
<p>자바스크립트 엔진은 암묵적인 처리를 통해 인스턴스를 생성하고 반환한다. </p>
<p>new 연산자와 함께 생성자 함수를 호출하면 자바스크립트 엔진은 다음과 같은 과정을 거쳐 암묵적으로 인스턴스를 생성하고 인스턴스를 초기화한 후 암묵적으로 인스턴스를 반환한다.</p>
<p><strong>1. 인스턴스 생성과 this 바인딩</strong></p>
<p>new 연산자와 함깨 생성자 함수가 호출 되면 암묵적으로 빈 객체가 생성된다. 이 빈 객체가 생성자 함수가 생성한 인스턴스이며, 이 빈 객체는 this에 바인딩된다. </p>
<p>즉 생성자 함수의 내부의 this는 생성할 인스턴스를 가리킨다.</p>
<p>이 처리는 런타임 이전에 실행된다. </p>
<p><strong>바인딩(binding)이란</strong></p>
<p>바인딩(name binding)이란 식별자와 값을 연결하는 과정을 의미한다. </p>
<p>변수 선언의 경우 변수이름과 확보된 메모리공간을 바인딩하는 것이다. this는 키워드이지만 식별자 역할을 한다. this 바인딩은 this와 this가 가리킬 객체를 바인딩하는 것이다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Rectangle(width &#x3D; 1, height &#x3D; 1) &#123;</span><br><span class="line">    &#x2F;&#x2F; 1. 런타임 이전에 암묵적으로 빈 객체가 생성되고 this에 바인딩된다. </span><br><span class="line">    this.width &#x3D; width;</span><br><span class="line">    this.height &#x3D; height;</span><br><span class="line">    </span><br><span class="line">    this.getArea()&#123;</span><br><span class="line">        return this.width * this.height;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">new Rectangle(2,3);</span><br></pre></td></tr></table></figure>



<p><strong>2. 인스턴스 초기화</strong></p>
<p>생성자 함수에 기술되어 있는 코드가 한 줄씩 실행되어 this에 바인딩되어 있는 인스턴스를 초기화한다. </p>
<p>this에 바인딩되어 있는 객체에 프로퍼티와 메서드를 추가하고 인수로 전달받은 초기값을 바인딩된 인스턴스의 프로퍼티에 할당한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Rectangle(width &#x3D; 1, height &#x3D; 1) &#123;</span><br><span class="line">    &#x2F;&#x2F; 1. 런타임 이전에 암묵적으로 빈 객체가 생성되고 this에 바인딩된다. </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 2. this에 바인딩된 인스턴스를 초기화한다.</span><br><span class="line">    this.width &#x3D; width;</span><br><span class="line">    this.height &#x3D; height;</span><br><span class="line">    </span><br><span class="line">    this.getArea()&#123;</span><br><span class="line">        return this.width * this.height;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">new Rectangle(2,3);</span><br></pre></td></tr></table></figure>



<p><strong>3. 인스턴스 반환</strong></p>
<p>생성자 함수의 모든 문이실행되고 인스턴스의 생성, 초기화가 끝나면 자바스크립트 엔진은 암묵적으로 해당 인스턴스를 반환한다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Rectangle(width &#x3D; 1, height &#x3D; 1) &#123;</span><br><span class="line">    &#x2F;&#x2F; 1. 런타임 이전에 암묵적으로 빈 객체가 생성되고 this에 바인딩된다. </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 2. this에 바인딩된 인스턴스를 초기화한다.</span><br><span class="line">    this.width &#x3D; width;</span><br><span class="line">    this.height &#x3D; height;</span><br><span class="line">    </span><br><span class="line">    this.getArea()&#123;</span><br><span class="line">        return this.width * this.height;</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F;3. this에 바인딩된 인스턴스 암묵적 반환</span><br><span class="line">&#125;</span><br><span class="line">new Rectangle(2,3);</span><br></pre></td></tr></table></figure>



<p><strong>return 값을 명시한다면?</strong></p>
<p>만약 this가 아닌 다른 객체를 명시적으로 반환하면 this에 바인딩된 인스턴스가 반환되는 것이 아니라, 명시적으로 기술한 객체가 반환된다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Rectangle(width &#x3D; 1, height &#x3D; 1) &#123;</span><br><span class="line">    &#x2F;&#x2F; 1. 런타임 이전에 암묵적으로 빈 객체가 생성되고 this에 바인딩된다. </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 2. this에 바인딩된 인스턴스를 초기화한다.</span><br><span class="line">    this.width &#x3D; width;</span><br><span class="line">    this.height &#x3D; height;</span><br><span class="line">    </span><br><span class="line">    this.getArea()&#123;</span><br><span class="line">        return this.width * this.height;</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F;3.this에 바인딩된 인스턴스 암묵적 반환</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;객체를 명시적으로 반환시 this반환이 무시된다.</span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">const rect1 &#x3D; new Rectangle(2,3);</span><br><span class="line"></span><br><span class="line">console.log(rect1);&#x2F;&#x2F;&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>원시값을 반환한다면</strong> 원시값반환이 무시되고 암묵적으로 this가 반환된다.</p>
<p>결론적으로 생성자 함수를 만들 때 return 문을 사용하면 안된다. 생성자 함수의 기본 동작을 훼손하기 때문이다. </p>
<h3 id="2-4-내부-메서드-Call-과-Construct"><a href="#2-4-내부-메서드-Call-과-Construct" class="headerlink" title="2.4 내부 메서드 [[Call]]과 [[Construct]]"></a>2.4 내부 메서드 [[Call]]과 [[Construct]]</h3><p><strong>함수는 일반 객체와 동일하게 동작할 수 있다.</strong></p>
<p>함수 선언문 또는 함수 표현식으로 정의한 함수는 일반 함수로 호출할 수 있으며, 생성자 함수로서 호출할 수도 있다.</p>
<p>생성자 함수로 호출하는 것은 new 연산자와 함께 함수를 호출하여 객체를 생성하는 것이다. </p>
<p>함수는 객체이므로 일반 객체(ordinary object)와 동일하게 동작할 수 있다. 함수 객체는 일반 객체가 가지고 있는 내부 슬롯과 내부 메서드를 모두 가지고 있기 때문이다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;&#125;</span><br><span class="line">&#x2F;&#x2F;함수는 객체이므로 프로퍼티를 소유할 수 있다</span><br><span class="line">foo.name &#x3D; &#39;Jiman&#39;;</span><br><span class="line">&#x2F;&#x2F;메서드도 소유할 수 있다.</span><br><span class="line">foo.getName &#x3D; function() &#123;return this.name&#125;;</span><br><span class="line"></span><br><span class="line">console.log(foo.getName()); &#x2F;&#x2F;Jiman</span><br></pre></td></tr></table></figure>



<p><strong>함수와 일반 객체의 차이점</strong></p>
<p>함수는 객체이지만 일반 객체와는 다르다.  일반객체는 호출할 수 없지만 함수는 호출할 수 있다. </p>
<p>함수는 일반 객체가 가진 내부 슬롯과 내부메서드를 가지고 있고, 추가로 함수로 동작하기 위한 내부 슬롯과 내부메서드를 가지고 있다. </p>
<p>함수 객체만을 위한 내부 슬롯,메서드 예시</p>
<ul>
<li>내부슬롯  <ul>
<li>[[Environment]], [[FormalParameters]] 등</li>
</ul>
</li>
<li>내부 메서드<ul>
<li>[[Call]], [[Construct]] 등</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;&#125;</span><br><span class="line"></span><br><span class="line">foo(); &#x2F;&#x2F; 내부 메서드 [[Call]] 호출</span><br><span class="line"></span><br><span class="line">new foo(); &#x2F;&#x2F; 내부메서드 [[Construct]] 호출</span><br></pre></td></tr></table></figure>



<p><strong>함수객체의 내부 메서드</strong></p>
<p>내부 메서드 [[Call]] 을 갖는 함수 객체를 callable이라 하며, 내부 메서드 [[Construct]]를 갖는 함수 객체를 constructor, [[Construct]]를 갖지 않는 객체를 non-constructor 이라고 부른다.</p>
<p>callable은 호출할 수 있는 객체, 즉 함수를 말한다.</p>
<p>constructor는 생성자 함수로서 호출할 수 있는 함수, non-constructor는 객체를 생성자 함수로서 호출할 수 없는 함수를 의미한다.</p>
<p>호출이 가능한 것은 함수 객체가 되기위한 필요조건이다. 즉 모든 함수 객체는 내부메서드 [[Call]]  을 가져서 callable 이어야한다.</p>
<p>단, 모든 함수 객체가 [[Construct]]를 갖는 것은 아니다. 모든 함수는 호출 가능하지만, 모든 함수가 생성자 함수로서 호출가능하진 않다.</p>
<ul>
<li>모든 함수는 callable이다.</li>
<li>constructor인 함수도 있고 non-constructor인 함수도 있다</li>
</ul>
<h3 id="2-5-constructor와-non-constructor의-구분"><a href="#2-5-constructor와-non-constructor의-구분" class="headerlink" title="2.5 constructor와 non-constructor의 구분"></a>2.5 constructor와 non-constructor의 구분</h3><p><strong>함수 정의 방식에 따른 constructor 구분</strong></p>
<p>자바스크립트 엔진이 어떻게 constructor와 non-constructor를 구분하는지 살펴보자. 자바스크립트 엔진은 함수 정의를 평가하여 함수객체를 생성할 때, 함수 정의 방식에 따라 함수를 constructor과 non-constructor로 구분한다.</p>
<ul>
<li>constructor : 함수 선언문, 함수 표현식, 클래스</li>
<li>non-constructor : 메서드(ES6메서드 축약 표현), 화살표 함수<ul>
<li>메서드는 메서드 축약표현만을 인정한다.</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;constructor</span><br><span class="line">&#x2F;&#x2F;일반 함수 정의: 함수 선언문, 함수 표현식</span><br><span class="line"></span><br><span class="line">function foo() &#123;&#125;</span><br><span class="line">const bar &#x3D; function () &#123;&#125;;</span><br><span class="line">const baz &#x3D; &#123;</span><br><span class="line">    f: function()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;baz의 프로퍼티 f에 할당된 함수는 일반적인 의미로는 메서드이지만 ES6에서는 메서드로 인정하지 않는 일반함수이다.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;일반 함수로 정의된 함수는 constructor</span><br><span class="line">new foo();</span><br><span class="line">new bar();</span><br><span class="line">new baz.f();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;non-constructor</span><br><span class="line">&#x2F;&#x2F;화살표 함수, 메서드</span><br><span class="line"></span><br><span class="line">const arrow &#x3D; () &#x3D;&gt; &#123;&#125;;</span><br><span class="line">const obj &#x3D; &#123;</span><br><span class="line">    f()&#123;&#125; &#x2F;&#x2F;축약표현만이 메서드로 인정</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;constructor 가 아니다, 에러 발생</span><br><span class="line">new arrow();</span><br><span class="line">new obj.f();</span><br><span class="line">&#x2F;&#x2F;TypeError: arrow(obj.f) is not a constructor</span><br></pre></td></tr></table></figure>

<p><strong>ECMAScript 사양에서의 메서드</strong></p>
<p>일반적으로 함수를 프로퍼티 값으로 사용하면 메서드로 통칭한다. 그러나 ECMAScript 사양에서는 메서드란 ES6의 메서드 축약표현을 의미한다. 즉 메서드는 다음 조건을 만족해야한다.</p>
<ul>
<li>함수를 프로퍼티 값으로 사용</li>
<li>메서드 축약표현으로 기술</li>
</ul>
<p><strong>함수의 호출방식에 따른 내부 메서드 동작</strong></p>
<p>함수를 일반 함수로 호출했을때와 new 연산자와 함께 생성자 함수로 호출했을 때 호출되는 내부메서드가 다르다</p>
<ul>
<li>일반 함수로서 호출<ul>
<li>[[Call]] 호출</li>
</ul>
</li>
<li>생성자 함수로서 호출<ul>
<li>[[Constructor]] 호출</li>
<li>non-constructor 호출 시 에러</li>
</ul>
</li>
</ul>
<p><strong>주의점</strong></p>
<p>일반함수로 사용할 것을 목적으로 정의한 일반함수를 new 연산자와 호출하면 목적과는 달리 생성자 함수로 동작할 수 있다. </p>
<h3 id="2-6-new-연산자"><a href="#2-6-new-연산자" class="headerlink" title="2.6 new 연산자"></a>2.6 new 연산자</h3><p><strong>new 연산자를 통한 호출방식 구분</strong></p>
<p>일반 함수와 생성자 함수에 특별한 형식적 차이는 없다. new 연산자와 함께 함수를 호출하면 해당 함수는 생성자 함수로 동작한다. 다시 말해, 함수 객체의 내부 메서드 [[Call]] 이 호출되는 것이 아니라 [[Construct]]가 호출된다.</p>
<p>new 연산자와 함께 호출하는 함수는 constructor 이어야 한다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;생성자 함수로서 정의하지 않은 일반 함수</span><br><span class="line">function foo()&#123;return 100;&#125;</span><br><span class="line">const obj1 &#x3D; new foo();</span><br><span class="line"></span><br><span class="line">console.log(obj1);&#x2F;&#x2F;&#123;&#125; 원시값을 반환하는 return 문이 무시되고 빈 객체가 할당</span><br><span class="line"></span><br><span class="line">function bar() &#123; return [1, 2]&#125;</span><br><span class="line">const obj2 &#x3D; new bar();</span><br><span class="line"></span><br><span class="line">console.log(obj2);&#x2F;&#x2F; [1, 2] return 문이 객체를 반환하므로 해당 객체를 반환</span><br></pre></td></tr></table></figure>



<p><strong>생성자 함수를 new 연산자 없이 호출한다면</strong></p>
<p>new 연산자 없이 생성자 함수를 호출하면 일반함수로 호출된다. 즉, 내부 메서드 [[Construct]]가 아닌 [[Call]]이 호출된다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;생성자 함수</span><br><span class="line">function Rectangle(width, height) &#123;</span><br><span class="line">    this.width &#x3D; width,</span><br><span class="line">    this.height &#x3D; height,</span><br><span class="line">    this.getArea &#x3D; function () &#123;</span><br><span class="line">        return width * height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const rect1 &#x3D; Rectangle(5,5);</span><br><span class="line"></span><br><span class="line">console.log(rect1); &#x2F;&#x2F;undefined</span><br><span class="line">&#x2F;&#x2F; 반환문이 없는 일반함수는 undefined를 반환한다.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;일반함수 내부의 this는 전역객체가 된다.</span><br><span class="line">console.log(width); 5</span><br><span class="line">console.log(getArea()) ; &#x2F;&#x2F;25</span><br><span class="line"></span><br><span class="line">console.log(rect1.getArea()); &#x2F;&#x2F;TypeError</span><br></pre></td></tr></table></figure>



<p><strong>생성자 함수의 표기</strong></p>
<p>일반함수와 생성자함수에 특별한 형식적 차이는 없다. 그렇기 때문에 의도적으로 생성자 함수를 기술할 때 파스칼케이스로 명명하여 차이를 두도록 하자</p>
<h3 id="2-7-new-target"><a href="#2-7-new-target" class="headerlink" title="2.7 new.target"></a>2.7 new.target</h3><p><strong>생성자 함수의 일반함수 호출 방지</strong></p>
<p>생성자 함수가 new 연산자 없이 호출되는 것을 방지하기 위해 파스칼 케이스 컨벤션을 사용하다 하더라도 실수는 언제나 발생할 수 있다.</p>
<p>이러한 위험성을 피하기 위해 ES6 에서는 new.target을 지원한다.</p>
<p>new.target은 this와 유사하게 constructor인 모든 함수 내부에서 암묵적인 지역 변수와 같이 사용되며 메타 프로퍼티라고 부른다. IE는 new.target 을 지원하지 않는다</p>
<p>new.target을 함수 내부에서 사용하면 해당 함수가 new 연산자와 함께 호출되었는지 확인가능하다. </p>
<ul>
<li>new 연산자와 함께 생성자 함수로서 호출된경우<ul>
<li>new.target은 함수 자신을 가리킨다</li>
</ul>
</li>
<li>new 연산자 없이 일반 함수로서 호출된 경우<ul>
<li>new.target 은 undefined 이다</li>
<li>일반함수로 호출한 경우 재귀호출로 new와 함께 호출한다.</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;생성자 함수</span><br><span class="line"></span><br><span class="line">function Book(title,author)&#123;</span><br><span class="line">    if(!new.target)&#123;</span><br><span class="line">        return new Book(title, author);</span><br><span class="line">    &#125;</span><br><span class="line">    this.title &#x3D; title;</span><br><span class="line">    this.author &#x3D; author;</span><br><span class="line">    </span><br><span class="line">    this.getInfo &#x3D; function()&#123;</span><br><span class="line">        return this.title + &#39;, &#39;+this.author;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const book1 &#x3D; Book(&#39;어린왕자&#39;, &#39;생택쥐베리&#39;);</span><br><span class="line"></span><br><span class="line">console.log(book1); &#x2F;&#x2F; &#123;title: ....&#125;</span><br></pre></td></tr></table></figure>



<p><strong>스코프 세이프 생성자 패턴(scope-safe constructor</strong></p>
<p>ES6의 문법인 new.target을 사용할 수 없을때 사용한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Book(title,author)&#123;</span><br><span class="line">    if(!this instanceof Book)&#123;</span><br><span class="line">        return new Book(title, author);</span><br><span class="line">    &#125;</span><br><span class="line">    this.title &#x3D; title;</span><br><span class="line">    this.author &#x3D; author;</span><br><span class="line">    </span><br><span class="line">    this.getInfo &#x3D; function()&#123;</span><br><span class="line">        return this.title + &#39;, &#39;+this.author;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>빌트인 생성자 함수와 new</strong></p>
<ul>
<li>Object, Function<ul>
<li>new 없이 호출하여도 new와 함께 호출한 것처럼 동작</li>
</ul>
</li>
<li>String, Number, Boolean<ul>
<li>new 없이 호출하면 문자열, 숫자, 불리언 값을 반환</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jjm2317.github.io/2020/09/23/javascript-16PropertyAttribute/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jeong Jiman">
      <meta itemprop="description" content="All Dev stories found in here.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeong Jiman's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/23/javascript-16PropertyAttribute/" class="post-title-link" itemprop="url">javascript 16PropertyAttribute</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-23 22:53:27" itemprop="dateCreated datePublished" datetime="2020-09-23T22:53:27+09:00">2020-09-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-30 13:39:16" itemprop="dateModified" datetime="2021-03-30T13:39:16+09:00">2021-03-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="프로퍼티-어트리뷰트"><a href="#프로퍼티-어트리뷰트" class="headerlink" title="프로퍼티 어트리뷰트"></a>프로퍼티 어트리뷰트</h1><h2 id="1-내부-슬롯과-내부-메서드"><a href="#1-내부-슬롯과-내부-메서드" class="headerlink" title="1. 내부 슬롯과 내부 메서드"></a>1. 내부 슬롯과 내부 메서드</h2><p><strong>자바스크립트 엔진 내부는?</strong></p>
<p>자바스크립트로 작성한 코드는 자바스크립트 엔진에 의해 해석되고 실행된다. 자바스크립트 엔진도 코드를 실행하기 위해 코딩된 하나의 프로그램이라고 할 수 있다. 자바 스크립트 엔진은 객체지향 언어 C++ 로 코딩되어 있다.  즉 엔진 내부에도 프로그램 구현을 위한 알고리즘이 있다는 이야기이다 .</p>
<p><strong>내부 슬롯, 내부 메서드란</strong></p>
<p>내부 슬롯(internal slot) 과 내부 메서드 (internal method)는 자바스크립트 엔진의 구현 알고리즘을 설명하기 위해 ECMAScript 사양에서 사용하는 의사 프로퍼티(pseudo property) 와 의사 메서드(pseudo method) 이다. ECMAScript 사양 에서는 내부슬롯과 내부 메서드를 이중 대괄호(  [[ ]] )로 해당 이름을 감싸서 표현하고 있다. </p>
<p><strong>내부 슬롯, 내부 메서드의 특징</strong></p>
<p>내부 슬롯과 내부 메서드는 ECMAScript 사양에 정의된 대로 구현되어 자바스크립트 엔진에서 실제로 동작한다. 하지만 개발자가 직접 접근할 수 있도록 외부로 공개된 객체의 프로퍼티는 아니다. </p>
<p>내부슬롯과 내부메서드는 자바스크립트 엔진의 내부 로직이므로 원칙적으로 자바스크립트는 내부슬롯과 내부메서드에 직접적으로 접근하거나 호출할 수 있는 방법을 제공하지 않는다. 괜한 문제나 어려움을 유발하지 않기 위해서이다. </p>
<p>단, 일부 내부 슬롯과 내부 메서드에 한하여 <strong>간접적으로</strong> 접근할 수 있는 수단을 제공한다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 모든 객체는 [[Prototype]] 이라는 내부슬롯을 갖는다</span><br><span class="line">&#x2F;&#x2F; 직접 접근은 불가하며 접근자 프로퍼티로 간접 접근은 가능하다.</span><br><span class="line"></span><br><span class="line">const obj &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">o.[[Prototype]]; &#x2F;&#x2F; Uncaught SyntaxError</span><br><span class="line"></span><br><span class="line">o.__proto__ &#x2F;&#x2F; Object.prototype</span><br></pre></td></tr></table></figure>





<h2 id="2-프로퍼티-어트리뷰트와-프로퍼티-디스크립터-객체"><a href="#2-프로퍼티-어트리뷰트와-프로퍼티-디스크립터-객체" class="headerlink" title="2. 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체"></a>2. 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체</h2><p><strong>프로퍼티 어트리뷰트란</strong></p>
<p>자바스크립트 엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다. </p>
<p>프로퍼티의 상태란 다음과 같다.</p>
<ul>
<li>값(value)</li>
<li>값의 갱신 가능 여부(writable)</li>
<li>열거 가능 여부(enumerable)</li>
<li>재정의 가능 여부(configurable)</li>
</ul>
<p>프로퍼티 어트리뷰트는 자바스크립트 엔진이 관리하는 내부 상태 값(meta-property)인 내부 슬롯 [[Value]], [[Writable]], [[Enumerable]], [[Configurable]]를 말한다. </p>
<p><strong>프로퍼티의 어트리뷰트에 접근하는 법</strong></p>
<p>프로퍼티 어트리뷰트 역시 직접접근은 불가하다.</p>
<p>간접적으로 접근하기 위해  Object.getOwnPropertyDiscriptor 메서드를 사용한다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const car &#x3D; &#123;</span><br><span class="line">    price: 5000</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyDiscriptor(car, &#39;price&#39;);</span><br><span class="line">&#x2F;&#x2F;&#123;value: 5000, writable: true, enumerable: true, configurable: true&#125;</span><br></pre></td></tr></table></figure>

<p>메서드를 호출할 때 첫 번째 매개변수에는 객체의 식별자, 두번째는 프로퍼티 키를 문자열로 전달한다. </p>
<p><strong>주의할 점</strong></p>
<ul>
<li>프로퍼티 키는 식별자가 아닌 문자열이다. 인수 전달에 주의해야한다. </li>
</ul>
<p><strong>반환 값</strong></p>
<p>Object.getOwnPropertyDiscriptor 메서드는 프로퍼티 어트리뷰트 정보를 프로퍼티로서 가지는 <strong>프로퍼티 디스크립터(PropertyDescriptor)객체</strong>를 반환한다.</p>
<ul>
<li>존재하지 않는 프로퍼티를 인수로 전달할 경우<ul>
<li>undefined를 반환</li>
</ul>
</li>
<li>상속받은 프로퍼티를 인수로 전달할 경우<ul>
<li>undefined 반환</li>
</ul>
</li>
</ul>
<p><strong>모든 프로퍼티의 내부 상태를 알고 싶다면</strong></p>
<p>Object.getOwnPropertyDiscriptor 메서드의 경우 하나의 프로퍼티의 디스크립터 객체를 반환한다. </p>
<p>ES8에서 도입된 Object.getOwnPRopertyDescriptors 메서드는 모든 프로퍼티의 프로퍼티 어트리뷰트 정보를 제공한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const car &#x3D; &#123;</span><br><span class="line">    price: 5000,</span><br><span class="line">    brand: &#39;Hyundai&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyDiscriptors(car);</span><br><span class="line">&#x2F;&#x2F;&#123;</span><br><span class="line">    price: &#123;value: 5000, writable: true, enumerable: true,     configurable: true&#125;,</span><br><span class="line">    brand: &#123;value: &#39;Hyundai&#39;, writable: true, enumerable: true, configurable: true&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="3-데이터-프로퍼티와-접근자-프로퍼티"><a href="#3-데이터-프로퍼티와-접근자-프로퍼티" class="headerlink" title="3. 데이터 프로퍼티와 접근자 프로퍼티"></a>3. 데이터 프로퍼티와 접근자 프로퍼티</h2><p><strong>프로퍼티의 구분</strong></p>
<p>프로퍼티는 데이터 프로퍼티와 접근자 프로퍼티로 구분할 수 있다.</p>
<ul>
<li>데이터 프로퍼티(data property)<ul>
<li>키와 값으로 구성된 일반적인 프로퍼티다. </li>
<li>지금까지 살펴본 모든 프로퍼티는 데이터 프로퍼티다.</li>
</ul>
</li>
<li>접근자 프로퍼티(accessor property)<ul>
<li>자체적으로 값을 갖지 않는다</li>
<li>다른 데이터 프로퍼티의 값을 <strong>읽거나 저장</strong>할 때 호출되는 접근자 함수(accessor function) 로 구성된 프로퍼티다.</li>
</ul>
</li>
</ul>
<h3 id="3-1-데이터-프로퍼티"><a href="#3-1-데이터-프로퍼티" class="headerlink" title="3.1 데이터 프로퍼티"></a>3.1 데이터 프로퍼티</h3><p><strong>데이터 프로퍼티의 프로퍼티 어트리뷰트</strong></p>
<p>데이터 프로퍼티(data property)는 다음과 같은 프로퍼티 어트리뷰트를 갖는다. 이 프로퍼티 어트리뷰트는 자바스크립트 엔진이 프로퍼티를 생성할 때 기본값으로 자동 정의된다. </p>
<table>
<thead>
<tr>
<th>프로퍼티 어트리뷰트</th>
<th>프로퍼티 디스크립터 객체의 프로퍼티</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>[[Value]]</td>
<td>value</td>
<td>- 프로퍼티 키를 통해 프로퍼티 값에 접근하면 반환되는 값이다. <br />- 프로퍼티 키를 통해 프로퍼티 값을 변경하면 [[Value ]]에 값을 재할당<br />- 이때 프로퍼티가 없으면 프로퍼티를 동적 생성 후 생성된 프로퍼티의 [[Value]]에 값을 저장</td>
</tr>
<tr>
<td>[[Writable]]</td>
<td>writable</td>
<td>- 프로퍼티 값의 변경 가능 여부를 나타내며 불리언 값을 갖는다<br />- [[Writable]] 의 값이 false인 경우 해당 프로퍼티의 [[Value]]의 값을 변경할 수 없는 읽기 전용 프로퍼티가 된다.</td>
</tr>
<tr>
<td>[[Enumerable]]</td>
<td>enumerable</td>
<td>- 프로퍼티의 열거 가능여부를 나타내며 불리언 값을 갖는다<br />- [[Enumerable]]의 값이 false인 경우 해당 프로퍼티는 for…in 문이나 Object.keys 메서드 등으로 열거할 수 있다</td>
</tr>
<tr>
<td>[[Configurable]]</td>
<td>configurable</td>
<td>- 프로퍼티의 재정의 가능 여부를 나타내며 불리언 값을 갖는다<br />- [[Configurable]]의 값이 false인 경우 해당 프로퍼티의 삭제, 프로퍼티 어트리뷰트 값의 변경이 금지된다. <br />- 단 [[Writable]]의 true 인경우 [[Value]] 의 변경과 [[Writable]]을 false로 변경하는 것은 허용된다.</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const car &#x3D; &#123;</span><br><span class="line">    price: 1000</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;데이터프로퍼티의 디스크립터 객체 반환</span><br><span class="line">console.log(Object.getOwnPropertyDiscriptor(car, &#39;price&#39;));</span><br><span class="line">&#x2F;&#x2F;&#123;value: 1000, writable: true, enumerable: true, configurable: true&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;프로퍼티 동적추가</span><br><span class="line">car.brand &#x3D; &#39;Hyundai&#39;;</span><br><span class="line"></span><br><span class="line">console.log(Object.getOwnPropertyDescriptors(car));</span><br><span class="line">&#x2F;&#x2F;&#123;</span><br><span class="line">  price: &#123; value: 1000, writable: true, enumerable: true, configurable: true &#125;,</span><br><span class="line">  brand: &#123;</span><br><span class="line">    value: &#39;Hyundai&#39;,</span><br><span class="line">    writable: true,</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>리터럴로 객체를 생성하는 경우,</p>
<p>프로퍼티가 생성될 때 [[Value]] 는 프로퍼티 값으로, 나머지는 true로 초기화된다. </p>
<p>프로퍼티를 동적 추가해도 마찬가지이다.</p>
<h3 id="3-2-접근자-프로퍼티"><a href="#3-2-접근자-프로퍼티" class="headerlink" title="3.2 접근자 프로퍼티"></a>3.2 접근자 프로퍼티</h3><p><strong>접근자 프로퍼티란</strong></p>
<p>접근자 프로퍼티(accessor property)는 자체적으로 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용되는 접근자 함수(accessor function) 으로 구성된 프로퍼티이다.</p>
<p><strong>접근자  프로퍼티의 프로퍼티 어트리뷰트</strong> </p>
<table>
<thead>
<tr>
<th>프로퍼티 어트리뷰트</th>
<th>프로퍼티 디스크립터 객체의 프로퍼티</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>[[Get]]</td>
<td>get</td>
<td>- 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 <strong>읽을 때</strong> 호출되는 접근자 함수이다.<br />- 접근자 프로퍼티 키로 프로퍼티 값에 접근하면 프로퍼티 어트립뷰트 [[Get]]의 값, 즉 getter 함수가 호출되고 그 결과가 프로퍼티 값으로 반환된다.</td>
</tr>
<tr>
<td>[[Set]]</td>
<td>set</td>
<td>- 접근자 프로퍼티를 통해 데이터프로퍼티의 값을 저장할 때 호출되는 접근자 함수이다.<br />- 즉, 접근자 프로퍼티 키로 프로퍼티 값을 저장하면 프로퍼티 어트리뷰트 [[Set]]의 값, setter 함수가 호출되고 그 결과가 프로퍼티 값으로 저장된다.</td>
</tr>
<tr>
<td>[[Enumerable]]</td>
<td>enumerable</td>
<td>데이터 프로퍼티와 동일</td>
</tr>
<tr>
<td>[[Configurable]]</td>
<td>configurable</td>
<td>데이터 프로퍼티와 동일</td>
</tr>
</tbody></table>
<p><strong>접근자 함수의 정의</strong></p>
<p>접근자 함수는 getter / setter 함수라고도 부른다. 접근자 프로퍼티는 getter와 setter 함수를 모두 정의할 수도 있고 하나만 정의할 수도 있다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F;데이터 프로퍼티</span><br><span class="line">    firstName: &#39;Jiman&#39;,</span><br><span class="line">    lastName: &#39;Jeong&#39;,</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;접근자 프로퍼티</span><br><span class="line">    </span><br><span class="line">    get fullName() &#123;</span><br><span class="line">        return &#96;$&#123;this.firstName&#125; $&#123;this.lastName&#125;&#96;;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    set fullName(name)&#123;</span><br><span class="line">        [this.firstName, this.lastName] &#x3D; name.split(&#39; &#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; setter 함수의 사용</span><br><span class="line">person.fullName &#x3D; &#39;Chansung Jeong&#39;;</span><br><span class="line"></span><br><span class="line">console.log(person.firstName, person.lastName);</span><br><span class="line">&#x2F;&#x2F;Chansung Jeong</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;getter 함수 사용</span><br><span class="line">console.log(person.fullName)</span><br><span class="line">Chansung Jeong</span><br></pre></td></tr></table></figure>



<p><strong>접근자 프로퍼티의 동작 원리</strong></p>
<p>내부슬롯, 메서드 관점에서, 접근자 프로퍼티 fullName으로 프로퍼티 값에 <strong>접근</strong>하면 내부적으로 [[Get]] 내부 메서드가 호출된다.</p>
<p>[[Get]] 내부 메서드의 동작</p>
<ol>
<li>프로퍼티 키가 유효한지 확인한다. 프로퍼티 키는 문자열 또는 심벌이어야 한다</li>
<li>프로토 타입 체인에서 프로퍼티를 검색한다. </li>
<li>검색된 프로퍼티가 데이터 프로퍼티인지, 접근자 프로퍼티인지 확인한다.</li>
<li>접근자 프로퍼티의 프로퍼티 어트리뷰트 [[Get]]의 값인 getter 함수를 호출하여 결과를 반환한다.  [[Get]]의 값은 해당 프로퍼티의 디스크립터 객체의 get 프로퍼티 값과 같다</li>
</ol>
<p><strong>데이터 프로퍼티와 접근자 프로퍼티를 구별하는 법</strong></p>
<ul>
<li>Object.getOwnPropertyDiscriptor 메서드가 반환한 프로퍼티 어트리뷰트 정보를 확인한다. </li>
</ul>
<h2 id="4-프로퍼티-정의"><a href="#4-프로퍼티-정의" class="headerlink" title="4. 프로퍼티 정의"></a>4. 프로퍼티 정의</h2><p><strong>프로퍼티 정의란</strong></p>
<p>프로퍼티 정의란 프로퍼티 어트리뷰트를 정의하는 것이다.</p>
<ul>
<li>새로운 프로퍼티를 추가하면서 프로퍼티 어트리뷰트를 명시적으로 정의</li>
<li>기존 프로퍼티의 프로퍼티 어트리뷰트 재정의</li>
</ul>
<p>프로퍼티를 정의함으로서 객체의 프로퍼티가 어떻게 동작해야 하는 지 명확히 정의할 수 있다. </p>
<p><strong>프로퍼티 어트리뷰트를 정의하는 법</strong></p>
<p>Object.defineProperty 메서드를 사용하면 프로퍼티의 어트리뷰트를 정의할 수 있다. 인수로는 객체의 참조와 데이터 프로퍼티의 키인 문자열, 프로퍼티 디스크립터 객체를 전달한다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;데이터 프로퍼티 정의</span><br><span class="line">Object.defineProperty(person, &#39;firstName&#39;, &#123;</span><br><span class="line">    value: &#39;Jiman&#39;,</span><br><span class="line">    writable: true,</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true</span><br><span class="line">&#125; );</span><br><span class="line">Object.defineProperty(person, &#39;lastName&#39;, &#123;</span><br><span class="line">    value: &#39;Jeong&#39;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(Object.getOwnPropertyDescriptors(person));</span><br><span class="line">&#x2F;&#x2F;&#123;</span><br><span class="line">  firstName: &#123;</span><br><span class="line">    value: &#39;Jiman&#39;,</span><br><span class="line">    writable: true,</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true</span><br><span class="line">  &#125;,</span><br><span class="line">  lastName: &#123;</span><br><span class="line">    value: &#39;Jeong&#39;,</span><br><span class="line">    writable: false,</span><br><span class="line">    enumerable: false,</span><br><span class="line">    configurable: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;누락된 디스크립터 객체의 프로퍼티는 undefined나 false로 초기화된다.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;[[Writable]], [[Enumerable]], [[Configurable]]이 false</span><br><span class="line"></span><br><span class="line">person.lastName &#x3D; &#39;hihi&#39;;&#x2F;&#x2F;무시된다. 에러는 x</span><br><span class="line">console.log(Object.keys(person));&#x2F;&#x2F;&#123;&quot;firstName&quot;&#125; 열거x</span><br><span class="line">delete person.lastName;</span><br><span class="line">&#x2F;&#x2F;Uncaught TypeError: Cannot redefine property: lastName</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;접근자 프로퍼티 정의</span><br><span class="line"></span><br><span class="line">Object.defineProperty(person,&#39;fullName&#39;, &#123;</span><br><span class="line">    get() &#123;</span><br><span class="line">        return &#96;$&#123;this.firstName&#125; $&#123;this.lastName&#125;&#96;;</span><br><span class="line">    &#125;,</span><br><span class="line">    set(name) &#123;</span><br><span class="line">        [this.firstName, this.lastName] &#x3D; name.split(&#39; &#39;);</span><br><span class="line">        </span><br><span class="line">    &#125;,</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="5-객체-변경-방지"><a href="#5-객체-변경-방지" class="headerlink" title="5. 객체 변경 방지"></a>5. 객체 변경 방지</h2><p><strong>객체는 변경 가능한 값이다</strong></p>
<p>객체는 재할당 없이 직접 변경할 수 있다. </p>
<ul>
<li>프로퍼티 추가 및 삭제</li>
<li>프로퍼티 값 갱신</li>
<li>프로퍼티 어트리뷰트 재정의</li>
</ul>
<p><strong>객체의 변경을 방지하는 방법</strong></p>
<p>자바스크립트는 객체의 변경을 방지하는 다양한 메서드를 제공한다. 메서드에 따라 그 범위가 다르다.</p>
<table>
<thead>
<tr>
<th>구분</th>
<th>메서드</th>
<th>프로퍼티 추가</th>
<th>프로퍼티 삭제</th>
<th>프로퍼티 값 읽기</th>
<th>프로퍼티 값 쓰기</th>
<th>프로퍼티 어트리뷰트 재정의</th>
</tr>
</thead>
<tbody><tr>
<td>객체 확장 금지</td>
<td>Object.preventExtensions</td>
<td>x</td>
<td>o</td>
<td>o</td>
<td>o</td>
<td>o</td>
</tr>
<tr>
<td>객체 밀봉</td>
<td>Object.seal</td>
<td>x</td>
<td>x</td>
<td>o</td>
<td>o</td>
<td>x</td>
</tr>
<tr>
<td>객체 동결</td>
<td>Object.freeze</td>
<td>x</td>
<td>x</td>
<td>o</td>
<td>x</td>
<td>x</td>
</tr>
</tbody></table>
<h3 id="5-1-객체-확장-금지"><a href="#5-1-객체-확장-금지" class="headerlink" title="5.1 객체 확장 금지"></a>5.1 객체 확장 금지</h3><p><strong>Object.preventExtensions</strong></p>
<p>Object.preventExtensions 메서드는 객체의 확장을 금지한다. 즉 프로퍼티 추가를 금지하는 것이다. </p>
<p>다음의 프로퍼티 추가 방법이 모두 금지된다.</p>
<ul>
<li>프로퍼티 동적추가</li>
<li>Object.defineProperty 를 통한 프로퍼티 추가 및 정의</li>
</ul>
<p>확장 가능여부는 Object.isExtensible 메서드로 확인 가능하다.</p>
<h3 id="5-2-객체-밀봉"><a href="#5-2-객체-밀봉" class="headerlink" title="5.2 객체 밀봉"></a>5.2 객체 밀봉</h3><p><strong>Object.seal</strong></p>
<p>Object.seal 메서드는 객체를 밀봉한다. </p>
<p>객체 밀봉(seal) 이란 다음을 금지한다.</p>
<ul>
<li>프로퍼티 추가 및 삭제</li>
<li>프로퍼티 어트리뷰트 재정의 금지</li>
</ul>
<p>기존 프로퍼티 값의 읽기, 갱신 이외에는 모두 불가하다.</p>
<p>객체의 밀봉여부는 Object.isSealed 메서드로 확인가능하다.</p>
<h3 id="5-3-객체-동결"><a href="#5-3-객체-동결" class="headerlink" title="5.3 객체 동결"></a>5.3 객체 동결</h3><p><strong>Object.freeze</strong></p>
<p>Object.freeze 메서드는 객체를 동결한다. </p>
<p>객체 동결(freeze)는 다음을 금지한다.</p>
<ul>
<li>프로퍼티 추가 및 삭제</li>
<li>프로퍼티 어트리뷰트 재정의 금지</li>
<li>프로퍼티 값 갱신</li>
</ul>
<p>즉 동결된 객체는 프로퍼티 값 읽기만 가능하다.</p>
<p>객체의 동결여부는 Object.isFrozen 메서드로 확인가능하다.</p>
<h3 id="5-4-불변-객체"><a href="#5-4-불변-객체" class="headerlink" title="5.4 불변 객체"></a>5.4 불변 객체</h3><p><strong>중첩 객체까지 동결하는 방법</strong></p>
<p>얕은 변경 방지(shallow only)가 아닌 중첩객체까지 동결된 불변객체(immutable object) 를 구현하려면,</p>
<p>객체를 값으로 갖는 모든 프로퍼티에 대해 재귀적으로 Object.freeze 메서드를 호출해야한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function deepFreeze(target) &#123;</span><br><span class="line">    if(target &amp;&amp; typeof target &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; !Object.isFrozen(target)) &#123;</span><br><span class="line">        Object.freeze(target);</span><br><span class="line">        </span><br><span class="line">        Object.keys(target).forEach(key &#x3D;&gt; Object.deepFreeze(target[key]));</span><br><span class="line">    &#125;</span><br><span class="line">    return target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jeong Jiman</p>
  <div class="site-description" itemprop="description">All Dev stories found in here.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">71</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jeong Jiman</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
