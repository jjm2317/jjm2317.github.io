<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jjm2317.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="All Dev stories found in here.">
<meta property="og:type" content="website">
<meta property="og:title" content="Jeong Jiman&#39;s blog">
<meta property="og:url" content="https://jjm2317.github.io/index.html">
<meta property="og:site_name" content="Jeong Jiman&#39;s blog">
<meta property="og:description" content="All Dev stories found in here.">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jeong Jiman">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://jjm2317.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Jeong Jiman's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jeong Jiman's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Awesome node.jser..</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jjm2317.github.io/2020/09/16/javascript-13Scope/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jeong Jiman">
      <meta itemprop="description" content="All Dev stories found in here.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeong Jiman's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/16/javascript-13Scope/" class="post-title-link" itemprop="url">javascript 13Scope</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-09-16 09:39:57 / Modified: 09:40:14" itemprop="dateCreated datePublished" datetime="2020-09-16T09:39:57+09:00">2020-09-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="스코프"><a href="#스코프" class="headerlink" title="스코프"></a>스코프</h1><h2 id="1-스코프란"><a href="#1-스코프란" class="headerlink" title="1. 스코프란?"></a>1. 스코프란?</h2><p><strong>스코프 이해의 중요성</strong></p>
<p>스코프(scope, 유효범위는) 자바스크립트를 포함한 모든 프로그래밍 언어의 기본적이고 중요한 개념이다.  자바스크립트의 스코프는 다른언어의 스코프와 구별되는 특징이 있어서 주의해야 한다.  var 키워드로 선언한 변수와 let, const로 선언한 변수의 스코프도 다르게 동작한다. 스코프는 변수, 함수와 깊은 관련이 있다. </p>
<p><strong>스코프는 식별자가 유효한 범위이다.</strong></p>
<p>우리는 스코프를 이미 경험했다. 바로 함수의 매개변수이다. 함수의 매개변수는 함수 몸체 내에서만 참조할 수 있고, 외부에서는 참조할 수 없다. 이것은 매개변수를 참조할 수 있는 유효범위, 즉 매개변수의 스코프가 함수 몸체 내부로 한정되기 때문이다. </p>
<p>매개변수의 스코프 예제</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function show(input) &#123;</span><br><span class="line">    console.log(input);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">show(&quot;hi&quot;); &#x2F;&#x2F;hi</span><br><span class="line"></span><br><span class="line">console.log(input); &#x2F;&#x2F; ReferenceError: input is not defined</span><br></pre></td></tr></table></figure>

<p>변수는 전역 뿐만 아니라 함수 몸체 내에서 선언할 수 있다. 또한 코드블록이나 함수는 중첩 가능하다.</p>
<p>스코프 별 변수 선언</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var num1 &#x3D; 1;</span><br><span class="line"></span><br><span class="line">if(1) &#123;</span><br><span class="line">    var num2 &#x3D; 2;</span><br><span class="line">    if(1) &#123;</span><br><span class="line">        var num3 &#x3D; 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    var num4 &#x3D; 4;</span><br><span class="line">    </span><br><span class="line">    function bar() &#123;</span><br><span class="line">        var num5 &#x3D; 5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(num1,num2,num3); &#x2F;&#x2F;1 2 3</span><br><span class="line">console.log(num4); &#x2F;&#x2F; ReferenceError: num4 is not defined</span><br><span class="line">console.log(num5); &#x2F;&#x2F; ReferenceError: num5 is not defined</span><br></pre></td></tr></table></figure>

<p>변수는 선언된 위치에 따라 유효한 범위(다른 코드가 변수를 참조할 수 있는 범위)가 정해진다. 변수뿐만 아니라 모든 식별자가 마찬가지이다. </p>
<p>모든 식별자는 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있있는 유효범위가 있다. 그 유효범위를 스코프라고 한다. </p>
<p><strong>스코프는 식별자를 검색할 때 사용하는 규칙이다</strong></p>
<p>다른 위치에 동일한 이름의 변수 선언 예제</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var x &#x3D; &#39;global&#39;;</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    var x &#x3D; &#39;local&#39;;</span><br><span class="line">    console.log(x); &#x2F;&#x2F; local</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line">console.log(x); &#x2F;&#x2F; global</span><br></pre></td></tr></table></figure>

<p>전역과 함수 몸체 내부에 같은 이름의 변수 x 를 선언하였다. 자바스크립트엔진은 이름같은 두개의 변수 중에서 어떤 변수를 참조 할것인지를 결정한다. 이를 식별자 결정(identifier resolution)이라고 한다. 자바스크립트 엔진은 스코프를 통해 어떤 변수를 참조할 것인지를 결정하기 때문에 스코프를 ‘식별자를 검색할 때 사용하는 규칙’ 이라고 할 수 있다.</p>
<p><strong>스코프가 다르면 별개의 변수이다.</strong></p>
<p>자바스크립트 엔진은 코드를 실행할 때 코드의 문맥을 고려한다. 즉, 코드의 위치를 고려하기 때문에 위 예제와 같이 동일한 이름의 변수 x 도 다른 결과를 만들어 낸다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">코드의 문맥(context)와 환경(environment)</span><br><span class="line">코드가 어디서 실행되며 주변에 어떤 코드가 있는지를 렉시컬 환경(lexical environment)라고 부른다. 코드의 문맥은 렉시컬 환경으로 이루어지며, 실행컨텍스트(execution context)로 구현된다. </span><br></pre></td></tr></table></figure>



<p>전역에서 선언된 변수 x 와 함수 내부에서 선언된 변수 x 는 식별자 이름이 동일하지만 스코프가 다른 별개의 변수이다. </p>
<p><strong>스코프는 네임 스페이스(이름으로 개체를 구별하는 공간)이다</strong></p>
<p>스코프라는 개념이 없다면 같은 이름을 갖는 변수는 충돌을 일으키기 띠ㅐ문에 프로그램 전체에서 하나만 사용해야된다.</p>
<p>식별자는 어떤 값을 구별하여 식별해낼 수 있는 고유한 이름을 말한다. 그렇기 때문에 유일(unique)해야 한다. 즉  중복되면 안된다는 뜻이다. 하나의 값은 유일한 식별자에 연결 (name binding)되어야 한다. </p>
<p>서로다른 스코프에서는 같은 이름의 식별자를 사용할 수 있다.</p>
<p>우리는 컴퓨터를 사용할 때 하나의 파일 이름만 사용하지 않는다. 폴더라는 개념이 존재하기 때문이다. 폴더가 있기 때문에 서로 다른 폴더에서 같은 이름의 파일을 만들 수 있다. </p>
<p><strong>var 키워드의 문제점</strong></p>
<p>var 키워드는 같은 스코프내에서 중복 선언이 허용된다.  의도치 않게 변수값이 재할당되는 부작용을 발생시킬 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var x &#x3D; 1;</span><br><span class="line">&#x2F;&#x2F;두번째 선언문은 var 키워드가 없는 것 처럼 동작한다. </span><br><span class="line">var x &#x3D; 2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(x);&#x2F;&#x2F;2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>let이나 const를 사용하자</strong></p>
<p>let, const 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용하지 않는다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let x &#x3D; 1;</span><br><span class="line">let x &#x3D; 2; &#x2F;&#x2F; SyntaxError: Identifier &#39;x&#39; has already been declared</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jjm2317.github.io/2020/09/15/javascript-12Function/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jeong Jiman">
      <meta itemprop="description" content="All Dev stories found in here.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeong Jiman's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/15/javascript-12Function/" class="post-title-link" itemprop="url">javascript 12Function</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-09-15 22:15:26 / Modified: 22:15:40" itemprop="dateCreated datePublished" datetime="2020-09-15T22:15:26+09:00">2020-09-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="함수"><a href="#함수" class="headerlink" title="함수"></a>함수</h1><h2 id="1-함수란"><a href="#1-함수란" class="headerlink" title="1. 함수란?"></a>1. 함수란?</h2><p>함수는 **입력(input) 을 받아 출력(output)**을 내보내는 일련의 과정을 정의한 것이다. </p>
<p>프로그래밍을 처음만든 과학자들 대다수가 수학자였다.</p>
<p>수학적사고를 통해서 프로그래밍을 만들었다. 그렇기 때문에 수학적 사고가 필요하다. </p>
<p><strong>프로그래밍에서의 함수는?</strong></p>
<p>프로그래밍 언어의 함수는 일련의 과정을 문(statement)로 구현하고 코드블록으로 감싸서 하나의 실행 단위로 정의한 것이다. </p>
<p>프로그래밍은 함수들의 집합이며, 우리는 함수를 만드는일을한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function sum(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>함수를 정의할때</strong></p>
<p><strong>function이라는 키워드</strong>를 쓰고 <strong>함수이름</strong>을 준다. <strong>괄호(매개변수 선언부)를 여닫고</strong>, **코드블록(함수 몸체)**을 써준다.</p>
<p>괄호를 매개변수 선언부라고한다. 매개 변수는 <strong>0개이상</strong>으로 여러개쓸 수 있다.  매개 ‘변수’는 함수 안에서 선언된 변수이다. </p>
<p><strong>매개변수란?</strong></p>
<p><strong>함수 바깥에 있는 값이</strong> 함수 안으로 들어올때 매개를 하는 것이 매개변수이다.</p>
<p>호출할때 인수로 작성하여 사용한다.</p>
<p>인수로 작성하면 매개변수에 할당된다.</p>
<p>함수 외부에 있었던 값을 함수 내부로 받아들이는 역할을 한다.</p>
<p><strong>함수는 함수정의(function definition)을 통해 생성한다.</strong> </p>
<p>함수를 정의하는 방법은 여러가지가 있다.</p>
<p>function 키워드와 함수이름, 매개변수 선언부() , 함수몸체를 작성해주는 것을 함수 선언문이라고 한다. 함수 몸체안에는 문들의 집합이 온다.</p>
<p>함수는 입력값을 받아서 출력값을 내보내기때문에 return 키워드를 통해 출력값 작성한다. </p>
<p>여기까지 함수 정의이다. 함수정의는 만드는것뿐이다. 사용하기위해선 call,호출해야한다. </p>
<p><strong>함수는 함수 호출(function call/ invoke) 를 통해 사용한다.</strong> </p>
<p>함수 호출을 하기위해서는 함수 식별자를 주고 괄호를 여닫고 괄호안에 매개변수를 통해 함수 안으로 넣어줄 값인 인수(argument)를 작성한다.</p>
<p>함수를 호출하게되면 인수가 매개변수에 할당이된다. </p>
<p>바깥에 있던 값이 안으로 들어가서 사용할 수 있다. </p>
<p>인수는 함수안에서 행해지는 일련의 과정을 위한 재료이다. </p>
<p>함수는 하나의 기계로 이해하면 편하다.</p>
<h2 id="2-함수를-사용하는-이유"><a href="#2-함수를-사용하는-이유" class="headerlink" title="2. 함수를 사용하는 이유"></a>2. 함수를 사용하는 이유</h2><ul>
<li>코드의 재사용<ul>
<li>실행 시점을 개발자가 정하고 재사용이 가능하다</li>
</ul>
</li>
<li>코드의 신뢰성을 높인다<ul>
<li>중복이 줄어드는 만큼 실수할 가능성도 줄기 때문</li>
</ul>
</li>
<li>가독성을 높인다<ul>
<li>적절한 함수 식별자 이름을 사용한다면 내부 코드를 몰라도 함수의 역할을 잘 파악할 수 있게 한다.</li>
</ul>
</li>
</ul>
<h2 id="3-함수-리터럴"><a href="#3-함수-리터럴" class="headerlink" title="3. 함수 리터럴"></a>3. 함수 리터럴</h2><p>리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기 방식(notation) 이다. 즉 표기법이다. 함수 리터럴도 평가되어 값을 생성한다. </p>
<p>자바스크립트에서 함수는 <strong>객체 타입의 값</strong>이다.</p>
<p>숫자를 숫자 리터럴로 생성하고 객체를 객체 리터럴로 생성하는 것처럼 함수도 함수 리터럴로 생성할 수 있다. </p>
<p>함수 리터럴은 다음으로 구성된다.</p>
<ul>
<li>function 키워드</li>
<li>함수 이름</li>
<li>매개변수 목록</li>
<li>함수 몸체</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const multiply &#x3D; function multiply(a, b)&#123;</span><br><span class="line">    &#x2F;&#x2F;var a;</span><br><span class="line">    &#x2F;&#x2F;var b;</span><br><span class="line">    return a * b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>함수 리터럴의 구성요소별 특징</strong></p>
<ul>
<li><strong>함수 이름</strong><ul>
<li>함수 이름은 식별자이므로 식별자 네이밍 규칙을 준수해야 한다.</li>
<li>단, 함수 몸체 내에서만 참조할 수 있는 식별자이다<ul>
<li>보통 재귀호출을 위해 사용된다</li>
</ul>
</li>
<li>함수 이름은 생략가능하다<ul>
<li>이름이 있는 함수는 기명 함수(named function)</li>
<li>이름이 없는 함수를 무명/익명 함수(anonymous function)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>매개변수 목록</strong><ul>
<li>0개 이상의 매개변수를 소괄호 () 로 감싸고 쉼표 , 로 구분</li>
<li>각 매겨변수에는 함수를 호출할때 입력한 인수(argument)가 순서대로 할당 된다. 즉 <strong>순서에 의미가 있다</strong>,</li>
<li>함수 몸체 내에서 변수와 동일하게 취급된다. <ul>
<li>식별자 네이밍 규칙을 준수해야 한다. </li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>함수 몸체<ul>
<li>함수 호출 시 실행될 문 들을 정의한 코드 블록이다.</li>
<li>함수 호출에 의해 실행된다.</li>
</ul>
</li>
</ul>
<p><strong>함수와 일반객체의 차이</strong></p>
<ul>
<li>일반 객체는 호출할 수 없지만 함수는 호출할 수 있다.</li>
<li>일반 객체에는 없는 함수 객체만의 고유한  프로퍼티를 갖는다. </li>
</ul>
<h2 id="4-함수-정의"><a href="#4-함수-정의" class="headerlink" title="4. 함수 정의"></a>4. 함수 정의</h2><p>함수 정의란 함수를 호출하기 이전에 인수를 전달받을 매개변수와 실행될 문들, 그리고 반환할 값을 지정하는 것을 말한다. 정의된 함수는 자바스크립트 엔진에 의해 평가되어 함수 객체가 된다. </p>
<p>함수를 정의하는 방법은 여러가지가 있다.</p>
<ul>
<li>함수 선언문 (function declaration / function statement)</li>
<li>함수 표현식 (function expression)</li>
<li>Function 생성자 함수(Function constructor)</li>
<li>화살표 함수 (arrow function)</li>
</ul>
<p><strong>변수 ‘선언’ 과 함수 ‘정의’는 어떤 차이가 있을까</strong></p>
<p>명확하지 않은것들을 명확하게 하는 것을 <strong>정의</strong></p>
<p><strong>선언</strong>은 이제부터 ~~할래 라는 뉘앙스</p>
<p>c언어 같은경우 선언과 정의를 명확히 구분했다.</p>
<p>(c언어에서) 변수에 값을 할당하는 것을 정의라고 한다. 값을 할당하는 순간 명확한 값을 가졌기때문이다. 선언은 없었던것을 새롭게 만드는 것이다. 선언하기전에는 메모리공간이 확보가 되어있지 않지만 선언을 하면 메모리공간이 확보된다.</p>
<p>자바스크립트에서는 변수 선언을 하면 자동으로 undefined 로 ‘정의’ 되기때문에 명확하지 않다. ECMAScript에서 정의와 선언을 구분하고 있기때문에 구함수는 정의, 변수는 선언이라고 표현하도록 하자. </p>
<h3 id="함수-선언문"><a href="#함수-선언문" class="headerlink" title="함수 선언문"></a>함수 선언문</h3><p>함수를 정의하는 방식 중 하나인 함수 선언문이다.</p>
<p>다음과 같은 특징이 있다.  </p>
<ul>
<li>표현식이 아닌 문</li>
<li>함수 호이스팅</li>
<li>함수이름 생략 불가</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;함수 선언문</span><br><span class="line">function searchWs(sentence)&#123;</span><br><span class="line">    var wsNum &#x3D; 0;</span><br><span class="line">    for(var i &#x3D; 0; i &lt; sentence.length; i ++)&#123;</span><br><span class="line">        if(sentence[i] &#x3D;&#x3D;&#x3D; &#39; &#39;)&#123;</span><br><span class="line">            wsNum ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return wsNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;함수 호출</span><br><span class="line">console.log(searchWs(&#39;my age is 23&#39;)); &#x2F;&#x2F;3</span><br></pre></td></tr></table></figure>



<p>함수 선언문은 함수 리터럴과 형태가 동일하다. 단, 함수 리터럴은 삼수 이름을 생략할 수 있으나 함수 선언문은 함수 이름을 생략할 수 없다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function (x, y) &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; SyntaxError: Function statementws require a function name</span><br></pre></td></tr></table></figure>



<ul>
<li>함수 선언문 은 표현식이 아닌 문이다. 즉, 크롬 개발자 도구의 콘솔에서 함수 선언문을 실행하면 완료 값 (completion) undefined 가 출력된다. </li>
<li>함수 선언문은 표현식이 아닌 문이기 때문에 변수에 할당할 수 없다.</li>
<li>그런데 다음 예제를 보면 함수 선언문이 변수에 할당되는 것처럼 동작한다. </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var add &#x3D; function add(x, y) &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;함수 호출</span><br><span class="line">console.log(add(1,3)); &#x2F;&#x2F; 4</span><br></pre></td></tr></table></figure>

<p>이유가 무엇일까? 위와 같이 동작하는 이유는 자바 스크립트가 문맥을 고려하기 때문이다.함수 선언문은 함수 이름을 생략할 수 없다는 점을 제외하면 함수 리터럴과 형태가 동일하다.</p>
<p> 즉 동일한 함수 표현을 문맥에 따라 두가지로 해석한다.</p>
<ul>
<li>함수 리터럴<ul>
<li>표현식인 문</li>
</ul>
</li>
<li>함수 선언문<ul>
<li>표현식이 아닌 문</li>
</ul>
</li>
</ul>
<p>비슷한 사례가 이전에도 있었다. 바로 객체 리터럴과 블록문이다. </p>
<p>{ }은 블록문일 수도 있고 객체 리터럴일 수도 있다.  즉, { }은 중의적 표현이다. 자바스크립트 엔진은 { } 을 문맥에 따라 다르게 해석한다.</p>
<p>만약 {} 이 단독으로 존재하면, 자바스크립트엔진은 { }을 블록문으로 해석한댜ㅏ. 하지만 { } 이 값으로 평가되어야하는 문맥에서는 { } 을 객체 리터럴로 해석한다. 이처럼 동일한 코드도 코드의 문맥에 따라 해석이 달라질 수 있다. </p>
<p>기명 함수 리터럴, 함수 선언문도 마찬가지로 중의적인 코드이다. 코드의 문맥에 따라 해석이 달라질 수 있다.</p>
<p>자바스크립트엔진은 기명 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석한다. 값으로 평가되어야하는 문맥( 변수 할당 등) 에 사용한다면 함수 리터럴 표현식으로 해석한다. </p>
<p>두 경우 모두 함수가 생성되는 것은 동일 하지만 내부 동작에 차이가 있다. 다음예제를 살펴보자. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;기명 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석된다.</span><br><span class="line">&#x2F;&#x2F; 함수 선언문에서는 함수 이름을 생략할 수 없다.</span><br><span class="line"></span><br><span class="line">function foo() &#123; console.log(&#39;foo&#39;);&#125;</span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 함수 리터럴을 피연산자로 사용하면 함수 선언문이 아니라 함수 리터럴 표현식으로 해석한다.</span><br><span class="line">&#x2F;&#x2F; 함수 리터럴에서는 함수 이름을 생략할 수 있다.</span><br><span class="line"></span><br><span class="line">(function bar() &#123; console.log(&#39;bar&#39;);&#125;);</span><br><span class="line">bar(); &#x2F;&#x2F;ReferenceError: bar is not defined</span><br></pre></td></tr></table></figure>

<p>위 예제에서 단독으로 사용된 함수 리터럴(foo)은 함수 선언문으로 해석된다. 하지만 그룹연산자 () 내에 있는 함수 리터럴(bar)은 함수 선언문으로 해석되지 않고 함수 리터럴 표현식으로 해석된다. 그룹연산자의 피연산자는 값으로  평가될 수 있는 표현식이어야 한다. 따라서 표현식이 아닌 문인 함수 선언문은 피연산자로 사용할 수 없다. </p>
<p>위 예제에서 함수 선언문을로 생성한 foo는 호출할 수 있으나 함수 리터럴 표현식으로 생성한 bar는 호출할 수 없다. 그이유가 무엇일까?</p>
<p>함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자이기 때문이다. </p>
<p>함수 몸체 외부에서는 함수 이름으로 함수를 참조할 수 없으므로 함수 외부에서 함수를 함수 이름으로 호출할 수 없다는 것이다. 즉, 함수를 생성하긴 했지만 생성한 함수를 가리키는 식별자가 존재하지 않는다. bar 함수를 호출 시 참조 에러가 발생하는 이유이다. </p>
<p>그런데 함수 선언문으로 정의한 foo 함수는 왜 호출이 가능하였을까?</p>
<p>foo 역시 함수 함수 이름인데 호출이 가능하려면 foo가 식별자이어야 한다. 우리가 명시 적으로 foo 라는 식별자를 생성한 적은 없다. 그러나 자바스크립트 엔진은 foo라는 식별자를 암묵적으로 생성하였다. </p>
<p>자바스크립트 엔진은 함수 선언문을 해석해 함수 객체를 생성한다. 이때 함수 이름은 함수 몸체 내에서만 유효한 식별자이다. 따라서 별도로 생성된 함수 객체를 가리리키는 식별자가 필요하다. </p>
<p>자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하과, 거기에 생성된 함수 객체를 할당한다. </p>
<p>즉 위에서 선언한 함수 foo는 내부적으로 다음과 같이 동작한다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; function foo() &#123;console.log(&#39;foo&#39;);&#125;;</span><br></pre></td></tr></table></figure>



<p>함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다. 즉, 함수 선언문으로 생성한 함수를 호출한 것은 함수 이름 foo 가 아닌, 암묵적으로 생성된 식별자 foo 이다. </p>
<p>위 의사 코드(pseudo code) 가 바로 다으에 살펴볼 함수 표현식이다. 결론적으로 자바스크립트 엔진은 함수 선언문을 함수 표현식으로 변환해 함수 객체를 생성한다고 생각할 수 있다. 단, 함수 선언문과 함수 표현식이 정확히 동일하게 동작하는 것은 아니다. </p>
<h3 id="함수-표현식"><a href="#함수-표현식" class="headerlink" title="함수 표현식"></a>함수 표현식</h3><p>함수는 객체 타입의 값이다. 함수는 값처럼 변수에 할당할 수 도있고 프로퍼티 값이 될수도 있으며, 배열의 요소가  될 수도 있다. 이러하 값의 성질을 갖는 객체를 일급 객체(first class object)라 한다. 자바스크립트의 함수는 일급 객체이다. 함수가 일급 객체라는 것은 함수를 값처럼 자유롭게 사용할 수 있다는 의미다. </p>
<p>함수는 일급 객체이므로 함수리터럴로 생성한 함수 객체를 변수에 할당할 수 있다. 이러한 정의방식을 함수 표현식(function expression) 이라고 한다. 함수 선언문으로 정의한 foo 함수를 함수 표현식으로 바꿔서 정의하면 다음과 같다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;함수 표현식</span><br><span class="line">var foo &#x3D; function ()&#123;</span><br><span class="line">    console.log(&#39;foo&#39;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo(); &#x2F;&#x2F; foo</span><br></pre></td></tr></table></figure>

<ul>
<li>함수 리터럴의 함수 이름은 생략 가능하다. 이러한 함수를 익명함수(anonymous function)이라 한다. </li>
<li>함수 리터럴은 함수 이름을 생략하는 것이 일반적이다. </li>
</ul>
<p>함수를 호출할 때는 함수 이름이 아니라 <strong>함수 객체를 가리키는 식별자</strong>를 사용해야한다.  함수 이름은 함수 몸체 내부에서만 유효한 식별자이므로, 함수 외부에서 함수 이름으로 함수를 호출할 수 없다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; function bar () &#123;</span><br><span class="line">    console.log(&#39;foo&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;함수 객체를 가리키는 식별자로 호출</span><br><span class="line">foo(); &#x2F;&#x2F; foo</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;함수 이름으로 호출하면 ReferenceError 이 발생한다. </span><br><span class="line">bar(); &#x2F;&#x2F; ReferenceError: bar is not defined</span><br></pre></td></tr></table></figure>



<p>자바스크립트 엔진은 함수 선언문의 함수 이름으로 식별자를 암묵적 생성하고 생성된 함수 객체를 할당하므로 함수 표현식과 유사하게 동작하는 것처럼 보인다. 하지만 함수 선언문과 함수 표현식이 정확히 동작하지는 않는다 </p>
<p>함수 선언문은 표현식이 아닌문이고 함수 표현식은 표현식인 문이다. </p>
<h3 id="함수-생성-시점과-함수-호이스팅"><a href="#함수-생성-시점과-함수-호이스팅" class="headerlink" title="함수 생성 시점과 함수 호이스팅"></a>함수 생성 시점과 함수 호이스팅</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;함수 참조</span><br><span class="line">console.dir(foo); &#x2F;&#x2F; f foo()</span><br><span class="line">console.dir(bar); &#x2F;&#x2F; undefined</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 함수 호출</span><br><span class="line">foo(); &#x2F;&#x2F; foo</span><br><span class="line">bar(); &#x2F;&#x2F; TypeError: bar is not a function </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;함수 선언문</span><br><span class="line">function foo () &#123;</span><br><span class="line">    console.log(&#39;foo&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;함수 표현식</span><br><span class="line">var bar &#x3D; function () &#123;</span><br><span class="line">    console.log(&#39;bar&#39;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있다.그러나 함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출할 수 없다.</p>
<p>함수 선언문으로 정의한 함수 표현식으로 정의한 함수의 생성 시점이 다르기 때문이다. </p>
<p><strong>함수 선언문은 런타임(runtime) 이전에 실행된다</strong></p>
<p>변수 선언문과 마찬가지로, 함수 선언문 역시 런타임 이전에 먼저 실행 된다. 즉, 함수 객체가 런타임이전에 생성된다는 뜻이다. 함수 선언문이 실행되면 자바스크립트 엔진은 <strong>함수 이름과 동일한 이름의 식별자를 암묵적으로 생성</strong>하고 생성된 함수 객체를 가리키게 한다.</p>
<p>코드상에서, 함수 선언문 이전에 함수를 참조하고, 호출할 수 있는 이유이다. 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 함수 호이스팅(function hoisting)이라고 한다.</p>
<p><strong>함수 호이스팅과 변수 호이스팅의 차이</strong></p>
<p>var 키워드를 사용한 변수 선언문과, 함수 선언문은 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행 되어 식별자를 생성한다는 점은 동일하다. 단 변수 호이스팅은 식별자가 암묵적으로 undefined을 할당하는 반면, 함수 선언문의 식별자는 명시한 함수객체를 생성해서 가리킨다는 점에서 차이가 있다. 그렇기 때문에 함수선언문으로 정의한 함수를 선언문 이전에 호출이 가능한 것이다. </p>
<p><strong>함수 표현식은 런타임(runtime)에 함수 객체를 만들어낸다</strong></p>
<p>함수 표현식은 변수 선언 및 할당문의 축약표현과 동일하게 동작한다. 런타임 이전에는 변수 선언만 실행이되어 undefined로 초기화 되고 함수 리터럴은 런타임에 평가되어 함수 객체를 생성한다. </p>
<p>따라서 함수 표현식은 함수 호이스팅이 아닌, 변수 호이스팅을 발생시키는 특징이 있다.  함수 표현식 이전에 함수식별자를 참조하면 함수가 아닌 undefined로 평가된다.  함수 호출 역시 불가하다. undefined를 호출하는 것과 마찬가지이므로 타입 에러가 발생한다. </p>
<p>함수 표현식으로 정의한 함수는 함수 표현식 이후에 참조, 호출하자.</p>
<h3 id="Function-생성자-함수"><a href="#Function-생성자-함수" class="headerlink" title="Function 생성자 함수"></a>Function 생성자 함수</h3><p><strong>생성자 함수(constructor function)란?</strong></p>
<p>생성자 함수는 객체를 생성하는 함수를 말한다. 객체를 생서하는 방식은 객체 리터럴 이외에도 다양한 방법이 있다. 그 중 하나가 생성자함수를 통한 객체 생성이다. </p>
<p><strong>Function 생성자 함수를 통해 함수 객체를 생성하는 방법</strong></p>
<p>Function 생성자 함수는 자바스크립트가 기본 제공하는 빌트인 함수이다.  이 Function 생성자 함수에 매개변수 목록과 함수 몸체를 문자열로 전달하고, new 연산자와 함께 호출하면 함수 객체를 생성해서 반환한다. new 연산자 없이 호출해도 결과는 동일하다. </p>
<p>Function 생성자 함수를 통한 함수 생성 예시</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var multiply &#x3D; new Function (&#39;a&#39;, &#39;b&#39;, &#39;return a*b&#39;);</span><br><span class="line"></span><br><span class="line">console.log(multiply(3,4)); &#x2F;&#x2F; 12</span><br></pre></td></tr></table></figure>

<p>Function 생성자 함수로 함수를 생성하는 것은 보통 바람직하지 않다. </p>
<p>다음과 같은 이유 때문이다.</p>
<ul>
<li>클로저(closure)를 생성하지 않는다. </li>
<li>함수 선언문이나 함수 표현식으로 생성한 함수와 다르게 움직인다. </li>
</ul>
<h3 id="화살표-함수-arrow-function"><a href="#화살표-함수-arrow-function" class="headerlink" title="화살표 함수(arrow function)"></a>화살표 함수(arrow function)</h3><p><strong>화살표 함수는 다음과 같은 특징이 있다.</strong></p>
<ul>
<li>좀 더 간략한 방법으로 함수를 생성</li>
<li>익명함수로 정의한다. </li>
<li>생성자 함수로 사용할 수 없다. </li>
<li>this 바인딩 방식이 다르다.</li>
<li>prototype 프로퍼티가 없다. </li>
<li>arguments 객체를 생성하지 않는다. </li>
</ul>
<p>화살표 함수 사용 예시</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const add &#x3D; (x, y) &#x3D;&gt; x + y;</span><br><span class="line">console.log(add ( 1,6))&#x2F;&#x2F; 7</span><br></pre></td></tr></table></figure>





<h2 id="5-함수-호출"><a href="#5-함수-호출" class="headerlink" title="5. 함수 호출"></a>5. 함수 호출</h2><p><strong>함수 호출이란?</strong></p>
<p>함수 호출은 함수를 참조해서 함수 몸체 내의 문들을 실행하는 것이다. </p>
<p>함수를 가리키는 식별자와 한쌍의 소괄호인 함수 호출 연산자로 호출한다. 함수 호출 연산자 () 내에는 0개 이상의 인수를 쉼표로 구분해서 나열한다.</p>
<p> 함수를 호출하면 현재의 실행 흐름을 중단하고 호출된 함수로 실행 흐름을 옮긴다. 이때 매개변수에 인수가 순서대로 할당되고 함수 몸체의 문들이 실행되기 시작한다. </p>
<h3 id="매개변수와-인수"><a href="#매개변수와-인수" class="headerlink" title="매개변수와 인수"></a>매개변수와 인수</h3><p><strong>매개변수와 인수의 역할</strong></p>
<p>함수를 실행하기 위해 필요한 값을 함수 외부에서 함수 내부로 전달할 필요가  있을 때 매개변수(parameter, 인자)를 통해 인수(argument)를 전달한다. 인수는 값으로 평가될 수 있는 표현식이어야 한다. 인수는 함수를 호출할 때 지정하며, 개수와 타입에 제한이 없다. </p>
<p>매개변수와 인수 사용예시</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 함수 선언문</span><br><span class="line">function divide(a, b) &#123;</span><br><span class="line">    return a &#x2F; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;함수 호출</span><br><span class="line">var result &#x3D; divide (5, 2);</span><br></pre></td></tr></table></figure>





<p><strong>매개 변수는 함수 몸체 내부에서 변수의 역할을 한다.</strong></p>
<p>매개변수는 함수를 정의할 때 선언하며 함수 몸체 내부에서 변수와 동일하게 취급된다. 즉, 함수가 호출되면 함수 몸체 내에서 암묵적으로 매개변수가 생성되고 일반 변수와 마찬가지로 undefined로 초기화 된 이후 인수를 입력한 순서대로 할당하게 된다. </p>
<p>**매개변수의 스코프는 함수 내부이다. **</p>
<p>매개 변수는 함수 몸체 내부에서만 참조할 수 있고 함수 몸체 외부에서는 참조할 수 없다. 즉 함수 내부에서만 유효하다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 함수 선언문</span><br><span class="line">function divide(a, b) &#123;</span><br><span class="line">    return a &#x2F; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;함수 호출</span><br><span class="line">var result &#x3D; divide (5, 2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;매개 변수 a, b는 전역에서 참조할 수 없다.</span><br><span class="line">console.log(a, b); &#x2F;&#x2F; ReferenceError: a is not defined </span><br></pre></td></tr></table></figure>



<p><strong>매개변수의 개수와 인수의 개수의 일치여부</strong></p>
<p>함수는 매개변수의 개수와 인수의 개수가 일치하는지 체크하지 않는다. 일반적으로, 함수를 호출할때 매개변수의 개수만큼 인수를 전달하지만, 만약 개수가 일치하지 않더라도 에러가 발생하지 않는다. </p>
<p><strong>인수가 매개변수의 개수보다 부족한 경우</strong>, 인수가 할당되지 않은 매개변수의 값은 undefined 이다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 함수 선언문</span><br><span class="line">function divide(a, b) &#123;</span><br><span class="line">    &#x2F;&#x2F; var a;</span><br><span class="line">    &#x2F;&#x2F; var b;</span><br><span class="line">    return a &#x2F; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;인수가 할당되지 않은 매개변수의 값은 undefined 이다.</span><br><span class="line">console.log(divide(5)); &#x2F;&#x2F; NaN b에 undefined 가 할당되었다. </span><br></pre></td></tr></table></figure>

<p>위에서 매개변수 a에는 인수 5가 전달되지만, b 에는 전달할 인수가 없으므로 매개 변수 undefined로 초기화된 상태이다. undefined로 산술을 할 수 없으므로 NaN이 출력된다. </p>
<p><strong>매개변수보다 인수가 더 많은 경우,</strong> 초과된 인수는 무시된다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 함수 선언문</span><br><span class="line">function divide(a, b) &#123;</span><br><span class="line">    return a &#x2F; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 초과된 인수 4는 무시된다.</span><br><span class="line">console.log(divide(5, 2, 4)); &#x2F;&#x2F;2.5</span><br></pre></td></tr></table></figure>

<p>초과된 인수는 그냥 버려지는 것은 아니다. 모든 인수는 arguments 객체의 프로퍼티로 보관된다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 함수 선언문</span><br><span class="line">function divide(a, b) &#123;</span><br><span class="line">    console.log(arguments); &#x2F;&#x2F; [Arguments] &#123; &#39;0&#39;: 5, &#39;1&#39;: 2, &#39;2&#39;: 4 &#125; </span><br><span class="line">    return a &#x2F; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(divide(5, 2, 4));</span><br></pre></td></tr></table></figure>

<p>arguments 객체는 함수를 정의할 때, 매개변수 개수를 확정할 수 없는 가변 인자 함수를 구현할 때 유용하게 사용된다.</p>
<h3 id="인수-확인"><a href="#인수-확인" class="headerlink" title="인수 확인"></a>인수 확인</h3><p><strong>적절한 인수 전달의 필요성</strong></p>
<p>다음예제를 살펴보자.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function sum(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 함수를 정의한 개발자의 의도는 2개의 숫자 타입 인수를 전달받아 덧셈의 결과를 반환하려는 것이다. </p>
<p>하지만, 불분명한 점이 있다.</p>
<ul>
<li>어떤 타입의 인수를 전달해야하는지</li>
<li>어떤 타입의 값을 반환해야하는지</li>
</ul>
<p>따라서 다음과 같은 문제가 발생할 수 있다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function sum(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(sum(4)); &#x2F;&#x2F; NaN</span><br><span class="line">console.log(sum(&#39;x&#39;, &#39;y&#39;)); &#x2F;&#x2F; &#39;xy&#39;</span><br></pre></td></tr></table></figure>

<p>위 코드는 문법상 아무 문제가 없다. 하지만 개발자의 의도와는 다르다. </p>
<p>이런 상황이 발생한 이유는 다음과 같다. </p>
<ul>
<li>자바스크립트는 매개변수와 인수의 개수가 일치하는지 확인하지 않는다</li>
<li>자바스크립트는 동적 타입언어이므로 사전에 매개변수 타입을 지정할수없다.</li>
</ul>
<p>우리는 함수를 정의할 때 적절한 인수가 전달되었는지 추가적인 코드로 확인해야 한다.</p>
<p><strong>인수의 타입이 부적절한 경우</strong></p>
<p>매개변수를 통해 전달된 인수의 타입이 부적절한 경우 다음과 같은 방법으로 에러를 발생시킬 수 있다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function sum(a, b) &#123;</span><br><span class="line">    if ( typeof a !&#x3D;&#x3D; &#39;number&#39; || typeof b !&#x3D;&#x3D; &#39;number&#39;)&#123;</span><br><span class="line">        throw new TypeError(&#39;인수는 모두 숫자 값이어야 한다.&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(sum(4)); &#x2F;&#x2F; TypeError: 인수는 모두 숫자 값이어야 한다.</span><br><span class="line">console.log(sum(&#39;x&#39;, &#39;y&#39;)); &#x2F;&#x2F; TypeError: 인수는 모두 숫자 값이어야 한다.</span><br></pre></td></tr></table></figure>

<p>위와 같이 에러를 통해 잘못된 호출을 방지 할 수 있지만, 사전에 방지할 수 없고 에러가 런타임에 발생한다. 따라서 타입 스크립트(정적 타입을 선언할 수 있는 자바스크립트의 상위 확장)를 도입하여 컴파일 시점에 부적절한 호출을 방지할 수도 있다. </p>
<p><strong>인수의 개수를 확인하는 법</strong></p>
<p>앞의 예제는 타입을 확인하지만 인수의 개수는 확인하지 않는다. 인수의 개수를 확인하는 법은 다음과같다. </p>
<ul>
<li>arguments 객체를 통해 인수 개수를 확인할 수 있다.</li>
<li>인수가 전달되지 않은 경우 단축 평가를 사용해 매개변수에 기본값을 할당할 수 있다. </li>
<li>ES6의 매개변수 기본값을 사용할 수 있다. </li>
</ul>
<p>단축 평가를 사용해 매개변수에 기본값을 할당해보자</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function sum(a, b, c) &#123;</span><br><span class="line">    a &#x3D; a || 0;</span><br><span class="line">    b &#x3D; b || 0;</span><br><span class="line">    c &#x3D; c || 0;</span><br><span class="line">    return a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(sum(1, 2, 3)); &#x2F;&#x2F; 6</span><br><span class="line">console.log(sum(1, 2)); &#x2F;&#x2F; 3</span><br><span class="line">console.log(sum(1)); &#x2F;&#x2F; 1</span><br><span class="line">console.log(sum); &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure>



<p>ES6의 매개변수 기본값을 사용해보자. 인수 체크 및 초기화를 간소화할 수 있다. 단, 인수가 부족하게 전달된 경우 즉  인수를 전달하지 않을경우, undefined를 전달한 경우에만 유효하다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function sum(a &#x3D; 0, b &#x3D; 0, c &#x3D; 0) &#123;</span><br><span class="line">    return a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(sum(1, 2, 3)); &#x2F;&#x2F; 6</span><br><span class="line">console.log(sum(1, 2)); &#x2F;&#x2F; 3</span><br><span class="line">console.log(sum(1)); &#x2F;&#x2F; 1</span><br><span class="line">console.log(sum); &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure>





<h3 id="매개변수의-최대-개수"><a href="#매개변수의-최대-개수" class="headerlink" title="매개변수의 최대 개수"></a>매개변수의 최대 개수</h3><p><strong>매개 변수의 개수는 적을 수록 좋다.</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jjm2317.github.io/2020/09/10/0831-0904-TIL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jeong Jiman">
      <meta itemprop="description" content="All Dev stories found in here.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeong Jiman's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/10/0831-0904-TIL/" class="post-title-link" itemprop="url">0831-0904 TIL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-09-10 22:44:07 / Modified: 22:47:30" itemprop="dateCreated datePublished" datetime="2020-09-10T22:44:07+09:00">2020-09-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="0831-0904-TIL"><a href="#0831-0904-TIL" class="headerlink" title="0831-0904 TIL"></a>0831-0904 TIL</h1><h2 id="한-일들"><a href="#한-일들" class="headerlink" title="한 일들"></a>한 일들</h2><ul>
<li>자바스크립트 공부<ul>
<li>poiemaweb 원시값과 객체 ~ 프로토타입</li>
</ul>
</li>
<li>블로그 포스팅 (원시값과 객체)</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jjm2317.github.io/2020/09/07/javascript-control-flow-exercise/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jeong Jiman">
      <meta itemprop="description" content="All Dev stories found in here.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeong Jiman's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/07/javascript-control-flow-exercise/" class="post-title-link" itemprop="url">javascript control-flow-exercise</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-09-07 18:38:56 / Modified: 18:43:59" itemprop="dateCreated datePublished" datetime="2020-09-07T18:38:56+09:00">2020-09-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Exercise-삼항-조건-연산자-제어문"><a href="#Exercise-삼항-조건-연산자-제어문" class="headerlink" title="Exercise (삼항 조건 연산자 , 제어문)"></a>Exercise (삼항 조건 연산자 , 제어문)</h1><h2 id="과제-1"><a href="#과제-1" class="headerlink" title="과제 1"></a>과제 1</h2><p>아래 코드를 삼항 조건 연산자로 변경</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var x &#x3D; 11;</span><br><span class="line">var res;</span><br><span class="line">if (x &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">  res &#x3D; &#39;영&#39;;</span><br><span class="line">&#125; else if (x % 2 &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">  res &#x3D; &#39;짝수&#39;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  res &#x3D; &#39;홀수&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Answer</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var x &#x3D; 11;</span><br><span class="line">var res &#x3D; x % 2 &#x3D;&#x3D;&#x3D; 0 ? (x &#x3D;&#x3D;&#x3D; 0  ? &#39;영&#39; : &#39;짝수&#39;) : &#39;홀수&#39;;</span><br></pre></td></tr></table></figure>



<h2 id="과제-2"><a href="#과제-2" class="headerlink" title="과제 2"></a>과제 2</h2><p>제어문 연습문제 풀이</p>
<h3 id="1-변수-x가-10보다-크고-20보다-작을-때-변수-x를-출력하는-조건식을-완성하라"><a href="#1-변수-x가-10보다-크고-20보다-작을-때-변수-x를-출력하는-조건식을-완성하라" class="headerlink" title="1. 변수 x가 10보다 크고 20보다 작을 때 변수 x를 출력하는 조건식을 완성하라"></a>1. 변수 x가 10보다 크고 20보다 작을 때 변수 x를 출력하는 조건식을 완성하라</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var x &#x3D; 15;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 변수 x가 10보다 크고 20보다 작을 때 변수 x를 출력하는 조건식을 완성하라.</span><br><span class="line">if (...) &#123;</span><br><span class="line">  console.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Answer</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var x &#x3D; 15;</span><br><span class="line"></span><br><span class="line">if (x &gt; 10 &amp;&amp; x &lt; 20) &#123;</span><br><span class="line">  console.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-for문을-사용하여-0부터-10미만의-정수-중에서-짝수만을-작은-수부터-출력하시오"><a href="#2-for문을-사용하여-0부터-10미만의-정수-중에서-짝수만을-작은-수부터-출력하시오" class="headerlink" title="2. for문을 사용하여 0부터 10미만의 정수 중에서 짝수만을 작은 수부터 출력하시오."></a>2. for문을 사용하여 0부터 10미만의 정수 중에서 짝수만을 작은 수부터 출력하시오.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">8</span><br></pre></td></tr></table></figure>



<p><strong>Answer</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(var number &#x3D; 0; number &lt; 10; number++)&#123;</span><br><span class="line">    if(number % 2 &#x3D;&#x3D;&#x3D; 0)&#123;</span><br><span class="line">        console.log(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-for문을-사용하여-0부터-10미만의-정수-중에서-짝수만을-작은-수부터-문자열로-출력하시오"><a href="#3-for문을-사용하여-0부터-10미만의-정수-중에서-짝수만을-작은-수부터-문자열로-출력하시오" class="headerlink" title="3. for문을 사용하여 0부터 10미만의 정수 중에서 짝수만을 작은 수부터 문자열로 출력하시오."></a>3. for문을 사용하여 0부터 10미만의 정수 중에서 짝수만을 작은 수부터 문자열로 출력하시오.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">02468</span><br></pre></td></tr></table></figure>



<p><strong>Answer</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var result&#x3D;&#39;&#39;;</span><br><span class="line"></span><br><span class="line">for(num &#x3D; 0; num &lt; 10; num++)&#123;</span><br><span class="line">    if(num % 2 &#x3D;&#x3D;&#x3D; 0)&#123;</span><br><span class="line">        result +&#x3D; num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure>



<h3 id="4-for문을-사용하여-0부터-10미만의-정수-중에서-홀수만을-큰수부터-출력하시오"><a href="#4-for문을-사용하여-0부터-10미만의-정수-중에서-홀수만을-큰수부터-출력하시오" class="headerlink" title="4. for문을 사용하여 0부터 10미만의 정수 중에서 홀수만을 큰수부터 출력하시오."></a>4. for문을 사용하여 0부터 10미만의 정수 중에서 홀수만을 큰수부터 출력하시오.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">7</span><br><span class="line">5</span><br><span class="line">3</span><br><span class="line">1</span><br></pre></td></tr></table></figure>



<p><strong>Answer</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(var num &#x3D; 9; num &gt;&#x3D; 0; num--)&#123;</span><br><span class="line">    if(num % 2 &#x3D;&#x3D;&#x3D; 1)&#123;</span><br><span class="line">        console.log(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-while문을-사용하여-0-부터-10-미만의-정수-중에서-짝수만을-작은-수부터-출력하시오"><a href="#5-while문을-사용하여-0-부터-10-미만의-정수-중에서-짝수만을-작은-수부터-출력하시오" class="headerlink" title="5. while문을 사용하여 0 부터 10 미만의 정수 중에서 짝수만을 작은 수부터 출력하시오."></a>5. while문을 사용하여 0 부터 10 미만의 정수 중에서 짝수만을 작은 수부터 출력하시오.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">8</span><br></pre></td></tr></table></figure>



<p><strong>Answer</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var num &#x3D; 0;</span><br><span class="line">while(num&lt;10)&#123;</span><br><span class="line">    if(num % 2 &#x3D;&#x3D;&#x3D;0)&#123;</span><br><span class="line">        console.log(num)</span><br><span class="line">    &#125;</span><br><span class="line">    num ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-while문을-사용하여-0-부터-10-미만의-정수-중에서-홀수만을-큰수부터-출력하시오"><a href="#6-while문을-사용하여-0-부터-10-미만의-정수-중에서-홀수만을-큰수부터-출력하시오" class="headerlink" title="6. while문을 사용하여 0 부터 10 미만의 정수 중에서 홀수만을 큰수부터 출력하시오."></a>6. while문을 사용하여 0 부터 10 미만의 정수 중에서 홀수만을 큰수부터 출력하시오.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">7</span><br><span class="line">5</span><br><span class="line">3</span><br><span class="line">1</span><br></pre></td></tr></table></figure>



<p><strong>Answer</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var num &#x3D; 9;</span><br><span class="line">while(num &gt;&#x3D; 0)&#123;</span><br><span class="line">    if(num % 2 &#x3D;&#x3D;&#x3D;1)&#123;</span><br><span class="line">        console.log(num)</span><br><span class="line">    &#125;</span><br><span class="line">    num --;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-for-문을-사용하여-0부터-10미만의-정수의-합을-출력하시오"><a href="#7-for-문을-사용하여-0부터-10미만의-정수의-합을-출력하시오" class="headerlink" title="7. for 문을 사용하여 0부터 10미만의 정수의 합을 출력하시오."></a>7. for 문을 사용하여 0부터 10미만의 정수의 합을 출력하시오.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">45</span><br></pre></td></tr></table></figure>



<p><strong>Answer</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var sum &#x3D; 0;</span><br><span class="line"></span><br><span class="line">for(num &#x3D; 0; num &lt; 10; num ++)&#123;</span><br><span class="line">    sum +&#x3D; num;</span><br><span class="line">&#125;</span><br><span class="line">console.log(sum);</span><br></pre></td></tr></table></figure>



<h3 id="8-1부터-20-미만의-정수-중에서-2-또는-3의-배수가-아닌-수의-총합을-구하시오"><a href="#8-1부터-20-미만의-정수-중에서-2-또는-3의-배수가-아닌-수의-총합을-구하시오" class="headerlink" title="8.  1부터 20 미만의 정수 중에서 2 또는 3의 배수가 아닌 수의 총합을 구하시오."></a>8.  1부터 20 미만의 정수 중에서 2 또는 3의 배수가 아닌 수의 총합을 구하시오.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">73</span><br></pre></td></tr></table></figure>



<p><strong>Answer</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var sum &#x3D; 0;</span><br><span class="line"></span><br><span class="line">for(num &#x3D; 1; num &lt; 20; num ++)&#123;</span><br><span class="line">    sum +&#x3D; (num % 2 &#x3D;&#x3D;&#x3D; 0 || num % 3 &#x3D;&#x3D;&#x3D; 0) ? 0 : num; </span><br><span class="line">&#125;</span><br><span class="line">console.log(sum);</span><br></pre></td></tr></table></figure>



<h3 id="9-1부터-20-미만의-정수-중에서-2-또는-3의-배수인-수의-총합을-구하시오"><a href="#9-1부터-20-미만의-정수-중에서-2-또는-3의-배수인-수의-총합을-구하시오" class="headerlink" title="9. 1부터 20 미만의 정수 중에서 2 또는 3의 배수인 수의 총합을 구하시오."></a>9. 1부터 20 미만의 정수 중에서 2 또는 3의 배수인 수의 총합을 구하시오.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">117</span><br></pre></td></tr></table></figure>



<p><strong>Answer</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var sum &#x3D; 0;</span><br><span class="line"></span><br><span class="line">for(num &#x3D; 1; num &lt; 20; num ++)&#123;</span><br><span class="line">    sum +&#x3D; (num % 2 &#x3D;&#x3D;&#x3D; 0 || num % 3 &#x3D;&#x3D;&#x3D; 0) ? num : 0; </span><br><span class="line">&#125;</span><br><span class="line">console.log(sum);</span><br></pre></td></tr></table></figure>



<h3 id="10-두-개의-주사위를-던졌을-때-눈의-합이-6이-되는-모든-경우의-수를-출력하시오"><a href="#10-두-개의-주사위를-던졌을-때-눈의-합이-6이-되는-모든-경우의-수를-출력하시오" class="headerlink" title="10. 두 개의 주사위를 던졌을 때, 눈의 합이 6이 되는 모든 경우의 수를 출력하시오."></a>10. 두 개의 주사위를 던졌을 때, 눈의 합이 6이 되는 모든 경우의 수를 출력하시오.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[ 1, 5 ]</span><br><span class="line">[ 2, 4 ]</span><br><span class="line">[ 3, 3 ]</span><br><span class="line">[ 4, 2 ]</span><br><span class="line">[ 5, 1 ]</span><br></pre></td></tr></table></figure>



<p><strong>Answer</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(var num1 &#x3D; 1; num1 &lt;&#x3D; 6; num1 ++)&#123;</span><br><span class="line">    for(var num2 &#x3D; 1; num2 &lt;&#x3D; 6; num2 ++)&#123;</span><br><span class="line">        if(num1 + num2 &#x3D;&#x3D;&#x3D; 6)&#123;</span><br><span class="line">            console.log(&#96;[ $&#123;num1&#125;, $&#123;num2&#125; ]&#96;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="11-삼각형-출력하기-pattern-1"><a href="#11-삼각형-출력하기-pattern-1" class="headerlink" title="11. 삼각형 출력하기 - pattern 1"></a>11. 삼각형 출력하기 - pattern 1</h3><p>다음을 참고하여 *(별)로 높이가 5인(var line = 5) 삼각형을 문자열로 완성하라. 개행문자(‘\n’)를 사용하여 개행한다. 완성된 문자열의 마지막은 개행문자(‘\n’)로 끝나도 관계없다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 높이(line)가 5</span><br><span class="line">*</span><br><span class="line">**</span><br><span class="line">***</span><br><span class="line">****</span><br><span class="line">*****</span><br></pre></td></tr></table></figure>



<p><strong>Answer</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var line &#x3D; 5;</span><br><span class="line">var star &#x3D; &#39;&#39;;</span><br><span class="line">var tri &#x3D; &#39;&#39;;</span><br><span class="line">for(var i &#x3D; 0; i &lt; line; i++)&#123;</span><br><span class="line">    star +&#x3D; &#39;*&#39;;</span><br><span class="line">    tri +&#x3D; star + &#39;\n&#39;;</span><br><span class="line">&#125;</span><br><span class="line">console.log(tri);</span><br></pre></td></tr></table></figure>



<h3 id="12-삼각형-출력하기-pattern-2"><a href="#12-삼각형-출력하기-pattern-2" class="headerlink" title="12. 삼각형 출력하기 - pattern 2"></a>12. 삼각형 출력하기 - pattern 2</h3><p>다음을 참고하여 *(별)로 트리를 문자열로 완성하라. 개행문자(‘\n’)를 사용하여 개행한다. 완성된 문자열의 마지막은 개행문자(‘\n’)로 끝나도 관계없다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*****</span><br><span class="line"> ****</span><br><span class="line">  ***</span><br><span class="line">   **</span><br><span class="line">    *</span><br></pre></td></tr></table></figure>



<p><strong>Answer</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var line &#x3D; 5;</span><br><span class="line">var tri &#x3D; &#39;&#39;;</span><br><span class="line">for(var i &#x3D; 0; i &lt; line; i++)&#123;</span><br><span class="line">    for(var j &#x3D; 0; j &lt; i; j ++)&#123;</span><br><span class="line">        tri +&#x3D; &#39; &#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    for(var k &#x3D; 0; k &lt; line - i; k ++)&#123;</span><br><span class="line">        tri +&#x3D; &#39;*&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    tri +&#x3D; &#39;\n&#39;;</span><br><span class="line">&#125;</span><br><span class="line">console.log(tri);</span><br></pre></td></tr></table></figure>



<h3 id="13-삼각형-출력하기-pattern-3"><a href="#13-삼각형-출력하기-pattern-3" class="headerlink" title="13. 삼각형 출력하기 - pattern 3"></a>13. 삼각형 출력하기 - pattern 3</h3><p>다음을 참고하여 *(별)로 트리를 문자열로 완성하라. 개행문자(‘\n’)를 사용하여 개행한다. 완성된 문자열의 마지막은 개행문자(‘\n’)로 끝나도 관계없다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*****</span><br><span class="line">****</span><br><span class="line">***</span><br><span class="line">**</span><br><span class="line">*</span><br></pre></td></tr></table></figure>



<p><strong>Answer</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var line &#x3D; 5;</span><br><span class="line">var tri &#x3D; &#39;&#39;;</span><br><span class="line">for(var i &#x3D; 0; i &lt; line; i++)&#123;</span><br><span class="line">    for(var k &#x3D; 0; k &lt; line - i; k ++)&#123;</span><br><span class="line">        tri +&#x3D; &#39;*&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    for(var j &#x3D; 0; j &lt; i; j ++)&#123;</span><br><span class="line">        tri +&#x3D; &#39; &#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    tri +&#x3D; &#39;\n&#39;;</span><br><span class="line">&#125;</span><br><span class="line">console.log(tri);</span><br></pre></td></tr></table></figure>



<h3 id="14-삼각형-출력하기-pattern-4"><a href="#14-삼각형-출력하기-pattern-4" class="headerlink" title="14. 삼각형 출력하기 - pattern 4"></a>14. 삼각형 출력하기 - pattern 4</h3><p>다음을 참고하여 *(별)로 트리를 문자열로 완성하라. 개행문자(‘\n’)를 사용하여 개행한다. 완성된 문자열의 마지막은 개행문자(‘\n’)로 끝나도 관계없다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    *</span><br><span class="line">   **</span><br><span class="line">  ***</span><br><span class="line"> ****</span><br><span class="line">*****</span><br></pre></td></tr></table></figure>



<p><strong>Answer</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var line &#x3D; 5;</span><br><span class="line">var tri &#x3D; &#39;&#39;;</span><br><span class="line">for(var i &#x3D; 1; i &lt;&#x3D; line; i++)&#123;</span><br><span class="line">    for(var j &#x3D; 0; j &lt; line - i; j ++)&#123;</span><br><span class="line">        tri +&#x3D; &#39; &#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    for(var k &#x3D; 0; k &lt; i; k ++)&#123;</span><br><span class="line">        tri +&#x3D; &#39;*&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    tri +&#x3D; &#39;\n&#39;;</span><br><span class="line">&#125;</span><br><span class="line">console.log(tri);</span><br></pre></td></tr></table></figure>



<h3 id="15-정삼각형-출력하기"><a href="#15-정삼각형-출력하기" class="headerlink" title="15. 정삼각형 출력하기"></a>15. 정삼각형 출력하기</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    *</span><br><span class="line">   ***</span><br><span class="line">  *****</span><br><span class="line"> *******</span><br><span class="line">*********</span><br></pre></td></tr></table></figure>



<p><strong>Answer</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var line &#x3D; 5;</span><br><span class="line">var tri &#x3D; &#39;&#39;;</span><br><span class="line">for(var i &#x3D; 1; i &lt;&#x3D; line; i++)&#123;</span><br><span class="line">    for(var j &#x3D; 0; j &lt; line - i; j ++)&#123;</span><br><span class="line">        tri +&#x3D; &#39; &#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    for(var k &#x3D; 0; k &lt; i * 2 - 1; k ++)&#123;</span><br><span class="line">        tri +&#x3D; &#39;*&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    tri +&#x3D; &#39;\n&#39;;</span><br><span class="line">&#125;</span><br><span class="line">console.log(tri);</span><br></pre></td></tr></table></figure>



<h3 id="16-역정삼각형-출력하기"><a href="#16-역정삼각형-출력하기" class="headerlink" title="16. 역정삼각형 출력하기"></a>16. 역정삼각형 출력하기</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*********</span><br><span class="line"> *******</span><br><span class="line">  *****</span><br><span class="line">   ***</span><br><span class="line">    *</span><br></pre></td></tr></table></figure>



<p><strong>Answer</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var line &#x3D; 5;</span><br><span class="line">var tri &#x3D; &#39;&#39;;</span><br><span class="line">for(var i &#x3D; 1; i &lt;&#x3D; line; i++)&#123;</span><br><span class="line">    for(var j &#x3D; 0; j &lt; i - 1; j ++)&#123;</span><br><span class="line">        tri +&#x3D; &#39; &#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    for(var k &#x3D; 0; k &lt; (line - i) * 2 + 1; k ++)&#123;</span><br><span class="line">        tri +&#x3D; &#39;*&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    tri +&#x3D; &#39;\n&#39;;</span><br><span class="line">&#125;</span><br><span class="line">console.log(tri);</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jjm2317.github.io/2020/09/01/0824-0828-TIL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jeong Jiman">
      <meta itemprop="description" content="All Dev stories found in here.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeong Jiman's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/01/0824-0828-TIL/" class="post-title-link" itemprop="url">0824~0828 TIL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-09-01 23:06:38 / Modified: 23:10:53" itemprop="dateCreated datePublished" datetime="2020-09-01T23:06:38+09:00">2020-09-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="0824-0828-TIL"><a href="#0824-0828-TIL" class="headerlink" title="0824~0828 TIL"></a>0824~0828 TIL</h1><h2 id="한-일들"><a href="#한-일들" class="headerlink" title="한 일들"></a>한 일들</h2><ul>
<li>자바스크립트 변수, 데이터 타입, 표현식 등등 기본 개념 이해</li>
<li>공부한 내용 정리하여 블로그 작성</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jjm2317.github.io/2020/09/01/javascript-11primitiveValue-vs-objectValue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jeong Jiman">
      <meta itemprop="description" content="All Dev stories found in here.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeong Jiman's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/01/javascript-11primitiveValue-vs-objectValue/" class="post-title-link" itemprop="url">javascript 11primitiveValue vs objectValue</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-01 22:08:08" itemprop="dateCreated datePublished" datetime="2020-09-01T22:08:08+09:00">2020-09-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-02 12:05:48" itemprop="dateModified" datetime="2020-09-02T12:05:48+09:00">2020-09-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="원시값과-객체의-비교"><a href="#원시값과-객체의-비교" class="headerlink" title="원시값과 객체의 비교"></a>원시값과 객체의 비교</h1><p>자바스크립트에는 7가지 데이터 타입이 있었다. 그리고 그 데이터 타입은 <strong>원시타입(primitive type)</strong> 과 <strong>객체타입(object/reference type)</strong> 으로 분류되었다.</p>
<ul>
<li>원시 타입<ul>
<li>number</li>
<li>string</li>
<li>boolean</li>
<li>undefined</li>
<li>null</li>
<li>symbol</li>
</ul>
</li>
<li>객체 타입<ul>
<li>함수, 객체 등등</li>
</ul>
</li>
</ul>
<p>원시 타입에서도 number, string 등 데이터 타입을 나누어 놓은 이유가 존재하였다. 자세한 내용은 데이터타입 포스팅에서 다루었다. </p>
<p>원시타입과 객체 타입을 나누어 놓은 이유는 무엇일까? 두 타입의 차이점을 먼저 짚어보자. 크게 3가지 측면에서 차이가 있다. </p>
<ul>
<li>원시 타입의 값, 즉 원시값은 변경 불가능한 값(immutable value)이다. 객체는 변경 가능한 값(mutable value)이다. <ul>
<li>변수에 저장된 값을 변경하고자할때, 원시값은 변경불가하기때문에 재할당에 의해 변경해야되지만, 객체는 재할당없이 값을 변경 가능하다.</li>
</ul>
</li>
<li>원시값을 변수에 할당하면 변수에 실제값이 저장된다. 이에 비해 객체를 변수에 할당하면 변수에는 참조값이 저장이된다. <ul>
<li>참조값은 객체 값을 저장한 메모리 주소를 가리킨다.</li>
</ul>
</li>
<li>원시값을 갖는 변수를 다른 변수에 할당하면 원본의 <strong>원시값이</strong> <strong>복사</strong>되어 전달된다.이를 값에 의한 전달 (pass by value) 라고 한다.  객체를 가리키는 변수를 다른 변수에 할당하면 원본의 <strong>참조값이 복사</strong>되어 전달된다. 이를 참조에 의한 전달(pass by reference) 이라고 한다.  </li>
</ul>
<p>즉 변경 가능성, 저장값, 전달 방식에서 차이가 있다.</p>
<p> 이 관점에서 원시 값과 객체를 분석해보자</p>
<h2 id="1-원시값"><a href="#1-원시값" class="headerlink" title="1. 원시값"></a>1. 원시값</h2><h3 id="1-1-원시값은-변경-불가능한-값이다"><a href="#1-1-원시값은-변경-불가능한-값이다" class="headerlink" title="1.1 원시값은 변경 불가능한 값이다."></a>1.1 원시값은 변경 불가능한 값이다.</h3><p>원시타입(primitive type)의 값, 원시값은 변경 불가능한 값 (immutable value) 이다. </p>
<p>한번 생성된 원시 값은 읽기 전용(read only) 값으로서 변경할 수 없다.</p>
<p><code>값을 변경할 수 없다?</code></p>
<p>값은 표현식이 평가되어 생성된 결과로 메모리에 저장되어 있다. 메모리에 저장된 값은 변경 불가능하다는 뜻이다. </p>
<p>헷갈릴 수 있는 개념에 대해 짚고 넘어가보자. 변수와 값은 구분해서 생각해야하낟. </p>
<ul>
<li>변수 : 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름</li>
<li>값 : 변수에 저장된 데이터로서 표현식이 평가되어 생성된 결과</li>
</ul>
<p>변경 불가 하다는 것은 변수가 아니라 값에 대한 진술이다.</p>
<p>원시값은 변경 불가능하다는 말은 <strong>원시값 자체를 변경할 수 없다</strong>는 것이지 변수 값을 변경할 수 없다는 것이 아니다. </p>
<p>다만, <strong>변수의 값이 변경</strong>되는 것은 원시값 자체의 변화가 아닌, 재할당을 통해 <strong>새로 생성된 원시값을 변수에 할당</strong>하는 것이다. 즉 엄밀히 말해서는 변수의 값이 교체되는 것이다.  </p>
<p>그렇다면 변수의 상대개념인 상수는 어떨까?</p>
<p>상수는 <strong>재할당이 금지된 변수</strong>이다. 상수도 값을 저장하기 위한 메모리 공간이 필요하므로 변수라고 할 수 있다. 다만 변수는 재할당을 통해 변수 값을 변경(교체)할 수 있지만 상수는 단 한번만 할당이 허용되므로 변수 값을 변경(교체)할 수 없다.  이처럼 상수는 재할당이 금지된 <strong>변수</strong>일 뿐이지, 변경 불가능한 값의 범주에 포함시키지는 않는다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 상수는 immutable한 값이 아닌 재할당이 금지된 변수이다.</span><br><span class="line">&#x2F;&#x2F; 상수에 객체를 할당할 시 변경 가능하다는 예시가 있다.</span><br><span class="line"></span><br><span class="line">const obj &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj.key &#x3D; &#39;value&#39;;</span><br><span class="line">console.log(obj); </span><br><span class="line">&#x2F;&#x2F;&#123;key: value&#125;</span><br></pre></td></tr></table></figure>



<p><code>변수의 재할당은 어떻게 일어날까?</code></p>
<p>원시값은 변경 불가능한 값이다. 변수에 재할당을 하게되면 원시값이 저장된 메모리공간으로 접근해서 값을 변경하는 것이 아니다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var num &#x3D; 10;</span><br><span class="line">&#x2F;&#x2F;값의 재할당</span><br><span class="line">num &#x3D; 5;</span><br></pre></td></tr></table></figure>

<p>num이라는 변수에 10이라는 숫자가 저장되어 있다. 5를 재할당 할 경우 10 이 저장되어 있는 메모리공간으로 접근해서 <strong>값을 변경하는 것이 아니라 새로운 메모리 공간을 확보</strong>해서 5를 저장한 후 num이라는 변수 이름을 연결해준다.  10은 가비지 컬렉터에 의해 메모리공간확보가 해제된다. </p>
<p>이렇게 처리하는 이유는 컴퓨터 입장에서 편하기 때문이다. </p>
<p>원시값의 이러한 특성을 불변성(immutaility)라고 한다.  불변성을 갖는 원시값을 할당한 변수는 재할당 의외에 변수 값을 변경할 수 있는 방법이 없다. </p>
<h3 id="1-2-문자열과-불변성"><a href="#1-2-문자열과-불변성" class="headerlink" title="1.2 문자열과 불변성"></a>1.2 문자열과 불변성</h3><p>원시값을 메모리 공간에 저장하기 위해서는, <strong>확보해야 하는 메모리 공간의 크기를 결정해야한다</strong>.  원시타입 별로 확보해야하는 메모리 공간의 크기가 정해져 있는 것이다.  ECMAScript 사양을 보면 문자열 타입 (2byte)와 숫자타입(8byte)는 메모리공간의 크기가 명시되어있는 반면에 다른 원시타입은 명시 되어있지 않고 브라우저 제조사의 구현에따라 다를 수 있다. </p>
<p>문자열 값은 다른 원시값과 비교해 독특한 특징이 있다.</p>
<ul>
<li>문자열은 0개 이상의 문자(character)로 이뤄진 집합이다.</li>
<li>1개의 문자는 2byte의 메모리 공간에 저장된다.</li>
<li>문자열은 몇 개의 문자로 이뤄졌느냐에 따라 필요한 메모리 공간의 크기가 결정된다.</li>
</ul>
<p>즉, 문자열은 확보해야하는 메모리공간의 크기가 고정된 다른 원시값과 다르게 <strong>문자의 개수에 따라 확보되는 메모리공간의 크기가 다르다</strong>. 1개의 문자로 된 문자열은 2byte, 5개의 문자로 이뤄진 문자열은 10byte가 필요하다.(실제 계산은 다르긴하다.)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str1 &#x3D; &#39;&#39;;</span><br><span class="line">var str2 &#x3D; &#39;jiman&#39;;</span><br><span class="line">&#x2F;&#x2F;필요한 메모리 공간의 크기가 다르다.</span><br></pre></td></tr></table></figure>

<p>C와 자바에서는 문자열 데이터 타입이 따로 없다. </p>
<p>c에서는 문자타입(char)들의 배열로 문자열을 처리하고, 자바에서는 String 객체로 문자열을 처리한다. </p>
<p>자바스크립트에서는 string이라는 데이터 타입을 제공하는 것이다. 데이터의 신뢰성을 보장하는, 자바스크립트의 장점이다.  </p>
<p>원시타입인 문자열 역시 변경 불가능하다. </p>
<p>문자열에는 독특한 특징이 하나 더 있는데 바로 유사 배열 객체 (array-like-object)라는 것이다. </p>
<p><strong>유사 배열 객체란?</strong></p>
<p>배열 처럼 인덱스로 프로퍼티 값에 접근할 수 있으며, length 프로퍼티를 갖는 객체이다. </p>
<p>즉 문자열은 인덱스로 각 문자 하나하나 에 접근할 수 있고 length 프로퍼티도 갖는다. for 문으로 순회하는 것도 가능하다. </p>
<p>다만 원시값인 문자열을 객체처럼 사용하면 원시값을 감싸는 래퍼 객체로 자동 변환된다. </p>
<p><strong>문자열은 변경 불가능한 원시값이다.</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var str &#x3D; &#39;jiman&#39;;</span><br><span class="line">str[0] &#x3D; &#39;J&#39;;</span><br><span class="line">console.log(str[0]);</span><br><span class="line">&#x2F;&#x2F;jiman</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;원시값이기때문에 개별문자의 변경이 불가하다. </span><br></pre></td></tr></table></figure>



<h3 id="1-3-값에-의한-전달-pass-by-value"><a href="#1-3-값에-의한-전달-pass-by-value" class="headerlink" title="1.3 값에 의한 전달(pass by value)"></a>1.3 값에 의한 전달(pass by value)</h3><p>어떤 변수에 기존에 원시값을 할당했던 변수를 할당하면 어떻게 될까?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var original &#x3D; 10;</span><br><span class="line">var copy &#x3D; original;</span><br><span class="line"></span><br><span class="line">console.log(original, copy);&#x2F;&#x2F; 10 10</span><br><span class="line"></span><br><span class="line">original &#x3D; 20;</span><br><span class="line"></span><br><span class="line">console.log(original, copy); 20 10</span><br></pre></td></tr></table></figure>

<p>copy에 original을 할당할때 original이 10으로 평가되어 새로운메모리 공간을 확보하고 10을 저장한 후 copy를 연결한다. 즉,  copy에는 original의 원시값이 복사되어 전달된다. 이를 값에의한전달 이라고 한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var original &#x3D; 10;</span><br><span class="line">var copy &#x3D; original;</span><br><span class="line"></span><br><span class="line">console.log( original, copy); &#x2F;&#x2F; 10 10</span><br><span class="line">console.log(original &#x3D;&#x3D;&#x3D; copy); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">orignal &#x3D; 20;</span><br><span class="line">console.log( original &#x3D;&#x3D;&#x3D; copy); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p>original 과 copy는 평가되었을때 동일한 숫자 값이지만, 두 값을 저장한 메모리공간의 위치는 다르다. 즉 orignal과 copy에 저장된 값은 별개의 값이다. </p>
<p>ECMAScript 사양에 변수를 통한 메모리 관리가 명확히 정의되지 않아서 값에 의한 전달시 두가지 경우가 있을 수 있다. </p>
<ul>
<li>식별자를 할당했을때 같은 원시값을 참조하였다가 재할당시 새로운 생성값을 참조</li>
<li>식별자 할당시부터 새로운 메모리공간 생성후 평가값저장후 참조</li>
</ul>
<p>파이썬은 전자처럼 동작한다고 한다. 할당 시점에 두 변수가 기억하는 메모리주소가 같느냐 다르냐이다. </p>
<p><strong>중요한것은 두 변수의 원시값이 결국엔 서로다른 메모리 공간에 저장된 다는 것이다.</strong>  서로 간섭하지 않는다.  </p>
<h2 id="2-객체"><a href="#2-객체" class="headerlink" title="2. 객체"></a>2. 객체</h2><p>객체 값을 생성할때 메모리공간의 크기는 어떻게 될까?</p>
<p>객체는 다음과 같은 특징이있다.</p>
<ul>
<li>객체는 프로퍼티의 개수가 고정되어 있지 않고, 동적으로 추가되고 삭제될 수 있다.</li>
<li>프로퍼티 값에 제약이 없다. </li>
<li>즉, 원시값과 같이 확보해야할 메모리 공간의 크기를 사전에 정해 둘 수 없다. </li>
</ul>
<p>객체는 복합적인 자료구조이다. 원시값과 비교하였을 때 복잡하고 브라우저 제조사마다 구현방식이 다를 수 있댜. 소비하는 메모리가 상대적으로 적은 원시값에 비해, 객체는 소비하는 메모리가 경우에 따라 매우 클 수 있다. </p>
<p>객체를 생성하고 프로퍼티에 접근하는 것도 원시값과 비교할 때 비용이 많이든다. </p>
<h3 id="2-1-객체는-변경-가능한-값이다"><a href="#2-1-객체는-변경-가능한-값이다" class="headerlink" title="2.1 객체는 변경 가능한 값이다."></a>2.1 객체는 변경 가능한 값이다.</h3><p>객체는 변경 가능한 값(mutable value) 이다.  변수에 원시값을 할당하면, 변수를 통해 해당 메모리공간에 저장된 값으로 직접 접근한다. 하지만, 객체를 할당한다면, 변수를 통해서 **참조값(reference value)**에 접근한다. </p>
<p>참조값은 <strong>객체가 저장된 메모리공간의 메모리 주소</strong>이다. 이 참조값을 통해 객체가 저장된 메모리공간에 접근할 수 있다.  그래서 원시값을 할당한 변수의 경우 변수는 ~~값을 갖는다 라고 표현하지만, 객체의 경우 변수는 객체를 가리키고(point) 있다 라고 표현한다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var object &#x3D; &#123;</span><br><span class="line">    key: &#39;value&#39;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;변수 objdect 는 객체&#123;key: &#39;value&#39;&#125;를 가리키고(참조하고) 있다.</span><br></pre></td></tr></table></figure>

<p>변수의 값을 변경해보자. 원시값은 재할당 외에는 방법이 없다. </p>
<p>하지만 객체는 변경 가능한 값이므로 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있다. </p>
<ul>
<li>프로퍼티 동적 추가</li>
<li>프로퍼티 값 갱신 </li>
<li>프로퍼티 삭제</li>
</ul>
<p>위 사항 모두 가능하다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var object &#x3D; &#123;</span><br><span class="line">    key: &#39;value&#39;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;object 변수에 객체 할당</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;프로퍼티 키 동적 추가</span><br><span class="line">object.addedKey&#x3D;&#39;value1&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;프로퍼티 값 갱신</span><br><span class="line">object.key &#x3D; &#39;modifiedValue&#39;;</span><br><span class="line"></span><br><span class="line">console.log(object);</span><br><span class="line">&#x2F;&#x2F;&#123; key: &#39;modifiedValue&#39;, addedKey: &#39;value1&#39; &#125;</span><br></pre></td></tr></table></figure>

<p>변수에는 객체의 참조값이 할당되어 있다.  프로퍼티 값을 조작할때 변수에 재할당은 하지 않았으므로 변수의 참조값이 변경되지않는다. </p>
<p>객체가 새로이 생성되지 않고 변경가능하게 설계된 이유는 무엇일까?</p>
<p>객체를 생성하고 관리하는 방식이 복잡하고 비용이 많이 드는일이다. 객체는 크기가 매우 클 수도 있고 원시값처럼 크기가 일정하지도 않으며 프로퍼티 값이 객체일 수 도있다. 그렇기때문에 복사해서 생성하는 비용이 많이든다. 메모리의 효율적 소비가 어렵고 성능이 나빠진다. </p>
<p>그렇기때문에 원시값 처럼 이전값을 복사해서 새롭게 생성하지 않는다. 객체는 메모리를 효율적으로 사용하고, 복사 및 생성비용을 절약하기 위해 변경가능한 값으로 설계되어 있다. 데이터의 신뢰성이 원시값에 비해 떨어지지만, 메모리 사용의 효율성과 성능을 고려한 것이다. </p>
<p>결론적으로 메모리 관점에서 효율성을 얻었지만 구조적인 단점도 가지고 있다.</p>
<p>이러한 단점에 따른 부작용이 있다.</p>
<p>바로 여러 개의 식별자가 하나의 객체를 공유할 수 있다는 것이다. </p>
<p>얕은 복사와 깊은 복사의 개념을 짚고 넘어가자.</p>
<p>객체의 프로퍼티 값으로 객체를 가지고 있다고 했을 때,</p>
<ul>
<li>얕은복사 : 한단계 까지만 복사하는 것을 말한다.</li>
<li>깊은복사 : 객체에 중첩되어 있는 객체 까지 복사하는 것</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">const o &#x3D; &#123;</span><br><span class="line">    a: &#123;</span><br><span class="line">        b: 2</span><br><span class="line">    &#125;,</span><br><span class="line">    f()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 얕은 복사1</span><br><span class="line">let c &#x3D; &#123; ...o&#125;; &#x2F;&#x2F; 35. 스프레드 문법에 있다고 한다.</span><br><span class="line">console.log(o&#x3D;&#x3D;&#x3D;c); &#x2F;&#x2F;false</span><br><span class="line">console.log(o.a &#x3D;&#x3D;&#x3D; c.a); &#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F; 한단계까지는 복사 하였지만 내부의 객체는 참조값을 전달했다.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;얕은 복사2 </span><br><span class="line">c &#x3D; Object.assign(&#123;&#125;,o);</span><br><span class="line">console.log(o &#x3D;&#x3D;&#x3D; c); &#x2F;&#x2F; false</span><br><span class="line">console.log(o.a &#x3D;&#x3D;&#x3D; c.a); &#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F; 마찬가지로 한단계까지 복사하고 내부의 객체는 참조값을 전달</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 깊은복사 1</span><br><span class="line">&#x2F;&#x2F; JSON.parse 와 JSON.stringify를 사용한 깊은복사</span><br><span class="line">c &#x3D; JSON.parse(JSON.stringify(o));</span><br><span class="line">console.log(o &#x3D;&#x3D;&#x3D; c); &#x2F;&#x2F; false</span><br><span class="line">console.log(o.a &#x3D;&#x3D;&#x3D; c.a); &#x2F;&#x2F; false</span><br><span class="line">&#x2F;&#x2F; 메서드가 사라지는 문제가있다.</span><br><span class="line">console.log(c.f);&#x2F;&#x2F; undefined</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 깊은 복사 2</span><br><span class="line">&#x2F;&#x2F; &quot;npm install lodash&quot;로 lodash를 설치한 후, Node.js 환경에서 실행</span><br><span class="line">const _ &#x3D; require(&#39;lodash&#39;);</span><br><span class="line"></span><br><span class="line">c &#x3D; _cloneDeep(o);</span><br><span class="line">console.log( o &#x3D;&#x3D;&#x3D; c); false</span><br><span class="line">console.log( o.a &#x3D;&#x3D;&#x3D; c.a); &#x2F;&#x2F;false</span><br><span class="line">console.log(c.f); &#x2F;&#x2F; f</span><br></pre></td></tr></table></figure>



<p>참고로, <strong>원시값을 할당한 변수를 다른 변수에 할당</strong>하는 것을 깊은복사, <strong>객체를 할당한 변수를 다른변수에 할당</strong>하는 것을 얕은 복사라고 하는 경우도 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;깊은 복사</span><br><span class="line">const v &#x3D; 1;</span><br><span class="line">const c1 &#x3D; v;</span><br><span class="line">console.log(c1 &#x3D;&#x3D;&#x3D; v); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;얕은 복사</span><br><span class="line">const o &#x3D; &#123; x: 1&#125;;</span><br><span class="line">const c2 &#x3D; o;</span><br><span class="line">consol.log(c2 &#x3D;&#x3D;&#x3D; o); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>



<h3 id="2-2-참조에-의한-전달"><a href="#2-2-참조에-의한-전달" class="headerlink" title="2.2 참조에 의한 전달"></a>2.2 참조에 의한 전달</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jjm2317.github.io/2020/08/28/javascript-ASCII-Unicode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jeong Jiman">
      <meta itemprop="description" content="All Dev stories found in here.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeong Jiman's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/28/javascript-ASCII-Unicode/" class="post-title-link" itemprop="url">javascript ASCII, Unicode</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-28 18:30:58 / Modified: 18:31:42" itemprop="dateCreated datePublished" datetime="2020-08-28T18:30:58+09:00">2020-08-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="아스키-코드-ASCII-amp-유니코드-Unicode-정리"><a href="#아스키-코드-ASCII-amp-유니코드-Unicode-정리" class="headerlink" title="아스키 코드(ASCII)&amp; 유니코드 (Unicode) 정리"></a>아스키 코드(ASCII)&amp; 유니코드 (Unicode) 정리</h1><h2 id="문자인코딩이-필요한-이유"><a href="#문자인코딩이-필요한-이유" class="headerlink" title="문자인코딩이 필요한 이유"></a>문자인코딩이 필요한 이유</h2><h3 id="먼저-프로그래밍-언어란"><a href="#먼저-프로그래밍-언어란" class="headerlink" title="먼저, 프로그래밍 언어란?"></a>먼저, 프로그래밍 언어란?</h3><p><strong>컴퓨터는 사람의 언어를 이해하지 못한다.</strong> 컴퓨터는 기계어만을 이해할 수 있다. </p>
<p>그렇기 때문에 컴퓨터에게 명령을 내리기 위해서는 인간의 언어인 자연어를 기계어로 바꿔서 명령을 해주어야 한다. 하지만 이진수로 이루어진 기계어를 <strong>직접 입력한다는 것은 복잡하고 어렵다.</strong>  </p>
<p> 사람과 컴퓨터의 소통을 매개하기 위해 필요한 것이 컴파일러라는 번역기이다. 우리는 이 번역기에 <strong>프로그래밍 언어</strong>로 작성한 프로그램을 보내주면 컴파일러가 프로그래밍 언어를 기계어로 번역해준다. </p>
<p>즉 프로그래밍언어는 <strong>인간과 컴퓨터의 소통을 매개</strong>하기 위해 만들어진 언어이다.</p>
<h3 id="문자-인코딩은-문자열을-컴퓨터에-전달하는-것이다"><a href="#문자-인코딩은-문자열을-컴퓨터에-전달하는-것이다" class="headerlink" title="문자 인코딩은 문자열을 컴퓨터에 전달하는 것이다."></a>문자 인코딩은 문자열을 컴퓨터에 전달하는 것이다.</h3><p>명령, 즉 우리의 언어를 기계어로 컴퓨터에게 전달하고 컴퓨터로부터 출력값을 전달받기위해서, </p>
<p>프로그래밍 언어에서는 어떤 값을 어떤 기계어로 변환할 것인지,그리고 컴퓨터가 처리한 정보를 어떻게 변환할 지에 대한 체계를 도입하고 있다. </p>
<p>여기서 인코딩과 디코딩이라는 개념을 짚어보자</p>
<ul>
<li>인코딩 :  사용자가 입력한 문자나 기호들을 컴퓨터가 이용할 수 있는 신호로 만드는 것</li>
<li>디코딩 :  인코딩된 신호를 다시 인간이 이해할수 있게 해독하는 것</li>
</ul>
<p>예로 우리가 ‘영어’로 작성한 프로그램을 기계어로 바꿔야된다. 그것이 <strong>문자 인코딩</strong>이다. 그런데 문자 인코딩을 위해서는 일관된 체계가 필요하다. 문자인코딩에 대한 기준, 체계를 정리한것이 <strong>문자열 세트</strong>이다. </p>
<p>일반적으로 문자 인코딩과 문자열 세트는 <strong>어떤 문자를 사용할 수 있으며 어떤 식으로 표현되는지를 나타내는 데서 동의어로 취급</strong>되기도한다.</p>
<h3 id="문자-인코딩은-어떻게-이루어지는가"><a href="#문자-인코딩은-어떻게-이루어지는가" class="headerlink" title="문자 인코딩은 어떻게 이루어지는가"></a>문자 인코딩은 어떻게 이루어지는가</h3><p>문자 인코딩 형태(character encoding form) :  문자열 세트 내의 문자들을 컴퓨터 시스템에서 사용할 목적으르 일정한 범위 안의 정수(코드 값) 으로 변환한다. </p>
<h2 id="아스키코드와-유니코드"><a href="#아스키코드와-유니코드" class="headerlink" title="아스키코드와 유니코드"></a>아스키코드와 유니코드</h2><p>문자열 세트의 표준으로서, 초기에는 <strong>아스키코드</strong>가 활용되었다. 아스키코드는 ‘<strong>영어</strong>‘라는 언어에 대한 인코딩 기준이다.  하지만 프로그래밍이  세계적으로 점차 확대됨에 따라 영어 하나로는 한계점이 있었다.더욱이 7비트만을 활용하는 아스키 특성상 다른 언어를 새로이 집어 넣는 것도 불가 하였다. 그래서 확장판인 <strong>유니코드</strong>가 등장하였다. 최초버전의 용량이 무려 2byte, 즉 16비트 65536개의 문자를 표현할 수 있다. 버전이 확장됨에 따라 현재 100만자 이상을 표현할 수 있다.</p>
<h2 id="1-ASCII"><a href="#1-ASCII" class="headerlink" title="1. ASCII"></a>1. ASCII</h2><p>아스키 인코딩의 특징을 알아보자</p>
<ul>
<li><p>7비트 인코딩</p>
</li>
<li><p>1비트는 오류검출용으로 사용</p>
</li>
<li><p>33개의 제어문자, 95개의 출력 가능 문자</p>
</li>
<li><p>출력가능문자 : 52개 알파벳 대소문자 / 10개 숫자 / 32개 특수문자  1개 공백문자 </p>
<p>아스키 코드표</p>
</li>
</ul>
<p><img src="https://t1.daumcdn.net/cfile/tistory/216CE84C52694FF020" alt="ASCII Table - 아스키 코드표"></p>
<h2 id="2-유니코드"><a href="#2-유니코드" class="headerlink" title="2. 유니코드"></a>2. 유니코드</h2><p>유니코드는 기존의 1byte에 문자열 셋을 할당한 방식에서, 더 많은 언어를 표시하고자 국제적으로 만들어진 표준코드이다. </p>
<p>다음과같은특징이 있다.</p>
<ul>
<li>가변 인코딩 방식(글자마다 byte 길이가 다르다.)</li>
</ul>
<p><img src="https://miro.medium.com/max/1624/1*A6GcpKbbG-u6ps66f_rEjg.png" alt="Image for post"></p>
<p>(출처 : 위키피디아)</p>
<ul>
<li>아스키코드와 호환된다.</li>
<li>확장 가능하다.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jjm2317.github.io/2020/08/27/javascript-10ObjectLiteral/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jeong Jiman">
      <meta itemprop="description" content="All Dev stories found in here.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeong Jiman's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/27/javascript-10ObjectLiteral/" class="post-title-link" itemprop="url">javascript 10ObjectLiteral</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-27 22:10:26" itemprop="dateCreated datePublished" datetime="2020-08-27T22:10:26+09:00">2020-08-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-14 21:59:45" itemprop="dateModified" datetime="2020-09-14T21:59:45+09:00">2020-09-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="객체-리터럴"><a href="#객체-리터럴" class="headerlink" title="객체 리터럴"></a>객체 리터럴</h1><ul>
<li>앞의 데이터 타입(data type) 에서 자바스크립트의 데이터 타입에는 원시 타입(primitive type)과 객체 타입(object/referrence type) 이 있다는 것을 알았다</li>
<li>리터럴은 값을 생성하는 표현식이다.</li>
<li>이번 챕터에서는 객체 리터럴(object literal), 즉 객체 값을 생성하는 표현식과 특징들을 알아볼 것이다.</li>
</ul>
<h2 id="1-객체란"><a href="#1-객체란" class="headerlink" title="1. 객체란?"></a>1. 객체란?</h2><p>자바스크립트가 <strong>객체기반의 프로그래밍 언어</strong>라는 말은 많이 들었다. 그렇다면 여기서 말하는 객체란 무엇일까?</p>
<p>자바스크립트 언어에는 여러 값(value)들이 있다.</p>
<ul>
<li><strong>원시 값(primitive value)를 제외한 모든 값</strong>은 객체이다.</li>
<li>함수, 배열, 정규표현식 등은 모두 객체이다.</li>
</ul>
<p>그렇다면 이 객체라는 값은 어떤 특징을 가지고 있을까??</p>
<p>원시값과 비교해보면,</p>
<ul>
<li>원시 값은 <strong>변경 불가한 값(immutable value)</strong> 인 반면에, 객체는 **변경 가능한 값(mutable value)**이다.</li>
<li>원시 타입은 <strong>하나의 값</strong>만을 가지지만 객체 타입은 <strong>여러 타입의 값</strong>들을 하나의 묶음으로서 가진다.<ul>
<li>표현식이 원시타입으로 평가될 때 하나의 메모리에 저장된 하나의 값으로 평가된다.</li>
</ul>
</li>
</ul>
<p>객체의 특징을 객체의 구조와 함께 알아보자</p>
<h3 id="1-1-객체의-구조"><a href="#1-1-객체의-구조" class="headerlink" title="1.1 객체의 구조"></a>1.1 객체의 구조</h3><p>객체는 여러타입의 값들을 하나의 묶음으로 가진다고 하였다.</p>
<p>여기서 값들은 정확히는 0개 이상의 <strong>프로퍼티</strong> 를 나타낸다</p>
<h4 id="객체는-프로퍼티의-집합이다"><a href="#객체는-프로퍼티의-집합이다" class="headerlink" title="객체는 프로퍼티의 집합이다"></a>객체는 프로퍼티의 집합이다</h4><p><strong>프로퍼티는 식별자의 상태(state), 동작을 나타낸다.</strong></p>
<ul>
<li>객체는 프로퍼티(property)의 집합이다</li>
<li>프로퍼티는 키(key)와 값(value)로 구성된다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var student &#x3D; &#123;</span><br><span class="line">    name: &#39;Jiman&#39;, &#x2F;&#x2F;프로퍼티</span><br><span class="line">    age: 23 &#x2F;&#x2F; 프로퍼티</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;name, age 는 프로퍼티 키(key), &#39;Jiman&#39;, 23 은 각각 키에 대한 프로퍼티 값(value)이다&#x2F; </span><br></pre></td></tr></table></figure>

<ul>
<li>프로퍼티 값은 <strong>어떤 데이터 타입</strong>도 가질 수 있다(원시값 or 객체)<ul>
<li>프로퍼티 값이 함수일 때 그 프로퍼티는 <strong>메서드</strong>라고 명명한다.</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var gun &#x3D; &#123;</span><br><span class="line">    bullet: 10, &#x2F;&#x2F; 프로퍼티</span><br><span class="line">    shot: function()&#123;</span><br><span class="line">        this.bullet--;</span><br><span class="line">    &#125; &#x2F;&#x2F; 프로퍼티이다. 프로퍼티 값으로 객체 타입인 함수를 사용하였다.</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; 프로퍼티 값이 함수일 경우 그 프로퍼티는 &#39;메서드&#39; 라고 한다.</span><br></pre></td></tr></table></figure>

<p>메서드도 프로퍼티이지만 값으로 사용되는 프로퍼티와 구조와 사용방식이 다르므로 구분해서 설명해보자.</p>
<p>여기까지, 객체는 <strong>프로퍼티와 메서드의 집합</strong>이라는 것을 알 수 있다.</p>
<h5 id="프로퍼티와-메서드"><a href="#프로퍼티와-메서드" class="headerlink" title="프로퍼티와 메서드"></a>프로퍼티와 메서드</h5><ul>
<li>프로퍼티 : 객체의 상태를 나타내는 <strong>값(data)</strong></li>
<li>메서드 : 객체의 프로퍼티(data)를 참조하고 조작할 수 있는 <strong>동작(behavior)</strong></li>
</ul>
<h4 id="정리해보면"><a href="#정리해보면" class="headerlink" title="정리해보면!"></a>정리해보면!</h4><ul>
<li><p>객체는 자바스크립트의 값(value)이다. 원시값 이외는 모두 객체!</p>
</li>
<li><p>프로퍼티의 집합이다. 프로퍼티는 여러 타입의 값을 가질 수 있다.</p>
</li>
<li><p>프로퍼티 값이 객체일 수도 있으며 함수일 경우 그 프로퍼티를 메서드라고한다.</p>
</li>
</ul>
<p>객체 지향 프로그래밍이란 <strong>객체들의 집합</strong>으로 프로그램을 표현하려는 프로그래밍 패러다임이다.</p>
<h2 id="2-객체-리터럴에-의한-객체-생성"><a href="#2-객체-리터럴에-의한-객체-생성" class="headerlink" title="2. 객체 리터럴에 의한 객체 생성"></a>2. 객체 리터럴에 의한 객체 생성</h2><p>지금까지 객체가 무엇인지 알아보았다. 이젠 객체라는 값을 생성할 수 있는 방법을 알아보자.</p>
<p> 값을 생성하려고 할때 <strong>표현식</strong>을 작성하며, 특정 타입의 값을 표기 자체로 생성하려고 할때 표현식으로써 <strong>리터럴</strong>을  사용한다. </p>
<p>리터럴은 값을 나타내는 약속된 기호이다. <strong>객체 값을 생성하는 리터럴</strong>이 존재한다.</p>
<h3 id="객체-리터럴의-사용"><a href="#객체-리터럴의-사용" class="headerlink" title="객체 리터럴의 사용"></a>객체 리터럴의 사용</h3><ul>
<li>객체리터럴은 중괄호{} 안에 프로퍼티들을 정의하는 방식이다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">var cafe &#x3D; &#123;</span><br><span class="line">    coffee: [&#39;americano&#39;,&#39;latte&#39;, &#39;chocolate&#39;],</span><br><span class="line">    sales: [0,0,0],</span><br><span class="line">    showMenu: function()&#123;</span><br><span class="line">        console.log(this.coffee.toString());</span><br><span class="line">    &#125;,</span><br><span class="line">    chooseCoffee: function(num)&#123;</span><br><span class="line">        switch(num)&#123;</span><br><span class="line">            case 1: </span><br><span class="line">                this.sales[0]++;</span><br><span class="line">                console.log(&#39;아메리카노 팔림&#39;);</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                this.sales[1]++;</span><br><span class="line">                console.log(&#39;라떼 팔림&#39;);</span><br><span class="line">                break;</span><br><span class="line">            case 3:</span><br><span class="line">                this.sales[2]++;</span><br><span class="line">                console.log(&#39;초콜릿 팔림&#39;);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(typeof cafe); &#x2F;&#x2F; object</span><br><span class="line">console.log(cafe);</span><br><span class="line">&#x2F;&#x2F;&#123;</span><br><span class="line">  coffee: [ &#39;americano&#39;, &#39;latte&#39;, &#39;chocolate&#39; ],</span><br><span class="line">  sales: [ 0, 1, 0 ],</span><br><span class="line">  showMenu: [Function: showMenu],</span><br><span class="line">  chooseCoffee: [Function: chooseCoffee]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;지금 카페라서 한번 만들어봤다.</span><br></pre></td></tr></table></figure>

<ul>
<li>프로퍼티를 정의하지 않으면 빈 객체가 생성된다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var cafe &#x3D; &#123;&#125;;</span><br><span class="line">console.log(typeof cafe); &#x2F;&#x2F; object</span><br></pre></td></tr></table></figure>



<h3 id="객체-리터럴은-코드블록과-다르다"><a href="#객체-리터럴은-코드블록과-다르다" class="headerlink" title="객체 리터럴은 코드블록과 다르다"></a>객체 리터럴은 코드블록과 다르다</h3><p>코드 블록은 {} 안에 문들을 작성하는 방식으로 쓰인다는 점에서 객체 리터럴과 비슷하게 보인다. 하지만, 차이가 있다.</p>
<h4 id="객체-리터럴은-값으로-평가되는-표현식이다"><a href="#객체-리터럴은-값으로-평가되는-표현식이다" class="headerlink" title="객체 리터럴은 값으로 평가되는 표현식이다."></a>객체 리터럴은 값으로 평가되는 표현식이다.</h4><p>코드블록은 {} 안에 문들을 작성하는 블록문이다. 자체종결성이 있어 세미콜론을 붙이지 않는다.</p>
<p>그에반해, 객체리터럴은 표현식이다.  중괄호 뒤에 세미콜론을 붙인다.</p>
<p>여기까지, 객체의 개념과 객체를 생성하는 방법도 알았다. 지금부터는 객체에 대해 구체적으로 알아보자. </p>
<h2 id="3-프로퍼티"><a href="#3-프로퍼티" class="headerlink" title="3. 프로퍼티"></a>3. 프로퍼티</h2><p>객체는 프로퍼티들의 집합이다. 이 프로퍼티들은 <strong>키와 값</strong>으로 구성된다.</p>
<ul>
<li>프로퍼티는 세미콜론이 아닌, 쉼표로 구분한다.</li>
<li>마지막 프로퍼티 뒤에는 일반적으로 쉼표를 사용하지 않는다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var myMajor &#x3D; &#123;</span><br><span class="line">    name: &#39;Industrial Engineering&#39;,</span><br><span class="line">    grade: 4.2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>프로퍼티의 키(key), 값(value) 에는 어떤 값이 와야될까?</p>
<ul>
<li>프로퍼티 키 : 빈 문자열’ ‘을 포함하는 모든 <strong>문자열</strong> 또는 <strong>심벌 값</strong></li>
<li>프로퍼티 값 : 자바스크립트의 모든 값</li>
</ul>
<h3 id="프로퍼티-키의-네이밍-규칙"><a href="#프로퍼티-키의-네이밍-규칙" class="headerlink" title="프로퍼티 키의 네이밍 규칙"></a>프로퍼티 키의 네이밍 규칙</h3><p>프로퍼티 키는 프로퍼티 값에 접근할 수 있는 이름이다. 즉 <strong>식별자</strong> 역할을 한다. </p>
<p>식별자들은 일반적으로 식별자 네이밍 규칙을 따른다. 하지만 프로퍼티 키는 식별자 역할을 하지만 네이밍 규칙을 반드시 따라야 되는 것은 아니다. 즉, 식별자 네이밍 규칙을 준수할 수 도, 그렇지 않을수도 있다. </p>
<h4 id="프로퍼티-키는-어떻게-네이밍하는가"><a href="#프로퍼티-키는-어떻게-네이밍하는가" class="headerlink" title="프로퍼티 키는 어떻게 네이밍하는가"></a>프로퍼티 키는 어떻게 네이밍하는가</h4><p>심벌 값 OR 문자열을 사용(<strong>일반적으로 문자열을 사용한다</strong>)</p>
<ul>
<li>문자열은 따옴표로 묶어야하지만 식별자 네이밍 규칙을 준수하는 경우, 따옴표를 생략할 수 있다.</li>
<li>식별자 네이밍 규칙을 따르지 않는다면 따옴표를 사용해야한다.</li>
</ul>
<p><code>자바스크립트에서 식별자이름으로 쓸 수 있는 모든 표기는 식별자 네이밍 규칙을 준수한 것이다.</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var phoneNumber &#x3D; &#123;</span><br><span class="line">    firstPin : 010,&#x2F;&#x2F; 식별자 네이밍 규칙 준수</span><br><span class="line">    &#39;second-pin&#39; : 9453, &#x2F;&#x2F; 식별자 네이밍 규칙 미준수</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>식별자 네이밍 규칙을 준수한 프로퍼티키 firstPin은 따옴표를 사용하지 않았어도  문자열로 평가된다. </p>
<p>하지만 식별자 네이밍 규칙을 준수하지 않은 프로퍼티키 second-pin은 따옴표를 생략할 수 없다. 만약 따옴표를 생략한다면 자바스크립트 엔진은 - 연산자 표현식으로서 second-pin을 해석할 것이다. </p>
<h5 id="따옴표를-생략한다면"><a href="#따옴표를-생략한다면" class="headerlink" title="따옴표를 생략한다면?"></a>따옴표를 생략한다면?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var phoneNumber &#x3D; &#123;</span><br><span class="line">    firstPin : 010,</span><br><span class="line">    second-pin : 9453, &#x2F;&#x2F; SyntaxError 발생</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="프로퍼티-키의-추가적인-특징"><a href="#프로퍼티-키의-추가적인-특징" class="headerlink" title="프로퍼티 키의 추가적인 특징"></a>프로퍼티 키의 추가적인 특징</h3><ul>
<li>문자열 or 문자열로 평가되는 표현식으로, 프로퍼티 키를 동적을 생성가능하다.<ul>
<li>표현식을 대괄호 []로 묶어서 시용</li>
</ul>
</li>
<li>빈문자열을 프로퍼티 키로 사용해도 에러가 발생하지 않음<ul>
<li>but 의미가 없으므로 권장 안함</li>
</ul>
</li>
<li>문자열, 심벌 값 이외의 값을 사용하면 문자열로 암묵적 타입변환된다.</li>
<li>예약어 (var, function 등) 를 프로퍼티 키로 사용가능하다<ul>
<li>권장하지는 않는다</li>
</ul>
</li>
<li>기존에 있던 프로퍼티 키를 중복선언 하게되면 나중에 선언된 프로퍼티키가 먼저 선언한 프로퍼티 키를 덮어 쓴다. </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;프로퍼티 키의 동적 생성</span><br><span class="line">var student &#x3D; &#123;&#125;;</span><br><span class="line">var key &#x3D; &#39;name&#39;;</span><br><span class="line"></span><br><span class="line">student[key] &#x3D; &#39;jiman&#39;;</span><br><span class="line">student[&#39;age&#39;] &#x3D; 23;</span><br><span class="line"></span><br><span class="line">console.log(student); &#x2F;&#x2F; &#123; name: &#39;jiman&#39;, age: 23 &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 빈 문자열을 프로퍼티 키로 사용해도 에러가 발생하지 않는다.</span><br><span class="line">var emptyKey &#x3D; &#123;</span><br><span class="line">    &#39;&#39;: &#39;&#39;;</span><br><span class="line">&#125;</span><br><span class="line">console.log(emptyKey);</span><br><span class="line">&#x2F;&#x2F; &#123;&#39;&#39;: &#39;&#39;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 프로퍼티 키에 문자열 이외의 값(숫자 등)을 사용해도 암묵적 타입변환</span><br><span class="line">var otherKey &#x3D; &#123;</span><br><span class="line">    0: &#39;a&#39;,</span><br><span class="line">    1: &#39;b&#39;,</span><br><span class="line">    2: &#39;c&#39;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(otherKey);</span><br><span class="line">&#x2F;&#x2F; &#123;0: &#39;a&#39;, 1: &#39;b&#39;, 2: &#39;c&#39;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;프로퍼티 키로 예약어 사용해도 에러발생 no</span><br><span class="line">var usingReservedWord &#x3D; &#123;</span><br><span class="line">    var: &#39;var&#39;,</span><br><span class="line">    function: &#39;function&#39;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(usingReservedWord); </span><br><span class="line">&#x2F;&#x2F;&#123;var: &#39;var&#39;, function: &#39;function&#39;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;프로퍼티 키 중복선언시 덮어씀</span><br><span class="line">var overlapKey  &#x3D; &#123;</span><br><span class="line">    age: 23,</span><br><span class="line">    age: 24</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(overlapKey);</span><br><span class="line">&#x2F;&#x2F;&#123;age: 24&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-메서드"><a href="#4-메서드" class="headerlink" title="4. 메서드"></a>4. 메서드</h2><p>객체의 프로퍼티 값(vale) 에는 자바스크립트의 모든 datatype의 값이 올 수 있다고 하였다.</p>
<p>datatype</p>
<ul>
<li>원시값</li>
<li>객체</li>
</ul>
<p>즉 원시값과 객체 값이 모두 올 수 가 있다. 함수는 <strong>객체 타입의 값</strong> 이다. 그렇다면 함수도 프로퍼티 값에 올 수 있다. </p>
<h3 id="메서드-함수를-프로퍼티-값으로-가지는-프로퍼티"><a href="#메서드-함수를-프로퍼티-값으로-가지는-프로퍼티" class="headerlink" title="메서드: 함수를 프로퍼티 값으로 가지는 프로퍼티"></a>메서드: 함수를 프로퍼티 값으로 가지는 프로퍼티</h3><p>함수가 객체의 프로퍼티 값으로 왔을때, 일반함수와의 구분을 위해서 메서드(method)라고 부른다.  즉 메서드는 객체안에 있는 함수이다.</p>
<p>일반적으로 메서드는 객체안의 프로퍼티를 참조하고, 조작할때 사용된다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var musicPlayer &#x3D; &#123;</span><br><span class="line">    songList: [&#39;song1&#39;,&#39;song2&#39;,&#39;song3&#39;],</span><br><span class="line">    showList: function()&#123;</span><br><span class="line">        console.log(this.songList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(musicPlayer.songList());</span><br><span class="line">&#x2F;&#x2F; [ &#39;song1&#39;, &#39;song2&#39;, &#39;song3&#39; ]</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="5-프로퍼티-접근"><a href="#5-프로퍼티-접근" class="headerlink" title="5. 프로퍼티 접근"></a>5. 프로퍼티 접근</h2><p>객체를 생성했다면. 해당 객체가 가지고 있는 프로퍼티를 이용하거나, 프로퍼티 값을 변경하기 위해 프로퍼티에 접근할 필요가 있다.  </p>
<p><code>객체의 프로퍼티에 어떻게 접근할 수 있을까 ?</code> </p>
<p>프로퍼티에 접근하기위해  연산자를 사용하는데, 두가지 방법이 있다.</p>
<ul>
<li>마침표 표기법(dot notation) : 마침표 프로퍼티 접근연산자 . 사용</li>
<li>대괄호 표기법(bracket notation) : 대괄호 프로퍼티 접근 연산자[] 사용</li>
</ul>
<p>프로퍼티 접근연산자는 객체로 평가되는 표현식 우측에 표기한다. 프로퍼티 접근연산자 마침표 . 우측에 / 프로퍼티 접근연산자 대괄호 [] 안에 프로퍼티 키를 표기한다. </p>
<p>대괄호 표기법의 경우 안의 키 이름을 따옴표로 감싸주어야한다. 대괄호 안의 키를 따옴표로 감싸지 않는다면 자바스크립트 엔진이 식별자로 해석한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var approach &#x3D; &#123;</span><br><span class="line">    key &#x3D; &#39;value&#39;</span><br><span class="line">&#125; ;</span><br><span class="line">&#x2F;&#x2F; 마침표 표기법</span><br><span class="line">console.log(approach.value); &#x2F;&#x2F; value</span><br><span class="line">&#x2F;&#x2F; 대괄호 표기법</span><br><span class="line">console.log(approach[&#39;key&#39;]);&#x2F;&#x2F; value 키는 따옴표로 감싼다</span><br><span class="line">&#x2F;&#x2F; 대괄호 표기법에서 따옴표로 감싸지 않는다면</span><br><span class="line">console.log(approach[key]); &#x2F;&#x2F; ReferenceError 발생 </span><br></pre></td></tr></table></figure>



<p><code>객체에 존재하지 않는 프로퍼티에 접근한다면?</code></p>
<p>undefined 를 반환한다 (ReferenceError을 발생시키지 않는다.)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">    key1 &#x3D; &#39;&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(obj.key2); &#x2F;&#x2F;undefined</span><br></pre></td></tr></table></figure>



<p><code>식별자 네이밍 규칙을 미준수한 프로퍼티에 접근하려면?</code></p>
<p>다음과 같은 사항을 유의하자</p>
<ul>
<li>반드시 대괄호 표기법 이용</li>
<li>프로퍼티 키가 숫자인 경우 따옴표 생략 가능<ul>
<li>그 외의 경우 따옴표로 감싼 문자열로 표기</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;식별자 네이밍 규칙을 미준수한 프로퍼티 (ex -연산자 사용)</span><br><span class="line">var person &#x3D; &#123;</span><br><span class="line">    &#39;last-name&#39;: &#39;Jeong&#39;,</span><br><span class="line">    23: &#39;age&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;마침표 표기법으로 접근(에러)</span><br><span class="line">person.&#39;last-name&#39;;&#x2F;&#x2F;SyntaxError</span><br><span class="line">person.last-name; &#x2F;&#x2F; 브라우저에서 NaN &#x2F; Node.js 에서 ReferenceError </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;대괄호 표기법으로 접근(따옴표 써줘야됨)</span><br><span class="line">person[last-name]; &#x2F;&#x2F;ReferenceError</span><br><span class="line">person[&#39;last-name&#39;]; &#x2F;&#x2F;Jeong</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;단 프로퍼티가 숫자라면 따옴표 생략가능</span><br><span class="line">person[23]; &#x2F;&#x2F; age</span><br><span class="line">person[&#39;23&#39;]; &#x2F;&#x2F; age</span><br></pre></td></tr></table></figure>



<h2 id="6-프로퍼티-값-갱신"><a href="#6-프로퍼티-값-갱신" class="headerlink" title="6. 프로퍼티 값 갱신"></a>6. 프로퍼티 값 갱신</h2><p>이미 존재하는 프로퍼티의 값을 변경할 수 있다. 키를 직접 호출해(키에 접근해) 변경하거나 메서드를 이용할 수 있다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var myAge &#x3D; &#123;</span><br><span class="line">    age: 23</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myAge.age&#x3D;24;</span><br><span class="line">console.log(myAge); &#x2F;&#x2F; &#123;age: 24&#125;</span><br></pre></td></tr></table></figure>



<h2 id="7-프로퍼티-동적-생성"><a href="#7-프로퍼티-동적-생성" class="headerlink" title="7. 프로퍼티 동적 생성"></a>7. 프로퍼티 동적 생성</h2><p>객체 내에 존재하지 않는 프로퍼티를 임의로 표기하고 값을 할당하면 어떻게 될까?</p>
<p>프로퍼티가 동적으로 생성되며, 객체 내에 추가되고 프로퍼티 값도 할당된다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var closet &#x3D;&#123;</span><br><span class="line">    outer : 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">closet.inner &#x3D; 5;</span><br><span class="line">console.log(closet); &#x2F;&#x2F; &#123; outer: 2, inner: 5 &#125;</span><br></pre></td></tr></table></figure>



<h2 id="8-프로퍼티-삭제"><a href="#8-프로퍼티-삭제" class="headerlink" title="8. 프로퍼티 삭제"></a>8. 프로퍼티 삭제</h2><p>객체 내의 프로퍼티를 삭제하고 싶다면 delete 연산자를 사용한다.</p>
<p>delete 연산자의 피연산자는 객체의 프로퍼티에 접근할 수 있는 표현식이어야한다.  주의할 점은 객체 내에 존재하지 않는 프로퍼티를 삭제해도 에러발생없이 넘어간다는 점이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var person &#x3D; &#123;</span><br><span class="line">    name: &#39;Jeong&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;delete 연산자를 이용한 프로퍼티 삭제</span><br><span class="line"></span><br><span class="line">delete person.name;</span><br><span class="line">console.log(person); &#x2F;&#x2F;&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>쓰지 않도록 하자. 애초에 삭제할 프로퍼티를 만들지 말자!</p>
<h2 id="9-ES6에서-추가된-객체-리터럴의-확장-기능"><a href="#9-ES6에서-추가된-객체-리터럴의-확장-기능" class="headerlink" title="9. ES6에서 추가된 객체 리터럴의 확장 기능"></a>9. ES6에서 추가된 객체 리터럴의 확장 기능</h2><h3 id="9-1-프로퍼티-축약-표현"><a href="#9-1-프로퍼티-축약-표현" class="headerlink" title="9.1 프로퍼티 축약 표현"></a>9.1 프로퍼티 축약 표현</h3><p>ES6에서는 프로퍼티 값으로 <strong>변수</strong>를 사용하는 경우 변수의 이름과 프로퍼티 키가 동일한 이름이라면 프로퍼티 키를 생략할수 있다</p>
<p>프로퍼티 키는 변수이름으로 자동 생성</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;ES5</span><br><span class="line">var x &#x3D; 1, y &#x3D; 2;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">    x: x,</span><br><span class="line">    y: y</span><br><span class="line">&#125;;</span><br><span class="line">console.log(obj);&#x2F;&#x2F; &#123;x: 1, y: 2&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ES6에서의 축약 표현</span><br><span class="line"></span><br><span class="line">var obj1 &#x3D; [x,y];</span><br><span class="line"></span><br><span class="line">console.log(obj1); &#x2F;&#x2F; &#123;x: 1, y: 2&#125;</span><br></pre></td></tr></table></figure>



<h3 id="9-2-계산된-프로퍼티-이름"><a href="#9-2-계산된-프로퍼티-이름" class="headerlink" title="9.2 계산된 프로퍼티 이름"></a>9.2 계산된 프로퍼티 이름</h3><p>앞에서, 문자열 또는 문자열로 타입 변환할 수 있는 값으로 평가되는 표현식을 사용해 프로퍼티 키를 동적으로 생성할 수 있다고 하였다. 여기서는 대괄호 프로퍼티 접근 연산자를 사용하는데,  표현식에는 계산식이 들어갈 수도 있다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var prefix &#x3D; &#39;prop&#39;;</span><br><span class="line">var i&#x3D; 0;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj[prefix + &#39;-&#39; + ++i] &#x3D; i;</span><br><span class="line">obj[prefix + &#39;-&#39; + ++i] &#x3D; i;</span><br><span class="line">obj[prefix + &#39;-&#39; + ++i] &#x3D; i;</span><br><span class="line"></span><br><span class="line">console.log(obj) &#x2F;&#x2F; &#123;prop-1: 1, prop-2: 2, prop-3: 3&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ES6에서는 객체 리터럴 내부에서도 계산된 프로퍼티 이름으로 동적 생성 가능하다.</span><br><span class="line"></span><br><span class="line">const prefix &#x3D; &#39;prop&#39;;</span><br><span class="line">let i &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;객체 리터럴 내부에서 computed property name 으로 프로퍼티 키 생성</span><br><span class="line"></span><br><span class="line">const obj &#x3D; &#123;</span><br><span class="line">    [&#96;$&#123;prefix&#125;-$&#123;++i&#125;&#96;]: i,</span><br><span class="line">    [&#96;$&#123;prefix&#125;-$&#123;++i&#125;&#96;]: i,</span><br><span class="line">    [&#96;$&#123;prefix&#125;-$&#123;++i&#125;&#96;]: i</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(obj);</span><br><span class="line">&#x2F;&#x2F;&#123;prop-1: 1, prop-2: 2, prop-3: 3&#125;</span><br></pre></td></tr></table></figure>



<h3 id="9-3-메서드-축약-표현"><a href="#9-3-메서드-축약-표현" class="headerlink" title="9.3 메서드 축약 표현"></a>9.3 메서드 축약 표현</h3><p>ES5 에서 메서드를 표기할 때 프로퍼티 키와 값을 명확히 구분해줬지만 ES 6에서는 축약표현을 사용할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;ES5</span><br><span class="line">var coffeeMachine &#x3D; &#123;</span><br><span class="line">    coffee: 10,</span><br><span class="line">    releaseCoffee : function() &#123;</span><br><span class="line">        this.coffee--;</span><br><span class="line">        console.log(&#96;남은 커피 수는 $&#123;this.coffee&#125;개 입니다&#96;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ES6</span><br><span class="line">var coffeeMachine &#x3D; &#123;</span><br><span class="line">    coffee: 10,</span><br><span class="line">    releaseCoffee() &#123;</span><br><span class="line">        this.coffee--;</span><br><span class="line">        console.log(&#96;남은 커피 수는 $&#123;this.coffee&#125;개 입니다&#96;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jjm2317.github.io/2020/08/26/javascript-09Casting-ShortCircuit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jeong Jiman">
      <meta itemprop="description" content="All Dev stories found in here.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeong Jiman's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/26/javascript-09Casting-ShortCircuit/" class="post-title-link" itemprop="url">javascript 09Casting&ShortCircuit</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-26 21:45:20" itemprop="dateCreated datePublished" datetime="2020-08-26T21:45:20+09:00">2020-08-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-14 22:00:13" itemprop="dateModified" datetime="2020-09-14T22:00:13+09:00">2020-09-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="타입-변환과-단축-평가"><a href="#타입-변환과-단축-평가" class="headerlink" title="타입 변환과 단축 평가"></a>타입 변환과 단축 평가</h1><h2 id="타입-변환이란"><a href="#타입-변환이란" class="headerlink" title="타입 변환이란?"></a>타입 변환이란?</h2><ul>
<li>자바 스크립트의 모든 <strong>값</strong>에는 타입이 있다. </li>
<li>타입 변환은 값의 타입을 변환시키는 것이다.</li>
</ul>
<p>타입 변환이 일어나는 방식은 두가지이다.</p>
<ol>
<li>개발자의 의도에 의한 타입 변환</li>
<li>자바스크립트 엔진에 의해 자동으로 수행되는 타입변환</li>
</ol>
<h3 id="개발자가-의도적으로-타입변환-명시적-타입변환"><a href="#개발자가-의도적으로-타입변환-명시적-타입변환" class="headerlink" title="개발자가 의도적으로 타입변환 : 명시적 타입변환"></a>개발자가 의도적으로 타입변환 : 명시적 타입변환</h3><ul>
<li>개발자가 의도적으로 타입을 변환하는 것을 명시적 타입변환(explicit coercion) 또는 타입 캐스팅(type casting) 이라고 한다.</li>
</ul>
<h4 id="예시"><a href="#예시" class="headerlink" title="예시"></a>예시</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var num &#x3D; 100;</span><br><span class="line">&#x2F;&#x2F;식별자 num 에 할당된 값의 타입은 number 이다</span><br><span class="line">var str &#x3D; num.toString();</span><br><span class="line">console.log(num, str); &#x2F;&#x2F; 10 10</span><br><span class="line">console.log(typeof num, typeof str); &#x2F;&#x2F; number string</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; string 타입으로 타입 캐스팅하였다.</span><br><span class="line">&#x2F;&#x2F; num 의 메모리에 할당된 값을 변경한 것은 아니고 새로운 메모리 공간을 확보하여 string 10 을 저장 하였다.</span><br></pre></td></tr></table></figure>

<h3 id="개발자의-의도와-상관없이-타입변환-암묵적-타입변환"><a href="#개발자의-의도와-상관없이-타입변환-암묵적-타입변환" class="headerlink" title="개발자의 의도와 상관없이 타입변환 :  암묵적 타입변환"></a>개발자의 의도와 상관없이 타입변환 :  암묵적 타입변환</h3><ul>
<li>자바스크립트 엔진에 의해 타입이 자동변환된다.</li>
<li>특정 상황에서 <strong>표현식을 평가</strong>할 때 일어난다.</li>
<li>암묵적 타입 변환(implicit coercion) 또는 타입 강제 변환(type coercion) 이라고 한다.</li>
</ul>
<h4 id="예시-1"><a href="#예시-1" class="headerlink" title="예시"></a>예시</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var x &#x3D; 100;</span><br><span class="line"></span><br><span class="line">var str &#x3D; x + &#39;&#39;;</span><br><span class="line">&#x2F;&#x2F; + 연산자는 피연산자에 문자열이 있으면 연결 연산자로 동작한다.</span><br><span class="line">&#x2F;&#x2F; x에 할당된 값 100은 &#39;100&#39; 으로 강제 형변환</span><br><span class="line"></span><br><span class="line">console.log(x,str); &#x2F;&#x2F; 100 100</span><br><span class="line">console.log(typeof x, typeof str); number string</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;개발자의 의도와 상관없이 number 타입이었던 100이 string 타입으로 변경됨</span><br><span class="line">&#x2F;&#x2F; 암묵적 타입변환도 기존 number 타입의 값을 &#39;변경&#39;한 것이 아니며, string 타입의 값을 &#39;생성&#39; 한것이다.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;원시값(primitive value)은 변경 불가능한 점 기억하자</span><br></pre></td></tr></table></figure>



<h3 id="코드를-예측할-수-있는-것이-중요하다-feat-타입변환"><a href="#코드를-예측할-수-있는-것이-중요하다-feat-타입변환" class="headerlink" title="코드를 예측할 수 있는 것이 중요하다(feat.타입변환)"></a>코드를 예측할 수 있는 것이 중요하다(feat.타입변환)</h3><p><strong>명시적 타입변환</strong>의 경우, 코드에 타입변환의 의도가 명백히 드러난다.</p>
<p><strong>암묵적 타입변환</strong>의 경우, 타입변환의 의도가 명백히 드러나지는 않는다.</p>
<p>암묵적 타입변환에 대해 잘 이해하지 못한다면, 뜻밖의 오류가 발생할 수 있으며, 결과를 예측하기 어려워진다. 암묵적타입변환은 왜 쓰이는 것일까? </p>
<p>본래의 경우, <strong>html css 사용자의 편의를 고려</strong>한 자바스크립트의 <strong>탄생배경</strong>과 관련이 있다. <strong>편의를 대가로 오류예측의 어려움</strong>이 생겼지만, 암묵적 타입변환을 잘 이해하고 있다면 다음과 같은 장점이 있다.</p>
<ul>
<li>명시적 타입변환에 비해 간결한 코드를 작성 가능</li>
<li>문법을 이해하고 있다는 가정 하에, 가독성이 더 좋은 코드 작성 가능</li>
</ul>
<p>결론은, 타입변환의 원리를 이해하도록 하자</p>
<p>그렇다면,  이번챕터의 이슈인 암묵적 타입변환을 먼저 다루어보자.</p>
<h2 id="1-암묵적-타입변환"><a href="#1-암묵적-타입변환" class="headerlink" title="1. 암묵적 타입변환"></a>1. 암묵적 타입변환</h2><ul>
<li>자바스크립트 엔진이 코드의 <strong>문맥</strong>을 고려해 데이터타입을 강제 변환</li>
</ul>
<h3 id="‘문맥’을-고려"><a href="#‘문맥’을-고려" class="headerlink" title="‘문맥’을 고려?"></a>‘문맥’을 고려?</h3><p>프로그램내에 여러 상황이 있다.</p>
<ul>
<li>조건식을 평가하여 코드의 실행 여부를 결정</li>
<li>숫자 끼리의 산술 연산</li>
<li>etc…</li>
</ul>
<p>조건식을 평가해서 boolean 값을 도출해야되는데 뜬금없이 숫자 가나온다면?</p>
<p>숫자끼리 산술 연산을 수행하는데 문자열이 나온다면?</p>
<p>: <strong>문맥</strong>에 맞지 않는다</p>
<p>다른 strict 한 언어들은 에러메시지를 출력한다. 하지만,</p>
<p><em>자바스크립트는 문맥까지 생각해주는 친절한 언어이다.</em></p>
<h4 id="예시-2"><a href="#예시-2" class="headerlink" title="예시"></a>예시</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">20*&#39;3&#39;; &#x2F;&#x2F; 60</span><br><span class="line">&#x2F;&#x2F; 문자열 3이 등장했지만 자바스크립트엔진은 *가 산술연산자임을 고려해서 3을 number로 암묵적으로 변환해 반환하였다(number3을 새로 생성)</span><br><span class="line"></span><br><span class="line">20 + &#39;3&#39;; &#x2F;&#x2F;&#39;203&#39;</span><br><span class="line">&#x2F;&#x2F; + 는 산술연산자, 연결연산자 쓰인다. 엔진은 피연산자에 문자열이 있으면 +연산자의 경우 연결연산자로 동작하도록 설계된 듯 하다. &#39;문맥&#39;에 맞게 number 20을 string &#39;20&#39;으로 변환</span><br><span class="line"></span><br><span class="line">if(3)&#123;&#125;;</span><br><span class="line">&#x2F;&#x2F; 조건식 부분에 number3 이 들어가 있다. 엔진은 number3 을  boolean true 로 강제 타입변환하여 값을 생성한다.</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>암묵적 타입변환의 여러 경우를 자세히 살펴보자</p>
<h3 id="1-1-문자열-타입으로-변환"><a href="#1-1-문자열-타입으로-변환" class="headerlink" title="1.1 문자열 타입으로 변환"></a>1.1 문자열 타입으로 변환</h3><p>문맥상 값이 문자열 타입으로 변환되어야 되는 경우는 여러경우가 있다.</p>
<ul>
<li>+연결 연산자의 피연산자들</li>
<li>템플릿 리터럴의 표현식 삽입에서 작성된 표현식</li>
</ul>
<p>문자열 타입변환은 대부분 + 연결연산자와 함께 일어난다.</p>
<h4 id="예시-3"><a href="#예시-3" class="headerlink" title="예시"></a>예시</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;숫자 타입</span><br><span class="line">&#x2F;&#x2F;음수와 양수구분까지 처리한다. 즉 - 단항연산자까지 반영</span><br><span class="line">0 + &#39;&#39;; &#x2F;&#x2F; &#39;0&#39;</span><br><span class="line">-0 + &#39;&#39;; &#x2F;&#x2F; &#39;0&#39; 음수 0 은 음수고려안한다</span><br><span class="line">1 + &#39;&#39; ; &#x2F;&#x2F; &quot;1&quot;</span><br><span class="line">-1 + &#39;&#39;; &#x2F;&#x2F; &#39;-1&#39;</span><br><span class="line">NaN + &#39;&#39;; &#x2F;&#x2F; &#39;NaN&#39;</span><br><span class="line">Infinity + &#39;&#39;; &#x2F;&#x2F; &#39;Infinity&#39;</span><br><span class="line">-Infinity + &#39;&#39;; &#x2F;&#x2F; &#39;-Infinity&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;boolean</span><br><span class="line">true + &#39;&#39;; &#x2F;&#x2F; &#39;true&#39;</span><br><span class="line">false + &#39;&#39;; &#x2F;&#x2F; &#39;false&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;null</span><br><span class="line">null + &#39;&#39;&#x2F;&#x2F; &#39;nul&#39;</span><br><span class="line"></span><br><span class="line">undefined + &#39;&#39;; &#x2F;&#x2F;&quot;undefined&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;symbol</span><br><span class="line">(Symbol())+ &#39;&#39; &#x2F;&#x2F; TypeError 출력</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;객체 타입</span><br><span class="line">(&#123;&#125;) + &#39;&#39;; &#x2F;&#x2F; &quot;[object Object]&quot;</span><br><span class="line">Math + &#39;&#39;; &#x2F;&#x2F; &quot;[object Math]&quot;</span><br><span class="line">[] + &#39;&#39;;</span><br><span class="line">[10, 20] + &#39;&#39;; &#x2F;&#x2F; &quot;10,20&quot;</span><br><span class="line">(function()&#123;&#125;) + &#39;&#39;; &#x2F;&#x2F;&quot;function()&#123;&#125;&quot;</span><br><span class="line">Array + &#39;&#39;; &#x2F;&#x2F; &quot;function Array()&#123;[native code]&#125;&quot;</span><br></pre></td></tr></table></figure>



<h3 id="1-2-숫자-타입으로-변환"><a href="#1-2-숫자-타입으로-변환" class="headerlink" title="1.2 숫자 타입으로 변환"></a>1.2 숫자 타입으로 변환</h3><p>문맥상 값이 숫자 타입으로 변환되어야 하는 경우가 있다.</p>
<ul>
<li>+이외의 산술 연산자( - * / %)의 피연산자</li>
<li>+단항 연산자의 피연산자</li>
<li>&lt;&gt; 비교 연산자의 피연산자</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 문자열 타입</span><br><span class="line">+&#39;&#39;       &#x2F;&#x2F; -&gt; 0</span><br><span class="line">+&#39;0&#39;      &#x2F;&#x2F; -&gt; 0</span><br><span class="line">+&#39;1&#39;      &#x2F;&#x2F; -&gt; 1</span><br><span class="line">+&#39;string&#39; &#x2F;&#x2F; -&gt; NaN 변환해도 실수가 아닌경우 NaN 반환</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 불리언 타입</span><br><span class="line">+true     &#x2F;&#x2F; -&gt; 1</span><br><span class="line">+false    &#x2F;&#x2F; -&gt; 0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; null 타입</span><br><span class="line">+null     &#x2F;&#x2F; -&gt; 0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; undefined 타입</span><br><span class="line">+undefined &#x2F;&#x2F; -&gt; NaN</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 심벌 타입</span><br><span class="line">+Symbol() &#x2F;&#x2F; -&gt; typeError: Cannot convert a Symbol value to a number</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 객체 타입</span><br><span class="line">+&#123;&#125;             &#x2F;&#x2F; -&gt; NaN</span><br><span class="line">+[]             &#x2F;&#x2F; -&gt; 0</span><br><span class="line">+[10, 20]       &#x2F;&#x2F; -&gt; NaN </span><br><span class="line">+(function()&#123;&#125;) &#x2F;&#x2F; -&gt; NaN</span><br></pre></td></tr></table></figure>



<h3 id="1-3-불리언-타입으로-변환"><a href="#1-3-불리언-타입으로-변환" class="headerlink" title="1.3 불리언 타입으로 변환"></a>1.3 불리언 타입으로 변환</h3><p>문맥상 값이 boolean 타입이 되어야 되는 경우는 다음과같다</p>
<ul>
<li>반복문의 조건식</li>
<li>조건문의 조건식</li>
</ul>
<p>즉 제어문의 조건식은 boolean 값으로 평가되어야 하기 때문에 자동 타입변환이 일어난다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(&#39;&#39;) console.log(&#39;1&#39;);</span><br><span class="line">if(true) console.log(&#39;2&#39;);</span><br><span class="line">if(0) console.log(&#39;3&#39;);</span><br><span class="line">if(&#39;str&#39;) console.log(&#39;4&#39;);</span><br><span class="line">if(null) console.log(&#39;5&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2 4</span><br></pre></td></tr></table></figure>

<p>타입 변환이 일어날때 <strong>false로 평가되는 값은 한정적</strong>이므로 false로 평가되는 값들을 알고 나머지는 true로 평가된다고 생각하면 좀 더 편리하다.</p>
<p>값이 boolean타입으로 평가될때 두가지로 평가된다.</p>
<ul>
<li>Truthy 값 : 참으로 평가되는 값 (평가값 true)</li>
<li>Falsy 값 : 거짓으로 평가되는 값 (평가값 false)</li>
</ul>
<h4 id="Falsy-값-false로-평가되는-값"><a href="#Falsy-값-false로-평가되는-값" class="headerlink" title="Falsy 값(false로 평가되는 값)"></a>Falsy 값(false로 평가되는 값)</h4><ul>
<li>false</li>
<li>undefined</li>
<li>null</li>
<li>0, -0</li>
<li>NaN</li>
<li>‘’</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">var values &#x3D; [false, undefined, null, 0 , NaN, &#39;&#39;,&#39;0&#39;,true, &#123;&#125;, []];&#x2F;&#x2F;falsy인지 truthy인지 판별할 값들</span><br><span class="line">var falsyList &#x3D; [];</span><br><span class="line">var truthyList</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Truthy&#x2F;Falsy 를 판별하는 함수</span><br><span class="line">function isFalsy(v)&#123;</span><br><span class="line">    return !v;</span><br><span class="line">&#125;</span><br><span class="line">function isTrue(v)&#123;</span><br><span class="line">    return !!v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;values 값들이 falsy인지 판별해보자</span><br><span class="line"></span><br><span class="line">for(var i of values)&#123;</span><br><span class="line">    if(isFalsy(i))&#123;</span><br><span class="line">        falsyList.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(falsyList);</span><br><span class="line">&#x2F;&#x2F;[ false, undefined, null, 0, NaN, &#39;&#39; ]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;values 값들이 truthy 인지 판별해보자</span><br><span class="line">for (var j of values)&#123;</span><br><span class="line">    if(isTruthy(j))&#123;</span><br><span class="line">        truthyList.push(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(truthyList);</span><br><span class="line">&#x2F;&#x2F;[ &#39;0&#39;, true, &#123;&#125;, [] ]</span><br><span class="line">&#x2F;&#x2F; &#39;0&#39;이 true이다. 빈문자열이 아니면 true로 변환된다. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;별개로 의문점</span><br><span class="line">&#x2F;&#x2F;console.log(falsyList + &#39;는 falsy 값&#39;);</span><br><span class="line">&#x2F;&#x2F;배열 안의 undefined,null 은 배열을 문자열 변환시 사라진다.왜일까</span><br></pre></td></tr></table></figure>





<h2 id="2-명시적-타입-변환"><a href="#2-명시적-타입-변환" class="headerlink" title="2. 명시적 타입 변환"></a>2. 명시적 타입 변환</h2><ul>
<li>개발자의 의도에 따라 명시적으로 타입을 변경할 수 있다.</li>
<li>보통 다음 3가지 방법을 따른다<ul>
<li>표준 빌트인 생성자 함수(String, Number, Boolean)를 new 없이 호출</li>
<li>빌트인 메서드</li>
<li>암묵적 타입변환 이용</li>
</ul>
</li>
</ul>
<p>표준 빌트인 생성자 함수와 빌트인 메서드는 자바스크립트에서 기본제공 함수이다. </p>
<h3 id="2-1-문자열-타입으로-변환"><a href="#2-1-문자열-타입으로-변환" class="headerlink" title="2.1 문자열 타입으로 변환"></a>2.1 문자열 타입으로 변환</h3><p>위에서 제시한 세가지 방법으로 값을 문자열 타입으로 변환시켜보자</p>
<ol>
<li><p>String  생성자 함수를 new 연산자 없이 호출</p>
</li>
<li><p>Object.prototype.toString 메서드 </p>
</li>
<li><p>문자열 연결 연산자</p>
</li>
</ol>
<h4 id="1-String-생성자-함수를-new-연산자-없이-호출"><a href="#1-String-생성자-함수를-new-연산자-없이-호출" class="headerlink" title="1. String 생성자 함수를 new 연산자 없이 호출"></a>1. String 생성자 함수를 new 연산자 없이 호출</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;데이터 타입 : number boolean undefined null symbol, object &gt;&gt; string</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;1. String 생성자 함수를 new 연산자 없이 호출</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;1.1 number to string</span><br><span class="line">String(1); &#x2F;&#x2F; &#39;1&#39;</span><br><span class="line">String(NaN);&#x2F;&#x2F; &#39;NaN&#39;</span><br><span class="line">String(-0); &#x2F;&#x2F; &#39;0&#39;</span><br><span class="line">String(-Infinity); &#x2F;&#x2F; &#39;-Infinity&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;1.2 boolean to string</span><br><span class="line">String(true); &#x2F;&#x2F; &#39;true&#39;</span><br><span class="line">String(false); &#x2F;&#x2F; &#39;false&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;1.3 undefined to string</span><br><span class="line">String(undefined); &#x2F;&#x2F; &#39;undefined&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;1.4 null to string</span><br><span class="line">String(null); &#x2F;&#x2F; &#39;null&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;1.5 symbol to string</span><br><span class="line">String(Symbol()); &#x2F;&#x2F; &#39;Symbol()&#39; 연결연산자로는 안되던게 1 방식에서는 된다!</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;1.6 object to string</span><br><span class="line">String(&#123;&#125;); &#x2F;&#x2F; &#39;[object Object]&#39;</span><br><span class="line">String([]); &#x2F;&#x2F; &#39;&#39;</span><br><span class="line">String([1,2]); &#x2F;&#x2F; &#39;1,2&#39;</span><br><span class="line">String(Array); &#x2F;&#x2F; &#39;function Array() &#123; [native code] &#125;&#39;</span><br><span class="line">String(Math); &#x2F;&#x2F; &#39;[object Math]&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="2-Object-prototype-toString-메서드-이용"><a href="#2-Object-prototype-toString-메서드-이용" class="headerlink" title="2. Object.prototype.toString 메서드 이용"></a>2. Object.prototype.toString 메서드 이용</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;데이터 타입 : number boolean undefined null symbol, object &gt;&gt; string</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2. Object.prototype.toString 메서드 이용</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2.1 number to string</span><br><span class="line">(1).toString(); &#x2F;&#x2F; &#39;1&#39;</span><br><span class="line">(NaN).toString();&#x2F;&#x2F; &#39;NaN&#39;</span><br><span class="line">(-0).toString(); &#x2F;&#x2F; &#39;0&#39;</span><br><span class="line">(-Infinity).toString(); &#x2F;&#x2F; &#39;-Infinity&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2.2 boolean to string</span><br><span class="line">(true).toString(); &#x2F;&#x2F; &#39;true&#39;</span><br><span class="line">(false).toString(); &#x2F;&#x2F; &#39;false&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2.3 undefined to string</span><br><span class="line">(undefined).toString(); &#x2F;&#x2F; typeError 뜨는데.. 왜그럴까</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2.4 null to string</span><br><span class="line">(null).toString(); &#x2F;&#x2F; 이것도 typeError</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2.5 symbol to string</span><br><span class="line">(Symbol()).toString(); &#x2F;&#x2F; &#39;Symbol()&#39; 빌트인 메서드도 된다</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2.6 object to string</span><br><span class="line">(&#123;&#125;).toString(); &#x2F;&#x2F; &#39;[object Object]&#39;</span><br><span class="line">([]).toString(); &#x2F;&#x2F; &#39;&#39;</span><br><span class="line">([1,2]).toString(); &#x2F;&#x2F; &#39;1,2&#39;</span><br><span class="line">(Array).toString(); &#x2F;&#x2F; &#39;function Array() &#123; [native code] &#125;&#39;</span><br><span class="line">(Math).toString(); &#x2F;&#x2F; &#39;[object Math]&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; undefined,null 타입을 제외하곤 String 생성자함수와 동일한결과</span><br></pre></td></tr></table></figure>



<h4 id="3-문자열-연결-연산자"><a href="#3-문자열-연결-연산자" class="headerlink" title="3. 문자열 연결 연산자"></a>3. 문자열 연결 연산자</h4><ul>
<li>암묵적 타입변환에서 다루었으므로 생략</li>
</ul>
<h3 id="2-2-숫자-타입으로-변환"><a href="#2-2-숫자-타입으로-변환" class="headerlink" title="2.2 숫자 타입으로 변환"></a>2.2 숫자 타입으로 변환</h3><p>역시나 크게 세가지 방법이 있다.</p>
<ol>
<li>Number 생성자 함수 new 연산자 없이 호출</li>
<li>parseInt, parseFloat 함수를 사용하는 방법(문자열만 숫자 타입으로 변환 가능)</li>
<li>산술 연산자 이용<ul>
<li>+단항 산술 연산자</li>
<li>*산술 연산자</li>
</ul>
</li>
</ol>
<h4 id="1-Number-생성자-함수-new-연산자-없이-호출"><a href="#1-Number-생성자-함수-new-연산자-없이-호출" class="headerlink" title="1. Number 생성자 함수 new 연산자 없이 호출"></a>1. Number 생성자 함수 new 연산자 없이 호출</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;데이터 타입 : string boolean undefined null symbol, object &gt;&gt; number</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;1. Number 생성자 함수 new 연산자 없이 호출</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;1.1 string to number</span><br><span class="line">Number(&#39;0&#39;); &#x2F;&#x2F; 0</span><br><span class="line">Number(&#39;5.12&#39;); &#x2F;&#x2F; 5.12</span><br><span class="line">Number(&#39;&#39;); &#x2F;&#x2F; 0 빈 문자열 은 0으로 변환</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;1.2 boolean to number</span><br><span class="line">Number(true); &#x2F;&#x2F; 1</span><br><span class="line">Number(false); &#x2F;&#x2F; 0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;1.3 undefined to number</span><br><span class="line">Number(undefined); &#x2F;&#x2F; NaN</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;1.4 null to number</span><br><span class="line">Number(null); &#x2F;&#x2F;  0 </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;undefined 는 NaN, null은 0으로 변환된다.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;1.5 symbol to number</span><br><span class="line">Number(Symbol()); &#x2F;&#x2F; TypeError 발생한다. String 생성자 함수로 가능했지만 Number에서는 안된다.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;1.6 object to number</span><br><span class="line">Number(&#123;&#125;); &#x2F;&#x2F; NaN</span><br><span class="line">Number([]); &#x2F;&#x2F; 0</span><br><span class="line">Number([1,2]); &#x2F;&#x2F; NaN</span><br><span class="line">Number(Array); &#x2F;&#x2F; NaN</span><br><span class="line">Number(Math); &#x2F;&#x2F; NaN</span><br><span class="line">&#x2F;&#x2F; 빈 배열을 제외하고는 NaN으로 변환된다. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="2-parseInt-parseFloat-함수를-사용하는-방법"><a href="#2-parseInt-parseFloat-함수를-사용하는-방법" class="headerlink" title="2. parseInt, parseFloat 함수를 사용하는 방법"></a>2. parseInt, parseFloat 함수를 사용하는 방법</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 문자열만 변환 가능하다</span><br><span class="line"></span><br><span class="line">parseInt(&#39;0&#39;); &#x2F;&#x2F; 0</span><br><span class="line">parseInt(&#39;3.22&#39;)&#x2F;&#x2F; 3 소수점을 무시하고 정수반환</span><br><span class="line">parseFloat(&#39;3.22&#39;)&#x2F;&#x2F; 3.22</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="3-산술-연산자-이용-를-이용한-암묵적-타입변환"><a href="#3-산술-연산자-이용-를-이용한-암묵적-타입변환" class="headerlink" title="3. 산술 연산자 이용(+, * 를 이용한 암묵적 타입변환)"></a>3. 산술 연산자 이용(+, * 를 이용한 암묵적 타입변환)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;데이터 타입 : string boolean undefined null symbol, object &gt;&gt; number</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3. 산술 연산자 이용(+, * 를 이용한 암묵적 타입변환)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3.1 string to number</span><br><span class="line">+&#39;0&#39;;</span><br><span class="line">1 * &#39;0&#39;</span><br><span class="line">&#x2F;&#x2F; 0</span><br><span class="line"></span><br><span class="line">+&#39;5.12&#39;;</span><br><span class="line">1 * &#39;5.12&#39;&#39;;</span><br><span class="line">&#x2F;&#x2F; 5.12</span><br><span class="line"></span><br><span class="line">+&#39;&#39;;</span><br><span class="line">1 * &#39;&#39;;</span><br><span class="line">&#x2F;&#x2F; 0 빈 문자열 은 0으로 변환</span><br><span class="line"></span><br><span class="line">2 * &#39;5&#39;;&#x2F;&#x2F;10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3.2 boolean to number</span><br><span class="line">+true;</span><br><span class="line">1 * true;</span><br><span class="line">&#x2F;&#x2F; 1</span><br><span class="line">2 * true; &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">+false;</span><br><span class="line">1 * false;</span><br><span class="line">&#x2F;&#x2F; 0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3.3 undefined to number</span><br><span class="line">+undefined;</span><br><span class="line">1 * undefined;</span><br><span class="line">&#x2F;&#x2F; NaN</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3.4 null to number</span><br><span class="line">+null;</span><br><span class="line">1 * null;</span><br><span class="line">&#x2F;&#x2F;0 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3.5 symbol to number</span><br><span class="line">+Symbol();</span><br><span class="line">1 * Symbol();</span><br><span class="line">&#x2F;&#x2F; TypeError 발생한다.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3.6 object to number</span><br><span class="line">&#x2F;&#x2F; 마찬가지로, 빈배열이 0으로 변환되는 것을 제외하고 전부 NaN</span><br></pre></td></tr></table></figure>



<h4 id="3-boolean-타입으로-변환"><a href="#3-boolean-타입으로-변환" class="headerlink" title="3. boolean 타입으로 변환"></a>3. boolean 타입으로 변환</h4><p>boolean 타입으로 변환하는 방법은 두가지!</p>
<ol>
<li>Boolean 생성자 함수를 new 연산자 없이 호출하는 방법</li>
<li>! 부정 논리 연산자를 두번 사용하는 방법</li>
</ol>
<p>명시적 타입변환에서도 다음만 고려하면 된다!</p>
<h5 id="Falsy-값-false로-평가되는-값-1"><a href="#Falsy-값-false로-평가되는-값-1" class="headerlink" title="Falsy 값(false로 평가되는 값)"></a>Falsy 값(false로 평가되는 값)</h5><ul>
<li>false</li>
<li>undefined</li>
<li>null</li>
<li>0, -0</li>
<li>NaN</li>
<li>‘’</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1 string to boolean (only &#39;&#39;)</span><br><span class="line">Boolean(&#39;x&#39;);       &#x2F;&#x2F; true</span><br><span class="line">Boolean(&#39;&#39;);        &#x2F;&#x2F; false</span><br><span class="line">Boolean(&#39;false&#39;);   &#x2F;&#x2F; true</span><br><span class="line">!! &#39;x&#39; ; &#x2F;&#x2F; true</span><br><span class="line">!! &#39;&#39;; &#x2F;&#x2F; false</span><br><span class="line">!! &#39;false&#39;&#x2F;&#x2F;true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2 undefined</span><br><span class="line">Boolean(undefined); &#x2F;&#x2F; false</span><br><span class="line">!!(undefined); &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3 null</span><br><span class="line">Boolean(null); &#x2F;&#x2F;  false </span><br><span class="line">!! null; &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;4 0, -0</span><br><span class="line">Boolean(0);&#x2F;&#x2F;false</span><br><span class="line">!!0 ; &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;5 NaN</span><br><span class="line">Boolean(NaN);&#x2F;&#x2F; false</span><br><span class="line">!!NaN;&#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>



<h2 id="3-단축-평가"><a href="#3-단축-평가" class="headerlink" title="3. 단축 평가"></a>3. 단축 평가</h2><p>논리 연산의 결과를 결정하는 피연산자를 <strong>타입 변환 없이</strong> 그대로 반환하는 것</p>
<p>if 문을 대체할 수 있다.</p>
<h3 id="3-1-논리-연산자를-사용한-단축-평가"><a href="#3-1-논리-연산자를-사용한-단축-평가" class="headerlink" title="3.1 논리 연산자를 사용한 단축 평가"></a>3.1 논리 연산자를 사용한 단축 평가</h3><h4 id="issue"><a href="#issue" class="headerlink" title="issue"></a>issue</h4><ul>
<li><strong>논리합 연산자와 논리곱 연산자</strong>의 평가 결과가 불리언 값이 <strong>아닐 수도</strong> 있다. </li>
<li>표현식 <strong>평가 도중에 평가 결과가 확정</strong>되면 <strong>나머지 평가 과정을 생략</strong></li>
</ul>
<p>: 표현식의 평가과정이 생략될 수도 있다!!</p>
<p>논리곱 / 논리합 연산자 사용 예시를 통해 단축평가의 개념을 알아보자</p>
<h4 id="논리곱-논리합-연산자의-평가-결과가-불리언-값이-아닐-수-있다"><a href="#논리곱-논리합-연산자의-평가-결과가-불리언-값이-아닐-수-있다" class="headerlink" title="논리곱/논리합 연산자의 평가 결과가 불리언 값이 아닐 수 있다."></a>논리곱/논리합 연산자의 평가 결과가 불리언 값이 아닐 수 있다.</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#39;Html&#39; &amp;&amp; &#39;CSS&#39;; &#x2F;&#x2F; &#39;CSS&#39;</span><br><span class="line">&#39;Html&#39; || &#39;CSS&#39;; &#x2F;&#x2F; &#39;Html&#39;</span><br><span class="line">&#x2F;&#x2F;boolean 값이 아닌 문자열 피연산자가 그대로 반환된다.</span><br></pre></td></tr></table></figure>

<p>여기서 알아야 될 <strong>논리합/논리곱 연산자 표현식의 평가 과정</strong>!</p>
<ul>
<li>좌항에서 우항으로 평가가 진행된다.</li>
<li>평가 진행 도중 평가 결과가 확정될 수 있다</li>
</ul>
<p>그리고 **중요!**한 특징</p>
<ul>
<li>평가 결과가 확정되면 타입 변환 없이 그대로 반환한다.<ul>
<li>즉 일반적으로 타입변환까지 해서 평가과정을 마무리하는 다른 연산자 표현식과는 차이가 있다.</li>
</ul>
</li>
</ul>
<p>위 코드 예시에서 &amp;&amp; 연산자 표현식을 먼저 보자</p>
<h5 id="두번째-피연산자가-평가결과를-결정"><a href="#두번째-피연산자가-평가결과를-결정" class="headerlink" title="두번째 피연산자가 평가결과를 결정"></a>두번째 피연산자가 평가결과를 결정</h5><p>‘Html’ 이 Truthy 값이므로 true이다. 하지만 <strong>&amp;&amp;연산자 특성상</strong> 이 시점에서 평가가 끝나지 않는다.  우항의 피연산자도 평가를 해야지 연산자 표현식의 평가 결과를 결정할 수 있다.  즉 <strong>평가 결과는 두번째 피연산자인 ‘CSS’</strong> 가 결정한다.  </p>
<h5 id="평가결과가-확정된-시점에-평가-과정을-종료"><a href="#평가결과가-확정된-시점에-평가-과정을-종료" class="headerlink" title="평가결과가 확정된 시점에 평가 과정을 종료"></a>평가결과가 확정된 시점에 평가 과정을 종료</h5><p>첫번째가 true로 평가되서 <strong>두번째 피연산자인 ‘CSS’로 평가 결과가 확정</strong>되었다. 논리 연산의 특성상 boolean 값으로 타입변환해서 true를 반환해야될것 같지만 ‘CSS’ 로 <strong>평가 결과가 확정된 시점에 평가 과정을 종료</strong>하는 <strong>단축평가</strong>가 이루어져, <strong>‘CSS’ 를 타입변환없이 그대로 반환</strong>한다.</p>
<p><strong>논리합 연산자</strong>는 어떨까??</p>
<h5 id="첫번째-피연산자가-평가-결과를-결정"><a href="#첫번째-피연산자가-평가-결과를-결정" class="headerlink" title="첫번째 피연산자가 평가 결과를 결정"></a>첫번째 피연산자가 평가 결과를 결정</h5><p>|| 연산자 특성상 평가 결과중 true가 하나라도 있으면 평가 결과가 확정된다. 즉 Truthy 값인 ‘Html’ 이 평가 결과를 결정한다.  두번째 피연산자는 평가를 시행하지않는다.</p>
<h5 id="평가-결과가-확정된-시점에-평가-과정을-종료"><a href="#평가-결과가-확정된-시점에-평가-과정을-종료" class="headerlink" title="평가 결과가 확정된 시점에 평가 과정을 종료"></a>평가 결과가 확정된 시점에 평가 과정을 종료</h5><p>‘Html’로 평가 결과가 확정되었기 때문에 두번째 피연산자의 평가는 시행하지 않는다. 마찬가지로, 타입변환도 실행하지 않고 평가를 종료한다. ‘Html’ 이 타입변환없이 그대로 반환</p>
<p>그럼, 두가지 연산자의 단축평가에 따른 결과를 정리해보자</p>
<table>
<thead>
<tr>
<th>단축 평가 표현식</th>
<th>평가 결과</th>
</tr>
</thead>
<tbody><tr>
<td>true || anything</td>
<td>true</td>
</tr>
<tr>
<td>false || anything</td>
<td>anything</td>
</tr>
<tr>
<td>true &amp;&amp; anything</td>
<td>anything</td>
</tr>
<tr>
<td>false &amp;&amp; anything</td>
<td>false</td>
</tr>
</tbody></table>
<h4 id="단축평가는-어디에-이용될까"><a href="#단축평가는-어디에-이용될까" class="headerlink" title="단축평가는 어디에 이용될까?"></a>단축평가는 어디에 이용될까?</h4><p>제어문을 사용한다면 코드의 흐름을 제어하게 된다. 제어문은 가독성을 떨어뜨리는 요소이기 때문에 단축평가를 사용하여 대체할 수 있다.</p>
<p>일반적으로</p>
<ol>
<li>if 문 대체</li>
<li>객체를 할당한 변수의 타입을 재확인할 때<ul>
<li>변수가  falsy 값인상태에서 프로퍼티를 참조하면 에러 및 프로그램 종료된다.</li>
</ul>
</li>
<li>함수 매개변수에 기본값 설정</li>
</ol>
<h5 id="if-문-대체"><a href="#if-문-대체" class="headerlink" title="if 문 대체"></a>if 문 대체</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var correct, sign;</span><br><span class="line">correct &#x3D; true;</span><br><span class="line"></span><br><span class="line">if(correct)&#123;</span><br><span class="line">    sign &#x3D; &#39;complete&#39;;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; sign &#x3D; correct &amp;&amp; &#39;complete&#39;;</span><br><span class="line"></span><br><span class="line">if(!correct)&#123;</span><br><span class="line">    sign &#x3D; &#39;fail&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; sign &#x3D; correct || &#39;fail&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;여기까지는 그렇게 유용한가 싶다.</span><br></pre></td></tr></table></figure>



<h5 id="객체를-할당한-변수의-타입을-재확인할때-돌다리-두드려볼때"><a href="#객체를-할당한-변수의-타입을-재확인할때-돌다리-두드려볼때" class="headerlink" title="객체를 할당한 변수의 타입을 재확인할때 (돌다리 두드려볼때)"></a>객체를 할당한 변수의 타입을 재확인할때 (돌다리 두드려볼때)</h5><p>객체의 프로퍼티를 참조하려는 상황이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var elem &#x3D; null; </span><br><span class="line">&#x2F;&#x2F;elem 변수에는 객체가 할당되어있다고 예상했지만, null 인 상황을 가정</span><br><span class="line">var value &#x3D; elem &amp;&amp; elem.value;&#x2F;&#x2F; null</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; null 인 변수의 프로퍼티를 참조하려고하면 에러가 나기때문에 위와같이 에러 및 프로그램 종료를 방지할 수 있다.</span><br></pre></td></tr></table></figure>



<h5 id="함수-매개변수에-기본값을-설정할-때"><a href="#함수-매개변수에-기본값을-설정할-때" class="headerlink" title="함수 매개변수에 기본값을 설정할 때"></a>함수 매개변수에 기본값을 설정할 때</h5><ul>
<li>먼저 설명하자면, 매개변수가 있는 함수를 호출할 때 인수를 작성하지 않으면 undefined가 할당된다. 이로 인한 오류들을 방지하기 위해 사용 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function getStringLength(str)&#123;</span><br><span class="line">    str &#x3D; str || &#39;&#39;;</span><br><span class="line">    return str.length;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;문자열 길이를 측정하는 함수이다(웅모강사님 코드)</span><br><span class="line"></span><br><span class="line">getStringLength(); &#x2F;&#x2F;0</span><br><span class="line">&#x2F;&#x2F;undefined에서 length 프로퍼티를 참조하면 발생하는 에러를 방지한다.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;es6 에서는 다음과 같이 매개변수 기본값을 설정한다</span><br><span class="line">function getStringLength(str &#x3D; &#39;&#39;)&#123;</span><br><span class="line">    return str.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-2-옵셔널-체이닝-연산자"><a href="#3-2-옵셔널-체이닝-연산자" class="headerlink" title="3.2 옵셔널 체이닝 연산자"></a>3.2 옵셔널 체이닝 연산자</h3><p>3.1 에서 단축평가를 통해 <strong>객체를 할당한 변수의 타입을 재확인</strong>하는 과정이 있었다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var elem &#x3D; null; </span><br><span class="line"></span><br><span class="line">var value &#x3D; elem &amp;&amp; elem.value;&#x2F;&#x2F; null</span><br></pre></td></tr></table></figure>

<p>옵셔널 체이닝 연산자 ?. 도 이와 같은 방식이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var elem &#x3D; null; </span><br><span class="line"></span><br><span class="line">var value &#x3D; elem?.value;&#x2F;&#x2F; null</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;elem이 Truthy 값이면 value 참조를 이어간다.</span><br><span class="line">&#x2F;&#x2F; &amp;&amp;연산자와의 차이가 있다면 &amp;&amp;연산자 표현식은 단축평가의 특성을 이용했다면, ?.연산자 표현식은 프로퍼티 참조에 포커스를 둔 것?이다</span><br></pre></td></tr></table></figure>

<h4 id="기존-단축평가를-통한-프로퍼티참조의-문제점-개선"><a href="#기존-단축평가를-통한-프로퍼티참조의-문제점-개선" class="headerlink" title="기존 단축평가를 통한 프로퍼티참조의 문제점 개선"></a>기존 단축평가를 통한 프로퍼티참조의 문제점 개선</h4><p>&amp;&amp;연산자 표현식을 통한 객체 평가에서, 좌항이 0이나 ‘’이면 false로 평가되었다. 하지만 0, ‘’를 객체로 평가하는 경우도 있다. ?.연산자 표현식에서는 프로퍼티 참조에 있어서 이러한 문제를 개선하였다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var str &#x3D; &#39;&#39;;</span><br><span class="line">var length &#x3D; str &amp;&amp; str.length;</span><br><span class="line">console.log(length);&#x2F;&#x2F;&#39;&#39;</span><br><span class="line">&#x2F;&#x2F;0 을 기대하였지만 &#39;&#39;는 falsy 값이므로 &#39;&#39;그대로 반환된다.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;옵셔널 체이닝 연산자 ?.를 통해 이를 개선해보자</span><br><span class="line">var length &#x3D; str ?.length;</span><br><span class="line">console.log(length);&#x2F;&#x2F;0</span><br></pre></td></tr></table></figure>



<h3 id="3-3-null-병합-연산자"><a href="#3-3-null-병합-연산자" class="headerlink" title="3.3 null 병합 연산자"></a>3.3 null 병합 연산자</h3><p>3.1 에서 논리합연산자 (||) 를통한 단축평가와 비슷하지만 조금 다르게, 좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연산자를 반환하고 아닌 경우 좌항을 반환한다.</p>
<h4 id="연산자를-통한-단축평가와는-어떤-차이가-있을까"><a href="#연산자를-통한-단축평가와는-어떤-차이가-있을까" class="headerlink" title="|| 연산자를 통한 단축평가와는 어떤 차이가 있을까"></a>|| 연산자를 통한 단축평가와는 어떤 차이가 있을까</h4><ul>
<li>falsy 값 전부를 false 로 평가하여 우항을 반환하는 || 연산자 표현식과 다르게,</li>
<li>null 과 undefined인 경우에만 우항을 반환</li>
</ul>
<h5 id="‘’-이나-0을-유효한-값으로-판단"><a href="#‘’-이나-0을-유효한-값으로-판단" class="headerlink" title="‘’ 이나 0을 유효한 값으로 판단"></a>‘’ 이나 0을 유효한 값으로 판단</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; &#39;&#39; ?? &#39;falsy&#39;;</span><br><span class="line">console.log(foo); &#x2F;&#x2F; &#39;&#39;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jjm2317.github.io/2020/08/26/javascript-08ControlFlowStatement/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jeong Jiman">
      <meta itemprop="description" content="All Dev stories found in here.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeong Jiman's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/26/javascript-08ControlFlowStatement/" class="post-title-link" itemprop="url">javascript 08ControlFlowStatement</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-26 15:38:08" itemprop="dateCreated datePublished" datetime="2020-08-26T15:38:08+09:00">2020-08-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-09 22:28:56" itemprop="dateModified" datetime="2020-09-09T22:28:56+09:00">2020-09-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="제어문"><a href="#제어문" class="headerlink" title="제어문"></a>제어문</h1><ul>
<li>제어문(control flow statement)는 다음의 경우 사용<ul>
<li>주어진 조건에 따라 코드블록 실행(조건문)</li>
<li>코드블록을 반복 실행(반복문)</li>
</ul>
</li>
<li>코드의 실행흐름을 인위적으로 제어<ul>
<li>가장 심플한 것은 위에서 아래로 예외없이 동작</li>
<li>모던한 개발 방법론에서는 제어문을 별로 안 좋아한다. </li>
</ul>
</li>
</ul>
<h2 id="블록문"><a href="#블록문" class="headerlink" title="블록문"></a>블록문</h2><ul>
<li>0개 이상의 문을 중괄호로 묶은 것(문이 없을 수도 있다)</li>
<li>여러개의 문을 묶은 하나의 블록을 하나의 실행단위로 취급<ul>
<li>하나가 실행되면 블록내의 문이 다같이 실행된다는 뜻</li>
</ul>
</li>
<li>제어문과 함수 선언문 등에서 블록문이 사용된다.</li>
<li>자체 종결성(self closing)이 있어 끝에 세미콜론을 붙이지 않는다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">var num1 &#x3D;1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(num1&lt;2)&#123;</span><br><span class="line">num1++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function increase(num)&#123;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; &#123;&#125; 로 감싸진 코드 블록이 모두 블록문이다</span><br></pre></td></tr></table></figure>



<h2 id="1-조건문"><a href="#1-조건문" class="headerlink" title="1. 조건문"></a>1. 조건문</h2><p>조건문은 <strong>조건식</strong>과 실행할 <strong>코드블록</strong>의 조합으로 이루어져 있다.</p>
<ul>
<li>조건식이 어떤 <strong>값</strong>으로 평가되느냐에 따라 코드블록의 실행 여부가 결정된다.</li>
<li>조건식은 불리언(boolean)값으로 평가되며 boolean 타입이 아닌 표현식의 경우 boolean 값으로 암묵적 타입변환된다. </li>
</ul>
<h3 id="상반되는-두가지-조건의-경우-if-else-문을-사용하자"><a href="#상반되는-두가지-조건의-경우-if-else-문을-사용하자" class="headerlink" title="상반되는 두가지 조건의 경우 if else 문을 사용하자"></a>상반되는 두가지 조건의 경우 if else 문을 사용하자</h3><ul>
<li>주어진 조건식이 true 인 경우 실행할 코드블록, false인 경우 실행할 코드 블록이 있는 경우 if else 문을 주로 활용한다.</li>
</ul>
<h4 id="사용예시는-다음과-같다"><a href="#사용예시는-다음과-같다" class="headerlink" title="사용예시는 다음과 같다"></a>사용예시는 다음과 같다</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var score,grade;</span><br><span class="line">if(score&gt;&#x3D;70)&#123;</span><br><span class="line">    grade &#x3D; &#39;P&#39;;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    grade &#x3D; &#39;F&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="조건을-추가할-경우-else-if-문을-사용하자"><a href="#조건을-추가할-경우-else-if-문을-사용하자" class="headerlink" title="조건을 추가할 경우 else if 문을 사용하자"></a>조건을 추가할 경우 else if 문을 사용하자</h3><ul>
<li>조건식이 여러개라면 else if 문을 사용</li>
</ul>
<h4 id="else-if-문의-사용예시는-다음과-같다"><a href="#else-if-문의-사용예시는-다음과-같다" class="headerlink" title="else if 문의 사용예시는 다음과 같다"></a>else if 문의 사용예시는 다음과 같다</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var score,grade;</span><br><span class="line">if(score &gt;&#x3D; 80)&#123;</span><br><span class="line">    grade &#x3D; &#39;A&#39;;</span><br><span class="line">&#125;else if(score &gt;&#x3D; 60)&#123;</span><br><span class="line">    grade &#x3D; &#39;B&#39;;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    grade &#x3D; &#39;C&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="기타사항"><a href="#기타사항" class="headerlink" title="기타사항"></a>기타사항</h3><ul>
<li>else, else if 는 필수가 아니라 선택이다. 사용하지 않아도 상관없으며 상황에 따라 추가해서 사용하도록 하자</li>
<li>코드블록내에 문이 하나면 중괄호를 생략가능하다.</li>
<li>if else 문은 삼항 조건 연산자로 바꾸어 쓸 수 있다.</li>
</ul>
<h3 id="if-else문은-삼항-조건-연산자로-바꿔-쓸-수-있다"><a href="#if-else문은-삼항-조건-연산자로-바꿔-쓸-수-있다" class="headerlink" title="if else문은 삼항 조건 연산자로 바꿔 쓸 수 있다."></a>if else문은 삼항 조건 연산자로 바꿔 쓸 수 있다.</h3><ul>
<li>if else 문, 삼항 조건 연산자 모두 조건과 그에따른 결과 값이 두가지 이므로 동일하게 구현할 수 있다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var score,grade;</span><br><span class="line">if(score&gt;&#x3D;70)&#123;</span><br><span class="line">    grade &#x3D; &#39;P&#39;;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    grade &#x3D; &#39;F&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 위 제어문을 삼항조건 연산자로 써보자</span><br><span class="line">grade &#x3D; score &gt;&#x3D; 70 ? &#39;P&#39; : &#39;F&#39;; </span><br></pre></td></tr></table></figure>

<p>그렇다면 조건이 3개 이상인 else if 문은 어떻게 삼항 조건 연산자로 구현 할 수 있을까??</p>
<h4 id="조건이-여러개인-else-if-문을-삼항-조건연산자로-바꾸려면"><a href="#조건이-여러개인-else-if-문을-삼항-조건연산자로-바꾸려면" class="headerlink" title="조건이 여러개인 else if 문을 삼항 조건연산자로 바꾸려면.."></a>조건이 여러개인 else if 문을 삼항 조건연산자로 바꾸려면..</h4><ul>
<li>다음과 같은 방법을 따른다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var score,grade;</span><br><span class="line">if(score &gt;&#x3D; 80)&#123;</span><br><span class="line">    grade &#x3D; &#39;A&#39;;</span><br><span class="line">&#125;else if(score &gt;&#x3D; 60)&#123;</span><br><span class="line">    grade &#x3D; &#39;B&#39;;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    grade &#x3D; &#39;C&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 위 코드를 삼항 조건 연산자로 구현해보자.</span><br><span class="line">grade &#x3D; score &gt;&#x3D; 80 ? &#39;A&#39; : (score &gt;&#x3D; 60 ? &#39;B&#39; : &#39;C&#39;);</span><br></pre></td></tr></table></figure>

<ul>
<li>조건 하나하나 순차적으로 분리해 작성하면 된다</li>
</ul>
<h3 id="if-else-문-이외에-조건이-여러개인-경우-사용할-수-있는-조건문-switch-문"><a href="#if-else-문-이외에-조건이-여러개인-경우-사용할-수-있는-조건문-switch-문" class="headerlink" title="if else 문 이외에, 조건이 여러개인 경우 사용할 수 있는 조건문 : switch 문"></a>if else 문 이외에, 조건이 여러개인 경우 사용할 수 있는 조건문 : switch 문</h3><ul>
<li>조건이 여러개일때 if else 문과 switch 문을 주로 사용하는데, 사용하는 상황은 다르다.</li>
<li>if else 문은 조건식의 <strong>논리적 참, 거짓</strong>을 따질때 사용한다.</li>
<li>switch 문은 <strong>주어진 표현식의 case</strong>에 따라 실행할 문을 나눌때 사용한다.</li>
</ul>
<h4 id="switch문의-사용예시"><a href="#switch문의-사용예시" class="headerlink" title="switch문의 사용예시"></a>switch문의 사용예시</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; if else 문은 조건식의 논리적 참거짓을 판단한다.</span><br><span class="line">var score,grade;</span><br><span class="line">if(score &gt;&#x3D; 80)&#123;</span><br><span class="line">    grade &#x3D; &#39;A&#39;;</span><br><span class="line">&#125;else if(score &gt;&#x3D; 60)&#123;</span><br><span class="line">    grade &#x3D; &#39;B&#39;;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    grade &#x3D; &#39;C&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; switch 문은 주어진 표현식의 평가값에 따라 case 문을 실행한다.</span><br><span class="line">var score, grade;</span><br><span class="line"></span><br><span class="line">switch(score)&#123;</span><br><span class="line">    case 5 : grade &#x3D; &#39;A&#39;;break;</span><br><span class="line">    case 4 : grade &#x3D; &#39;B&#39;;break</span><br><span class="line">    case 3 : grade &#x3D; &#39;C&#39;;break;</span><br><span class="line">    case 2 : grade &#x3D; &#39;D&#39;;break;</span><br><span class="line">    case 1 : grade &#x3D; &#39;E&#39;;break;</span><br><span class="line">    default: grade &#x3D; null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="break-로-case-문을-마무리해주는-것에-주의하자"><a href="#break-로-case-문을-마무리해주는-것에-주의하자" class="headerlink" title="break 로 case 문을 마무리해주는 것에 주의하자"></a>break 로 case 문을 마무리해주는 것에 주의하자</h4><p>case 문을 실행하고 break 문으로 switch 문을 탈출하지 않는다면 다음 case 문, default 문까지 연이어 실행하게되는 상황이 발생한다. 이러한 상황을 fall through 라고 한다.</p>
<p>그러므로 실행하고자 하는 case 문이 끝났다면 <strong>break 키워드</strong>로 제어문을 탈출해주도록 하자</p>
<p> break 키워드는 코드블록을 탈출한다는 의미가 있다.</p>
<ul>
<li>기타사항<ul>
<li>fall through 현상을 이용해서 코드를 작성하는 경우도 있다. </li>
<li>일반적으로 default 문에는 break 키워드를 사용하지 않는다. default가 switch 문의 마무리를 암시하기 때문이다.</li>
</ul>
</li>
</ul>
<h4 id="폴-스루-fall-through-를-이용한-제어문-작성-예시"><a href="#폴-스루-fall-through-를-이용한-제어문-작성-예시" class="headerlink" title="폴 스루(fall through) 를 이용한 제어문 작성 예시"></a>폴 스루(fall through) 를 이용한 제어문 작성 예시</h4><ul>
<li><p>월별 일 수를 나타내는 switch 문을 작성해보자.</p>
</li>
<li><p>추가적으로 윤년 판별을 삼항 조건연산자로 작성해보자</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var year, month, days;</span><br><span class="line">​&#96;&#96;&#96;</span><br><span class="line">&#x2F;&#x2F; year, month, days에 값을 할당</span><br><span class="line">​&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">switch(month)&#123;</span><br><span class="line">    case 1: case 3: case 5: case 7: case 8: case 10: case 12:</span><br><span class="line">    days &#x3D;31;</span><br><span class="line">    break;</span><br><span class="line">    case 4: case 6: case 9: case 11:</span><br><span class="line">    days &#x3D;30;</span><br><span class="line">    break;</span><br><span class="line">    case 2:</span><br><span class="line">    &#x2F;&#x2F;윤년 판별하기</span><br><span class="line">    &#x2F;&#x2F; 1. 연도가 4로 나누어떨어지는 해(2000, 2004, 2008, 2012, 2016, 2020...)는 윤년이다.</span><br><span class="line">    &#x2F;&#x2F; 2. 연도가 4로 나누어떨어지더라도 연도가 100으로 나누어떨어지는 해(2000, 2100, 2200...)는 평년이다.</span><br><span class="line">    &#x2F;&#x2F; 3. 연도가 400으로 나누어떨어지는 해(2000, 2400, 2800...)는 윤년이다.</span><br><span class="line">    </span><br><span class="line">    days &#x3D; year%4&#x3D;&#x3D;&#x3D;0 ? (year%100&#x3D;&#x3D;&#x3D;0 ? (year%400 &#x3D;&#x3D;&#x3D; 0 ? 29 : 28) : 29) : 28;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 위는 일감으로 써본건데 좀 긴 것 같다.</span><br><span class="line">    &#x2F;&#x2F; 한번의 조건식 평가로 값을 도출하도록 작성해보자</span><br><span class="line">    &#x2F;&#x2F; days &#x3D; (year%4&#x3D;&#x3D;&#x3D;0)&amp;&amp;(year%100!&#x3D;&#x3D;0 || year%400&#x3D;&#x3D;&#x3D;0) ? 29 : 28;</span><br><span class="line">    &#x2F;&#x2F; 이웅모 강사님의 코드는?</span><br><span class="line">    &#x2F;&#x2F;  days &#x3D; ((year % 4 &#x3D;&#x3D;&#x3D; 0 &amp;&amp; year % 100 !&#x3D;&#x3D; 0) || (year % 400 &#x3D;&#x3D;&#x3D; 0)) ? 29 : 28;break;</span><br><span class="line">    </span><br><span class="line">    default :</span><br><span class="line">        console.log(&#39;month 제대로 치세요&#39;)   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="2-반복문"><a href="#2-반복문" class="headerlink" title="2. 반복문"></a>2. 반복문</h2><ul>
<li><strong>조건식의 평가 값이 true</strong> 인경우 <strong>코드블록을 반복적으로</strong> 실행</li>
<li>조건식의 평가 값이 false 면 반복문을 탈출한다.</li>
<li>세가지 반복문이 있다<ul>
<li>for 문</li>
<li>while 문</li>
<li>do while 문</li>
</ul>
</li>
</ul>
<h3 id="for-문"><a href="#for-문" class="headerlink" title="for 문"></a>for 문</h3><ul>
<li>조건식 평가 값이 false 일때까지 코드블록 반복 실행</li>
<li>함수형 프로그래밍하고는 잘 안맞는다.<ul>
<li>괄호 안에 변수가 만들어지기 때문</li>
</ul>
</li>
<li>실행순서가 특이하다</li>
</ul>
<h4 id="for-문은-어떻게-동작할까"><a href="#for-문은-어떻게-동작할까" class="headerlink" title="for 문은 어떻게 동작할까"></a>for 문은 어떻게 동작할까</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var sum &#x3D; 0;</span><br><span class="line">for(var i &#x3D; 1; i&lt;&#x3D;10; i++)&#123;</span><br><span class="line">    sum+&#x3D;i;</span><br><span class="line">&#125;</span><br><span class="line">console.log(sum); &#x2F;&#x2F; 55</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;위 예제에서의 반복문</span><br><span class="line">for(var i &#x3D; 1; i&lt;&#x3D;10; i++)&#123;</span><br><span class="line">    sum+&#x3D;i;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;for(변수선언문;조건식;증감식)&#123;실행할 코드블록&#125; 의 방법으로 이용</span><br><span class="line">&#x2F;&#x2F;for(1번;2번;3번)&#123;4번&#125; 작동순서는 아래와 같다</span><br><span class="line">&#x2F;&#x2F;1번 2번 4번 3번 2번(2번이 계속해서 참이면) 4번 3번 2번 4번 3번 &#x2F;&#x2F;2번(2번이 거짓이면) 반복문 끝</span><br></pre></td></tr></table></figure>



<h4 id="좀-더-자세히-for문의-안이-어떻게-동작하는지를-중심으로"><a href="#좀-더-자세히-for문의-안이-어떻게-동작하는지를-중심으로" class="headerlink" title="좀 더 자세히? for문의 () 안이 어떻게 동작하는지를 중심으로"></a>좀 더 자세히? for문의 () 안이 어떻게 동작하는지를 중심으로</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(문1 ; 문2 ; 문3)&#123; 코드블록4&#125;</span><br></pre></td></tr></table></figure>

<p>for 문의  () 안에는 <strong>일반적으로</strong> 3개의 문이 들어간다.  </p>
<p><strong>조건식 평가 값이 false 일때까지 코드블록 반복 실행</strong> 하는 것이 for 문의 목적이다. 문1~3 으로 <strong>조건식의 평가와 코드블록의 반복여부</strong>를 결정한다.</p>
<p>for 문에서 코드 실행 순서는 문1 - 문2 - 코드블록4 - 문3 순이다.</p>
<ul>
<li>문1 : for 문 첫실행 시 한번만 실행되는 문. 보통 반복을 결정하는데 쓰일 변수를 선언한다.</li>
<li>문2 : 두번째로 실행되는 문. <strong>boolean 값으로 평가</strong>되어 true인경우 코드블록 4를 실행한다.  </li>
<li>코드블록 4 : 문2가 true 로 평가되면 실행된다. 문 2가 false 면 실행 안됨.</li>
<li>문3 : 코드블록 4 실행이 끝나면 실행되는 문. 보통 문 1에서 선언한 변수의 증감식을 삽입한다.</li>
</ul>
<h4 id="for-의-안의-3가지-문에-대한-실험"><a href="#for-의-안의-3가지-문에-대한-실험" class="headerlink" title="for 의 () 안의 3가지 문에 대한 실험"></a>for 의 () 안의 3가지 문에 대한 실험</h4><h5 id="먼저-문1에-대해서"><a href="#먼저-문1에-대해서" class="headerlink" title="먼저 문1에 대해서"></a>먼저 문1에 대해서</h5><ul>
<li>전역변수로 어떤 변수를 선언했고 그 변수를 문2의 조건식에 이용한다면 문1 을 비워두어도 된다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var i&#x3D;0</span><br><span class="line">for( ; i&lt;10; i++)&#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;&#x2F;&#x2F;0 1 2 ~~~ 9</span><br><span class="line">console.log(i);&#x2F;&#x2F;10, </span><br><span class="line">&#x2F;&#x2F;다른얘기이지만, ()안에서 i를 선언해도 console.log(i)가 10이다.var 키워드의 특성때문이다.</span><br></pre></td></tr></table></figure>

<ul>
<li>문 1에는 표현식인 문과 표현식이 아닌 문 전부 들어갈 수 있다.<ul>
<li>선언문 작성이 가능하며, 할당문 작성역시 가능하다.</li>
</ul>
</li>
</ul>
<h5 id="문2-에-대해서"><a href="#문2-에-대해서" class="headerlink" title="문2 에 대해서"></a>문2 에 대해서</h5><ul>
<li><strong>boolean 값</strong>으로 평가된다(중요!)<ul>
<li>boolean 값으로 평가되지 않는 표현식도 암묵적 타입변환</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">for(var i&#x3D;0; i&#x3D;0; i++)&#123;</span><br><span class="line">    console.log(&#39;코드블록 실행&#39;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#39;코드블록 미실행&#39;);</span><br><span class="line">&#x2F;&#x2F; 코드블록 미실행</span><br><span class="line">&#x2F;&#x2F; i&#x3D;0 이라는 할당문은 0으로 평가되어 false로 암묵적 변환된다.</span><br><span class="line"></span><br><span class="line">for(var i&#x3D;0; i&#x3D;&#x3D;&#x3D;0; i++)&#123;</span><br><span class="line">    console.log(&#39;코드블록 실행&#39;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 코드블록 실행</span><br><span class="line">&#x2F;&#x2F; i&#x3D;&#x3D;&#x3D;0은 true 이다.</span><br><span class="line"></span><br><span class="line">for(;1;)&#123;</span><br><span class="line">    console.log(&#39;무한루프&#39;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 무한루프~~~~ </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2번째 문은 boolean 값으로 평가된다는 점 꼭 기억하자</span><br></pre></td></tr></table></figure>



<h5 id="문3-에-대해서"><a href="#문3-에-대해서" class="headerlink" title="문3 에 대해서"></a>문3 에 대해서</h5><ul>
<li>3번째 문에는 <strong>표현식인 문</strong>이 위치 할 수 있다.</li>
<li>문3은 별로 궁금한게 없어서 별거 안했다.</li>
</ul>
<h5 id="for-문은-안의-문들과-코드블록의-실행순서-각문의-특징만-알면-끝난다"><a href="#for-문은-안의-문들과-코드블록의-실행순서-각문의-특징만-알면-끝난다" class="headerlink" title="for 문은 ()안의 문들과 코드블록의 실행순서, 각문의 특징만 알면 끝난다."></a>for 문은 ()안의 문들과 코드블록의 실행순서, 각문의 특징만 알면 끝난다.</h5><ul>
<li><p>여기까지 공부한 바로는 그렇다.</p>
</li>
<li><p>혼자 가설 세우고 검증해봤지만 나중에 사양을 직접 살펴보자</p>
</li>
</ul>
<h3 id="while-문"><a href="#while-문" class="headerlink" title="while 문"></a>while 문</h3><ul>
<li>for 문과 마찬가지로 while문 역시 <strong>조건식 평가결과가 참</strong>이면 <strong>코드블록 반복실행</strong></li>
<li>for 문과는 어떤 차이?<ul>
<li>for 문은 반복횟수가 명확할때 사용</li>
<li>while 문은 반복횟수가 불명확할 때 사용</li>
</ul>
</li>
</ul>
<h4 id="for-문과-비슷하게-동작한다-다만-실행-순서가-조금-다르다"><a href="#for-문과-비슷하게-동작한다-다만-실행-순서가-조금-다르다" class="headerlink" title="for 문과 비슷하게 동작한다. 다만 실행 순서가 조금 다르다."></a>for 문과 비슷하게 동작한다. 다만 실행 순서가 조금 다르다.</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while(조건식)&#123;</span><br><span class="line">    실행할 문들</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 조건식을 먼저 평가하고 true 이면 코드블록을 실행한다.</span><br><span class="line">&#x2F;&#x2F; 조건식은 for의 문2와 마찬가지로 boolean 값으로 평가된다.</span><br><span class="line">&#x2F;&#x2F; 코드블록이 끝나면 다시 조건식을 평가한다. 조건식 평가 값이 false 일때 까지 반복실행</span><br></pre></td></tr></table></figure>



<h4 id="while문의-조건식이-항상-참이면-무한루프이다"><a href="#while문의-조건식이-항상-참이면-무한루프이다" class="headerlink" title="while문의 조건식이 항상 참이면, 무한루프이다."></a>while문의 조건식이 항상 참이면, 무한루프이다.</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var num &#x3D;0 ;</span><br><span class="line">while(1)&#123;</span><br><span class="line">    console.log(num++);</span><br><span class="line">&#125;&#x2F;&#x2F;0 1 2 3 4 5 6 ~~ 무한루프가 걸렸다</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;보통 break 키워드로 반복문을 탈출한다.</span><br><span class="line"></span><br><span class="line">var num &#x3D;0;</span><br><span class="line">while(1)&#123;</span><br><span class="line">    console.log(num++);</span><br><span class="line">    if(num&#x3D;&#x3D;&#x3D;10)&#123;break;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>



<h3 id="do-while-문"><a href="#do-while-문" class="headerlink" title="do while 문"></a>do while 문</h3><ul>
<li>마찬가지이다. 실행순서만 조금 다르다.<ul>
<li>코드블록을 먼저 실행하고 조건식을 평가한다.</li>
<li>일단 실행한다는데에 의의가 있다.</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var num &#x3D;1;</span><br><span class="line"></span><br><span class="line">do&#123;</span><br><span class="line">    console.log(num++);</span><br><span class="line">&#125;while(num&lt;10)</span><br><span class="line">&#x2F;&#x2F; 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>



<h2 id="3-break-문"><a href="#3-break-문" class="headerlink" title="3. break 문"></a>3. break 문</h2><h3 id="일부-코드블록을-탈출하는-break-문"><a href="#일부-코드블록을-탈출하는-break-문" class="headerlink" title="일부 코드블록을 탈출하는 break 문"></a>일부 코드블록을 탈출하는 break 문</h3><ul>
<li><p>break 문으로 탈출할 수 있는 문은 다음과 같다.</p>
<ul>
<li>레이블 문</li>
<li>반복문(for, for in , for of, while, do while)</li>
<li>switch 문</li>
</ul>
</li>
<li><p>위 문 이외의 문에서는 동작안함 (SyntaxError)</p>
<ul>
<li><pre><code>if(1)&#123;
    break;
&#125;//SyntaxError
//if 문에서 동작 안함
//바깥의 코드블록을 탈출
&lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### 레이블문이란? &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- 식별자가 붙은 문이다.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- 레이블 문의 식별자에는 따로 키워드를 안붙여도 되는듯하다.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;##### 레이블 문의 사용예시&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;
for(var i =0; i&lt;10; i++)&#123;
for(var j =0; j&lt;10; j++)&#123;
    if (i===3 &amp;&amp; j===3)&#123;
        break;
    &#125;
&#125;
&#125;
console.log(i, j);// 10 10
// 내부 for 문만 탈출 했기때문에 외부 for 문으로 다시 돌아가 반복 실행한다. 
</code></pre>
</li>
</ul>
</li>
</ul>
<p>//3 3 의결과를 얻고 싶다면 레이블 문을 이용하자.</p>
<p>all : for(var i =0; i&lt;10; i++){<br>    for(var j =0; j&lt;10; j++){<br>        if (i===3 &amp;&amp; j===3){<br>            break all;<br>        }<br>    }<br>}<br>console.log(i, j); // 3 3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">레이블 문 사용 시 코드 가독성이 나빠져서 잘 사용 안한다고 한다.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 4. continue 문</span><br><span class="line"></span><br><span class="line">- 반복문의 증감식으로 바로 이동시킨다. </span><br><span class="line">- 탈출은 아니다.</span><br><span class="line"></span><br><span class="line">### continue 문 사용예시</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>// 1~10에서 홀수만 출력해보자</p>
<p>for(var i=0;i&lt;10;i++){<br>    if(i%2===0)continue;<br>    console.log(i);<br>}<br>//위와 같이 continue 문을 사용할 수 있다.</p>
<p>// 위코드는 아래와 같은 결과이다.<br>for(var i=0;i&lt;10;i++){<br>    if(i%2!==0){<br>     console.log(i);<br>    }<br>}<br>// continue 문을 썼을 때보다 더 가독성이 좋아보인다.<br>// continue 문은 본래 코드의 if 문 내의 실행코드가 많을 때 사용하면 효율적이다.</p>
<pre><code></code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jeong Jiman</p>
  <div class="site-description" itemprop="description">All Dev stories found in here.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jeong Jiman</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
