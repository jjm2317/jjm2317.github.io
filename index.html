<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jjm2317.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="All Dev stories found in here.">
<meta property="og:type" content="website">
<meta property="og:title" content="Jeong Jiman&#39;s blog">
<meta property="og:url" content="https://jjm2317.github.io/index.html">
<meta property="og:site_name" content="Jeong Jiman&#39;s blog">
<meta property="og:description" content="All Dev stories found in here.">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jeong Jiman">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://jjm2317.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Jeong Jiman's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jeong Jiman's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Awesome node.jser..</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jjm2317.github.io/2020/09/23/javascript-15let-const-BlockLevelScope/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jeong Jiman">
      <meta itemprop="description" content="All Dev stories found in here.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeong Jiman's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/23/javascript-15let-const-BlockLevelScope/" class="post-title-link" itemprop="url">let, const & BlockLevelScope</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-09-23 19:53:38 / Modified: 19:55:34" itemprop="dateCreated datePublished" datetime="2020-09-23T19:53:38+09:00">2020-09-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="let-const와-블록-레벨-스코프"><a href="#let-const와-블록-레벨-스코프" class="headerlink" title="let, const와 블록 레벨 스코프"></a>let, const와 블록 레벨 스코프</h1><h2 id="1-var-키워드로-선언한-변수의-문제점"><a href="#1-var-키워드로-선언한-변수의-문제점" class="headerlink" title="1. var 키워드로 선언한 변수의 문제점"></a>1. var 키워드로 선언한 변수의 문제점</h2><p><strong>ES5 까지의 변수 선언</strong></p>
<p>ES5까지 변수를 선언할 수 있는 유일한 방법은 var 키워들ㄹ 사용하는 것이었다. var 키워드로 선언된 변수는 다른 언어와는 구별되는 독특한 특징이 있으며, 주의를 기울이지 않으면 심각한 문제를 발생시킬 수 있다.</p>
<h3 id="1-1-변수-중복-선언-허용"><a href="#1-1-변수-중복-선언-허용" class="headerlink" title="1.1 변수 중복 선언 허용"></a>1.1 변수 중복 선언 허용</h3><p><strong>중복 선언시 var 키워드가 없는 것처럼 동작</strong></p>
<p>var 키워드로 선언한 변수는  중복선언이 가능하다.</p>
<ul>
<li>같은 스코프 내에서 중복 선언이 가능하다.</li>
<li>초기화문이 있는 변수 선언문은 자바 스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작한다.</li>
<li>초기화문이 없는 변수 선언문을 중복선언하면 무시된다. </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var x &#x3D; 1;</span><br><span class="line">var y &#x3D; 1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;같은 스코프 내 중복 선언 허용</span><br><span class="line">&#x2F;&#x2F; var 키워드가 없는 것처럼 동작</span><br><span class="line">var x &#x3D; 100;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;초기화 문이 없으면 무시, 에러x</span><br><span class="line">var y;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;x : 100, y : 1</span><br></pre></td></tr></table></figure>

<p><strong>문제점</strong></p>
<p>동일한 이름의 변수가 이미 선언되어 있는 것을 모르고 변수를 중복 선언 하면서 값까지 할당했다면 의도치 않게 먼저 선언된 변수 값이 변경 되는 부작용 발생</p>
<h3 id="1-2-함수-레벨-스코프"><a href="#1-2-함수-레벨-스코프" class="headerlink" title="1.2 함수 레벨 스코프"></a>1.2 함수 레벨 스코프</h3><p><strong>함수의 코드 블록만을 스코프로 인정</strong></p>
<p>var 키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다. 따라서 함수 외부에서 var 키워드로 선언한 변수는 코드 블록 내에서 선언해도 모두 전역 변수가 된다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var x &#x3D; 1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;함수 외 코드블록은 스코프로 인정하지 않는다.</span><br><span class="line">&#x2F;&#x2F;x 변수 중복된다</span><br><span class="line">if(true) &#123;</span><br><span class="line">    var x &#x3D; 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(x); &#x2F;&#x2F;10</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;for 문도 마찬가지</span><br><span class="line">for(var i &#x3D; 0; i&lt;5; i++)&#123;</span><br><span class="line">console.log(i); &#x2F;&#x2F;0 1 2 3 4 </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>문제점</strong></p>
<p>함수 레벨 스코프를 인지 못하고 전역 변수를 선언하게 된다. 그러면 의도치 않게 변수값을 변경할 수 있다.</p>
<h3 id="1-3-변수-호이스팅"><a href="#1-3-변수-호이스팅" class="headerlink" title="1.3 변수 호이스팅"></a>1.3 변수 호이스팅</h3><p><strong>변수 호이스팅으로 초기화까지 일어난다.</strong></p>
<p>var 키워드로 변수를 선언하면 변수 호이스팅에 의해 변수 선언문이 스코프의 선두로 끌어 올려진 것처럼 동작한다. 즉, 변수 호이스팅에 의해 var 키워드로 선언한 변수는 변수 선언문 이전에 참조할 수 있다. 변수 할당문 이전에 변수를 참조하면 undefined를 반환한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.log(num);&#x2F;&#x2F;undefined</span><br><span class="line"></span><br><span class="line">num &#x3D; 100;</span><br><span class="line"></span><br><span class="line">console.log(num);100</span><br><span class="line"></span><br><span class="line">var num;</span><br></pre></td></tr></table></figure>

<p><strong>var 변수 호이스팅의 문제점</strong></p>
<p>변수 선언문 이전에 변수를 참조하는 것은 변수 호이스팅에 의해 에러를 발생시키지는 않는다 하지만 다음과 같은 문제가 있다.</p>
<ul>
<li>프로그램의 흐름상 맞지 않다.</li>
<li>가독성을 떨어뜨린다.</li>
<li>오류 발생 가능성이 높아진다.</li>
</ul>
<h2 id="2-let-키워드"><a href="#2-let-키워드" class="headerlink" title="2. let 키워드"></a>2. let 키워드</h2><p><strong>let 과 const의 도입</strong></p>
<p>var 키워드의 여러 문제점을 보완하기 위해서 ES6에서는 새로운 변수 선언 키워드가 추가 되었다. </p>
<ul>
<li>let</li>
<li>const</li>
</ul>
<p>var 키워드와의 차이를 알아보자</p>
<h3 id="2-1-변수-중복-선언-금지"><a href="#2-1-변수-중복-선언-금지" class="headerlink" title="2.1 변수 중복 선언 금지"></a>2.1 변수 중복 선언 금지</h3><p><strong>let 키워드는 중복 선언 미허용</strong></p>
<p>var 키워드로 이름이 동일한 변수를 중복 선언하면 아무런 에러를 발생하지 않는다. 인간은 실수하는 동물이기에 의도치않게, 실수로 값을 재할당 할 수도 있다. 즉, 오류 발생 가능성이 높아진다. </p>
<p>let 키워드의 경우 이름이 같은 변수를 중복 선언 하면 문법 에러(SyntaxError) 를 발생시킨다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var num1 &#x3D; 100;</span><br><span class="line">var num1 &#x3D; 200;</span><br><span class="line">&#x2F;&#x2F;var 키워드로 선언된 변수는 중복선언 허용</span><br><span class="line">&#x2F;&#x2F;중복 선언시 var 키워드가 없는 것처럼 동작</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let num2 &#x3D; 123;</span><br><span class="line">let num2 &#x3D; 456;</span><br><span class="line"> &#x2F;&#x2F; let이나 const 키워드로 선언한 변수는 중복선언을 허용하지 않는다. </span><br></pre></td></tr></table></figure>



<h3 id="2-2-블록-레벨-스코프"><a href="#2-2-블록-레벨-스코프" class="headerlink" title="2.2 블록 레벨 스코프"></a>2.2 블록 레벨 스코프</h3><p><strong>let , const 키워드는 블록 레벨 스코프를 따른다</strong></p>
<p>var 키워드로 선언된 변수는 오로지 함수의 코드 블록만을 지역 스코프를 따른다. 하지만 let 키워드로 선언한 변수는 모든 코드블록을 지역 스코프로 인정한다. (함수, if 문, while 문, try/catch) 등을 지역 스코프로 인정하는 블록레벨 스코프를 따른다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let num &#x3D; 1;</span><br><span class="line">&#123;</span><br><span class="line">    let num &#x3D; 2;</span><br><span class="line">    let bar &#x3D; 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(num); &#x2F;&#x2F;2</span><br><span class="line">console.log(bar); &#x2F;&#x2F; ReferenceError</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2-3-변수-호이스팅"><a href="#2-3-변수-호이스팅" class="headerlink" title="2.3 변수 호이스팅"></a>2.3 변수 호이스팅</h3><p><strong>let 키워드로 선언한 변수의 호이스팅</strong></p>
<p>var 키워드로 선언한 변수와 달리 let 키워드로 선언한 변수는 변수호이스팅이 발생하지 않는 것처럼 동작한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(a); &#x2F;&#x2F;ReferenceError</span><br><span class="line">let foo;</span><br></pre></td></tr></table></figure>

<p>위와 같이 let 키워드로 선언한 변수를 선언문 이전에 참조하면 참조에러가 발생한다. </p>
<p><strong>이유</strong></p>
<p><strong>기존의 var 키워드의 변수 선언</strong></p>
<p>var 키워드로 선언한 변수는 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 선언단계와 초기화단계가 <strong>한번에</strong> 진행된다</p>
<ol>
<li>선언 단계에서 실행 컨텍스트의 렉시컬 환경에 변수 식별자를 등록해 자바스크립트 엔진에 변수의 존재를 알린다.</li>
<li>초기화 단계에서 undefined로 변수를 초기화한다.</li>
</ol>
<p>따라서 변수 선언문 이전에 변수에 접근해도 에러가 발생하지 않는다. 다만 의도한 값대신 undefined가 할당되어 있다. </p>
<p><strong>let 키워드의 선언단계와 초기화 단계</strong></p>
<p>let 키워드로 선언한 변수는 선언단계와 초기화 단계가 분리되어 진행된다. </p>
<ol>
<li>런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 선언 단계 실행</li>
<li><strong>런타임</strong>이 되어 변수선언문에 도달했을때 초기화 단계 실행</li>
</ol>
<p>런타임 이전에 초기화 단계를 실행 하지않으므로 변수선언문 이전에 참조하려고 하면 참조 에러가 발생한다.</p>
<p><strong>일시적 사각지대란</strong></p>
<p> let 키워드로 선언한 변수는 스코프의 시작 지점부터 초기화단계 시작 지점까지 변수를 참조할 수 없다. </p>
<p>스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간을 **일시적 사각지대(Temporal Dead Zone; TDZ)**라고 부른다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;일시적 사각지대</span><br><span class="line">console.log(foo); &#x2F;&#x2F;ReferenceError</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; &quot;&quot;</span><br><span class="line">let foo;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>let 키워드의 변수 호이스팅</strong></p>
<p>let 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는 것 같지만 그렇지 않다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let bar &#x3D; 1;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    console.log(bar); &#x2F;&#x2F;ReferenceError</span><br><span class="line">    </span><br><span class="line">    let bar &#x3D;10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>만일 변수 호이스팅이 발생하지 않는다면 bar를 출력했을때 전역에서 할당한 1이 출력되어야 정상이지만, 참조에러가 발생한다. </p>
<p>let 키워드도 스코프 시작전에 선언단계, 초기화단계 중 선언단계는 진행하기 때문이다. </p>
<h3 id="2-4-전역-객체와-let"><a href="#2-4-전역-객체와-let" class="headerlink" title="2.4 전역 객체와 let"></a>2.4 전역 객체와 let</h3><p><strong>var 키워드로 선언한 변수는 전역 객체의 프로퍼티가 된다.</strong> </p>
<p>var 키워드로 선언한 전역 변수, 전역 함수와 암묵적 전역은 전역 객체 window or global의 프로퍼티가 된다. 전역 객체의 프로퍼티를 참조할 땐 window를 생략가능하다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 전역변수</span><br><span class="line">var foo;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 전역 함수</span><br><span class="line">fuction bar() </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 암묵적 전역</span><br><span class="line">x &#x3D; 1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;위 모두 전역 객체 window의 프로퍼티</span><br><span class="line">&#x2F;&#x2F;선언 및 참조 시 window 식별자는 생략 가능</span><br></pre></td></tr></table></figure>



<p><strong>let 키워드는 전역 객체의 프로퍼티가 아니다.</strong></p>
<p>let 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아닌, 전역 렉시컬 환경의 선언적 환경 레코드에 존재하게 된다. </p>
<h2 id="3-const-키워드"><a href="#3-const-키워드" class="headerlink" title="3. const 키워드"></a>3. const 키워드</h2><h3 id="3-1-선언과-초기화"><a href="#3-1-선언과-초기화" class="headerlink" title="3.1 선언과 초기화"></a>3.1 선언과 초기화</h3><p><strong>const 키워드로 선언한 변수는 선언과 동시에 초기화한다.</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const foo &#x3D; 1;</span><br><span class="line"></span><br><span class="line">const bar; &#x2F;&#x2F; SyntaxError</span><br></pre></td></tr></table></figure>

<p>초기화 없이 선언만 하면 문법 에러가 발생한다. </p>
<p><strong>const, 스코프와 호이스팅</strong></p>
<p>const 키워드로 선언한 변수는 블록레벨 스코프를 가지며, 변수호이스팅이 발생하지 않는 것처럼 동작한다. </p>
<h3 id="3-2-재할당-금지"><a href="#3-2-재할당-금지" class="headerlink" title="3.2 재할당 금지"></a>3.2 재할당 금지</h3><p><strong>const 키워드로 선언한 변수는 재할당이 금지된다.</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const foo &#x3D; 10;</span><br><span class="line"></span><br><span class="line">foo &#x3D; 5;&#x2F;&#x2F; TypeError</span><br></pre></td></tr></table></figure>



<h3 id="3-3-상수"><a href="#3-3-상수" class="headerlink" title="3.3 상수"></a>3.3 상수</h3><p><strong>const 키워드의 이용</strong></p>
<p>원시값은 immutable value 이다. 그리고 const 키워드로 선언한 변수에 원시값을 할당한다면 <strong>재할당 없이</strong> 변수값을 변경할 수 없다. 그렇기 때문에 const 키워드를 이용해 상수를 표현할 수 있다.</p>
<p><strong>상수의 뜻</strong></p>
<p>변수의 상대 개념인 상수는 재할당이 금지된 변수를 말한다. 상수도 값을 저장하기 위한 메모리 공간이 필요하므로 변수이다. 일반적인 변수와는 달리 재할당이 금지된다. </p>
<p><strong>상수의 장점</strong></p>
<ul>
<li>상태를 유지한다</li>
<li>가독성이 높아진다</li>
<li>유지보수가 편하다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 세율같은 경우 쉽게 변하지 않으며, 고정값을 사용해야 한다.</span><br><span class="line">const TAX_RATE &#x3D; 0,1;</span><br><span class="line">let preTaxPrice &#x3D; 100;</span><br><span class="line"></span><br><span class="line">let afterTaxPrice &#x3D; preTaxPrice + (preTaxPrice * TAX_RATE)</span><br></pre></td></tr></table></figure>

<p>const 키워드로 선언한 변수에 원시값을 할당한다면 선언문 이후에 값을 변경할 수 없으며 상태가 유지된다.</p>
<p>또한 세율을 상수로 정의하여 의미를 쉽게 알 수 있다. 즉 가독성이 높아진다.</p>
<p>세율이 변경된다면 상수만을 변경하면 되므로 유지 보수성이 향상된다. </p>
<p><strong>상수의 일반적인 표기</strong></p>
<p>상수의 이름은 대문자로 선언해 상수임을 명확히 나타낸다.</p>
<p>여러개의 단어로 이루어진 경우 언더스코어로 구분한 스네이크 케이스로 표현한다. </p>
<h3 id="3-3-const-키워드와-객체"><a href="#3-3-const-키워드와-객체" class="headerlink" title="3.3 const 키워드와 객체"></a>3.3 const 키워드와 객체</h3><p><strong>객체의 경우 값의 변경이 가능하다.</strong></p>
<p>원시값의 경우 불변값이기 때문에 재할당없이 값의 변경이 불가하며, const로 선언한 경우 재할당까지도 불가하다. </p>
<p>하지만, 객체의 경우 가변 값 (mutable value) 이기 때문에 재할당없이도 값을 변경할 수 있다. </p>
<p>const 키워드는 재할당을 금지할 뿐이다.  객체는 자유롭게 변경될 수 있다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const student &#x3D; &#123;</span><br><span class="line">    name: &#39;Jiman&#39;,</span><br><span class="line">    age: 23</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">student.age &#x3D; 24;</span><br><span class="line">console.log(student)&#x2F;&#x2F; &#123;name: &#39;jiman&#39;, age: 24&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-var-vs-let-vs-const"><a href="#4-var-vs-let-vs-const" class="headerlink" title="4. var vs. let vs. const"></a>4. var vs. let vs. const</h2><p><strong>const 사용을 지향하자</strong></p>
<p>변수 선언에는 기본적으로 const를 사용하고 let은 재할당이 필요한 경우에만 사용하도록 하자. </p>
<p><strong>이유</strong></p>
<ul>
<li>변수를 선언하는 시점에는 재할당이 필요할 지 잘모르는 경우가 많다.</li>
<li>객체는 재할당하는 경우가 드물다</li>
<li>재할당이 꼭 필요하다면 그때 let 으로 바꾸자 </li>
</ul>
<p><strong>ES6 이상인 경우 var은 사용하지 말자</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jjm2317.github.io/2020/09/22/javascript-14Problem-of-GlobalVariable/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jeong Jiman">
      <meta itemprop="description" content="All Dev stories found in here.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeong Jiman's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/22/javascript-14Problem-of-GlobalVariable/" class="post-title-link" itemprop="url">javascript 14Problem of GlobalVariable</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-09-22 16:39:18 / Modified: 16:39:25" itemprop="dateCreated datePublished" datetime="2020-09-22T16:39:18+09:00">2020-09-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="전역-변수의-문제점"><a href="#전역-변수의-문제점" class="headerlink" title="전역 변수의 문제점"></a>전역 변수의 문제점</h1><p>전역변수는 사용을 지양하는 것이 좋다. 많은 문제를 야기하기 때문이다. 전역변수의 사용이 꼭 필요한 경우가 아니라면, 지역변수를 사용하도록 해야한다.  이는 변수의 생명주기와 관련이 있다. </p>
<h2 id="1-변수의-생명주기"><a href="#1-변수의-생명주기" class="headerlink" title="1. 변수의 생명주기"></a>1. 변수의 생명주기</h2><h3 id="1-1-지역-변수의-생명주기"><a href="#1-1-지역-변수의-생명주기" class="headerlink" title="1.1 지역 변수의 생명주기"></a>1.1 지역 변수의 생명주기</h3><p><strong>변수에도 생명주기(life cycle)가 있다</strong></p>
<p>변수는 선언에 의해 생성되고 할당에 의해 값을 갖는다. 그리고 언젠가 소멸된다. 변수에도 생물과 같이 생성되고 소멸되는 생명주기가 있다. </p>
<p>만약 변수에 생명주기가 없다면? 한번 선언된 변수는 프로그램자체를 종료하지 않는 한 계속 메모리 공간을 차지하고 있을 것이다. </p>
<p>변수는 자신의 선언된 위치(스코프) 에서 생성되고 소멸한다. 전역변수의 생명 주기는 애플리케이션의 생명 주기와 같다. 하지만 지역변수의 경우 함수가 호출되면 생성되고 함수가 종료하면 소멸한다. 다음 예제를 살펴보자</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">    const x &#x3D; &#39;local&#39;;</span><br><span class="line">    console.log(x); &#x2F;&#x2F; local</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;함수가 호출되면 함수foo의 지역스코프가 생성되고 해당 위치에서 식별자가 생성된다. foo 스코프 안에서 x는 foo의 지역변수여서 foo함수 몸체 내에서 참조할 수 있다.</span><br><span class="line">foo(); </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;전역에서는 x가 선언된 적이 없다. 스코프 체인에서 상위스코프에서 하위스코프의 변수를 참조할 수 없다. 다음과 같이 에러 발생</span><br><span class="line">console.log(x); &#x2F;&#x2F; ReferenceError: x is not defined</span><br></pre></td></tr></table></figure>



<p><strong>지역 변수가 생성되는 시점</strong></p>
<p>함수 몸체의 문들은 함수가 호출되어야 실행된다. 그렇기때문에 위 예제에서 지역변수 x에 대한 변수 선언문은 함수가 <strong>호출</strong>되기 전까지 생성되지 않는다.</p>
<p>전역변수의 경우 위치에 상관없이 가장 먼저 실행된다. 자바스크립트 엔진은 런타임 이전에 변수 선언을 완료한다. </p>
<p>단, 함수 내부에서 선언된 변수는 함수가 호출된 직후에 함수 몸체 내부의 문들이 실행되기 이전에, 엔진에 의해 가장먼저 실행된다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">    const x &#x3D; &#39;local&#39;;</span><br><span class="line">    console.log(x); &#x2F;&#x2F; local</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line">foo(); </span><br></pre></td></tr></table></figure>

<p>foo 함수를 호출하면 foo 함수 몸체 내부의 문들이 실행되기 이전에 변수 선언문이 가장 먼저 실행되어 x 변수가 선언된다. 그 후 함수 몸체를 구성하는 문들이 순차적으로 실행되기 시작하고 변수 할당문이 실행되면 x 변수에 값이 할당된다. </p>
<p><strong>지역변수가 소멸되는 시점</strong></p>
<p>위 예제에서 함수 foo 가 종료하면 변수 x도 소멸되어 생명주기가 종료된다. 함수 내부에서 선언된 지역변수 x는 foo 함수가 호출되어 실행되는 동안에만 유효하다. 즉, 지역변수의 생명주기는 함수의 생명주기와 일치한다. </p>
<p><strong>지역 변수가 함수보다 오래 생존하는 경우</strong></p>
<p>대부분의 지역변수의 경우 함수가 종료되면 같이 소멸한다. 하지만 특정한 경우에 함수보다 오래 생존할 수 있다.</p>
<p>변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름이다. </p>
<p>따라서, 변수의 생명주기는 메모리 공간이 확보된 시점부터 메모리 공간이 해제 되어 가용 메모리 풀에 반환되는 시점까지이다. </p>
<p>함수 내부에서 선언된 지역 변수는 함수가 생성한 스코프에 등록된다. 함수가 생성한 스코프는 렉시컬 환경이라 부르는 물리적인 실체가 있다. 따라서 변수는 자신이 등록된 스코프가 소멸될 때까지 유효하다. <strong>할당된 메모리 공간은 더 이상 참조하지 않을때</strong> 가비지 컬렉터에 의해 메모리 해제되어 가용메모리풀에 반환된다. </p>
<p>다시 말해, 메모리 공간이 참조되고 있다면 해당 메모리공간은 해제되지 않고 유효하다. 생성되었던 스코프의 경우에도 누군가 해당 스코프를 참조하고 있으면 소멸되지 않고 남아 있는다. </p>
<p>일반적으로 함수가 종료하면 함수가 생성한 스코프도 소멸한다. 하지만 누군가 스코프를 참조하고 있다면 스코프는 해제되지않고 생존하게 된다.  </p>
<p><strong>호이스팅은 스코프를 단위로 동작한다.</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let x &#x3D; &#39;global&#39;;</span><br><span class="line"></span><br><span class="line">function foo()&#123;</span><br><span class="line">    console.log(x); &#x2F;&#x2F; 초기화 에러 발생</span><br><span class="line">    let x &#x3D; &#39;local&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line">console.log(x); &#x2F;&#x2F; global</span><br></pre></td></tr></table></figure>

<p>foo 함수를 호출했을때 x를 출력하는 문에서 초기화에러가 발생한다. 호이스팅이 전역에서만 한번 일어난다면 global이 출력될 것으로 기대되나, 호이스팅은 스코프를 단위로 동작하기 때문에 스코프마다 일어난다. 그렇기 때문에 let변수의 특성상 선언만 되는 호이스팅이 일어나고 초기화가 안되어있으므로 초기화 에러를 발생시킨다.</p>
<p>지역변수의 호이스팅은 지역변수의 선언이 지역스코프의 선두로 끌어 올려진 것처럼 동작한다. 따라서 지역변수는 함수 호출, 스코프생성과 동시에 생성된다. 호이스팅을 다시 정의해 보면 변수 선언이 스코프의 선두로 끌어오려진 것처럼 동작하는 자바스크립트 고유의 특징이다. </p>
<h3 id="1-2-전역변수의-생명주기"><a href="#1-2-전역변수의-생명주기" class="headerlink" title="1.2 전역변수의 생명주기"></a>1.2 전역변수의 생명주기</h3><p><strong>자바스크립트의 전역코드는 명시적인 호출 없이 실행된다</strong></p>
<p>c나 java 같은 경우 main 함수를 호출함으로서 코드를 실행한다.  자바스크립트는 이와 달리, 함수호출과 같이 전역코드를 실행 하는 특별한 진입점(entry point)이 없이 코드가 로드되자마자 곧바로 해석되고 실행된다.</p>
<p>함수는 함수 몸체의 마지막 문 또는 반환문이 실행되면 종료한다. 하지만 전역코드는 반환문을 사용할 수 없으므로 마지막 문이 실행되어 더 이상 실행할 문이 없을 때 종료한다. </p>
<p><strong>전역 변수의 생명주기는 전역 객체의 생명주기와 일치</strong></p>
<p>지역 변수의 경우 생명주기가 함수의 생명주기와 일치하였다. 반면 var 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 된다. 이는 전역 변수의 생명주기가 <strong>전역 객체</strong>의 생명주기와 일치하는 것을 말한다. 브라우저 환경에서 전역 객체는 window 이므로 브라우저 환경에서 var 키워드로 선언한 전역 변수는 전역 객체 windwo 의 프로퍼티 이다. 전역 객체 window 는 웹 페이지를 닫기 전까지 유효하다. 따라서 브라우저 환경에서 var 키워드로 선언한 전역 변수 역시 웹페이지를 닫을 때 까지 유효하다. </p>
<p>전역 변수는 자바스크립트파일이 생성되자마자 태어나고 전역객체가 끝날때 (탭을 닫거나 브라우저를 닫거나) 죽는다. 다시말해, var 키워드로 서언한 전역 변수의 생명 주기는 전역 객체의 생명주기와 일치한다.  </p>
<p><strong>전역 객체(global object)란</strong></p>
<p>전역 객체는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체다. 전역 객체는 클라이언트 사이드 환경(브라우저)에서는 window, 서버 사이드 환경(Node.js)에서는 global 객체를 의미한다. 환경에 따라 전역 객체를 가리키는 다양한 식별자(windwo, self, this, frames, global)가 존재하였으나 ES11(ECMAScript 11)에서 globalThis로 통일되었다. </p>
<p>전역 객체에는 표준 빌트인 객체(Object, String, Number, Function, Array…)</p>
<p>와 환경에 따른 호스트 객체(클라이언트 Web API 또는 Node.js의 호스트 API), 그리고 var키워드로 선언한 전역 변수와 전역 함수를 프로퍼티로 갖는다. </p>
<h2 id="2-전역-변수의-문제점"><a href="#2-전역-변수의-문제점" class="headerlink" title="2. 전역 변수의 문제점"></a>2. 전역 변수의 문제점</h2><p><strong>암묵적 결합</strong></p>
<p>전역 변수를 선언한 의도는 전역, 즉 코드 어디서든 참조하고 할당할 수 있는 변수를 사용하겠다는 것이다. 이는 모든 코드가 전역 변수를 참조하고 변경할 수 있는 암묵적 결합(implicit coupling)을 허용하는 것이다. 변수의 유효범위가 크면 클수록 코드의 가독성은 나빠지고 의도치 않게 상태가 변경될 수 있는 위험성도 높아진다. </p>
<p><strong>긴 생명 주기</strong></p>
<p>전역 변수는 생명주기가 길다. 따라서 메모리 리소스도 오랜 기간 소비한다. 또한 전역 변수의 상태를 변경할 수 있는 시간도 길고 기회도 많다. </p>
<p>더욱이 var 키워드는 변수의 중복선언을 허용하므로 생명주기가 긴 전역 변수는 변수 이름이 중복될 가능성이 있다. 변수 이름이 중복되면 의도치 않은 재할당이 이뤄진다. </p>
<p>반면에, 지역 변수의 경우 전역 변수보다생명주기가 훨씬 짧다. 크지 않은 함수의 지역 변수는 생존 시간이 극히 짧다. 따라서 지역 변수의 상태를 변경할 수 있는 시간도 짧고 기회도 적다. 이는 전역 변수보다 상태 변경에 의한 오류가 발생할 확률이 작다는 것을 의미한다. 메모리 리소드도 짧은 기간만 소비한다.</p>
<p><strong>스코프 체인 상에서 종점에 존재</strong></p>
<p>변수를 검색할따 하위 스코프에서 상위스코프로 차례로 검색한다. 전역 변수는 스코프체인의 종점에 존재한다. 변수가 검색될때 우선순위가 가장 낮으므로 가장 마지막에 검색된다. 전역 변수는 검색속도가 가장 느리다는 뜻이다. 차이는 크지 않지만 속도의 차이가 있다.</p>
<p><strong>네임 스페이스 오염</strong></p>
<p>자바 스크립트 코드의 여러파일을 삽입하면 분리되어 있더라도 하나의 전역 스코프를 공유한다. 큰 문제점이라고 할 수 있다. 전역 스코프를 공유하기 때문에 다른 파일 내에서 동일한 이름으로 명명된 전역 변수나 전역 함수가 같은 스코프 내에 존재할 경우 예상치 못한 결과를 가져올 수 있다. </p>
<h2 id="3-전역-변수의-사용을-억제하는-방법"><a href="#3-전역-변수의-사용을-억제하는-방법" class="headerlink" title="3. 전역 변수의 사용을 억제하는 방법"></a>3. 전역 변수의 사용을 억제하는 방법</h2><p><strong>전역 변수대신 지역 변수를 사용해야된다</strong></p>
<p>전역 변수의 무분별한 사용은 위험하기 때문에 전역 변수를 반드시 사용해야 할 이유를 찾지 못했다면 지역 변수를 사용해야 한다. 변수의 스코프는 좁을수록 좋다. 전역 변수를 절대 사용하는 것은 불가능에 가까우므로 최대한 전역 변수의 사용을 억제하도록 해야한다. </p>
<p>전역 변수의 사용을 억제하는 방법은 다음과 같다.</p>
<h3 id="3-1-즉시-실행-함수"><a href="#3-1-즉시-실행-함수" class="headerlink" title="3.1 즉시 실행 함수"></a>3.1 즉시 실행 함수</h3><p>즉시 실행 함수의 특징을 이용한 꼼수이다. 즉시 실행 함수는 함수 정의와 동시에 호출되며, 단 한 번만 호출된다. 모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 된다. 이러한 특성을 이용해 전역 변수의 사용을 제한하는 방법이다. </p>
<p>이 방법을 사용하면 전역 변수를 생성하지 않으므로 라이브러리 등에 자주 사용된다. </p>
<h3 id="3-2-네임-스페이스-객체"><a href="#3-2-네임-스페이스-객체" class="headerlink" title="3,2 네임 스페이스 객체"></a>3,2 네임 스페이스 객체</h3><p>전역에 네임스페이스(namespace)  역할을 담당할 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티를 추가하는 방법이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const MYAPP &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">MYAPP.name &#x3D; &#39;Jeong&#39;;</span><br><span class="line"></span><br><span class="line">console.log(MYAPP.name) ; &#x2F;&#x2F; Jeong</span><br></pre></td></tr></table></figure>



<p>네임 스페이스 객체에 또 다른 네임 스페이스 객체를 프로퍼티로 추가해서 계층적으로 네임 스페이스를 구성할 수도 있다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const MYAPP &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">MYAPP.person &#x3D; &#123;</span><br><span class="line">name: &#39;Jeong&#39;,</span><br><span class="line">age: 23</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(MYAPP.person.age); &#x2F;&#x2F; 23</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>네임스페이스를 분리해서 식별자 충돌을 방지하는 효과는 있다. 하지만 객체 자체가 전역 변수에 할당되므로 그다지 유용하지 않다.</p>
<h3 id="3-3-모듈-패턴"><a href="#3-3-모듈-패턴" class="headerlink" title="3.3 모듈 패턴"></a>3.3 모듈 패턴</h3><p>모듈 패턴은 클래스를 모방해서 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만든다. 모듈 패턴은 자바스크립트의 강력한 기능인 클로져를 기반으로 동작한다. 모듈 패턴의 특징은 전역 변수의 억제는 물론 캡슐화까지 구현할 수 있다는 것이다. </p>
<p>**캡슐화(encapsulation)**는 객체의 상태(state)를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작(behavior)인 메서드를 하나로 묶는 것을 말한다. 캡슐화는 객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용하기도 하는데 이를 정보 은닉 (information hiding)이라고 한다.</p>
<p>대부분의 객체지향 프로그래밍 언어는 클래스를 구성하는 멤버에 대해 public, private, protected 등의 접근 제한자(access modifier )를 사용해 공개 범위를 한정할 수 있다. public 으로 선언된 데이터 또는 메서드는 외부에서 접근이 가능하지만 private으로 선언된 경우는 외부에서 접근할 수 없고 내부에서만 사용된다. </p>
<p>이것은 클래스 외부에는 제한된 접근 권한ㄴ을 제공하며 원하지 않는 외부의 접근으로부터 내부를 보호하는 기능을 한다.</p>
<p>하지만 자바 스크립트는 public, private, protected 등의 접근 제한자를 제공하지 않는다. 모듈 패턴은 전역 네임 스페이스의 오염을 막는 기능을 물론 한정적이기는 하지만 정보은닉을 구현하기 위해 사용한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const Counter &#x3D; (function() &#123;</span><br><span class="line">&#x2F;&#x2F;private 변수</span><br><span class="line">    let num &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;외부로 공개할 데이터나 메서드를 프로퍼티로 추가한 객체를 반환한다. </span><br><span class="line">    return &#123;</span><br><span class="line">        increase()&#123;</span><br><span class="line">            return ++num;</span><br><span class="line">        &#125;,</span><br><span class="line">        decrease()&#123;</span><br><span class="line">            return --num;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;private 변수는 외부로 노출되지 않는다. </span><br><span class="line">console.log(Counter.num); &#x2F;&#x2F; undefined</span><br><span class="line"></span><br><span class="line">console.log(Counter.increase()); &#x2F;&#x2F;1</span><br><span class="line"></span><br><span class="line">console.log(Counter.increase()); &#x2F;&#x2F;2</span><br><span class="line">console.log(Counter.decrease()); &#x2F;&#x2F; 1</span><br><span class="line">console.log(Counter.decrease()); &#x2F;&#x2F;0</span><br></pre></td></tr></table></figure>

<p>위 예제의 즉시 실행 함수는 객체를 반환한다. 이 객체에는 외부에 노출하고 싶은 변수나 함수를 담아 반환한다. 이때 반환되는 객체의 프로퍼티는 외부에 노출되는 퍼블릭 멤버(public member) 이다. 외부로 노출하고 싶지 않은 변수나 함수는 반환하는 객체에 추가하지 않으면 외부에서 접근할 수 없는 프라이빗 멤버(private member)가 된다.</p>
<h3 id="3-4-ES6-모듈"><a href="#3-4-ES6-모듈" class="headerlink" title="3.4 ES6 모듈"></a>3.4 ES6 모듈</h3><p><strong>ES6 모듈은 파일 자체의 독자적인 스코프 제공</strong></p>
<p>ES6 모듈을 사용하면 더는 전역 변수를 사용할 수 없다. ES 6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공한다. 즉, 모듈 내에서 var 키워드로 선언한 변수는 더는 전역 변수가 아니며 window 객체의 프로퍼티도 아니다.</p>
<p>모던 브라우저(Chrome 61, FF 60, SF 10.1, Edge 16 이상) 에서 ES6모듈을 사용할 수 있따. script 태그에 type = “module” 어트리뷰트를 추가하면 로드된 자바스크립트 파일은 모듈로서 동작한다. 모듈의 파일 확장자는 mjs를 권장한다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type &#x3D; &quot;module&quot; src &#x3D; &quot;lib.mjs&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type &#x3D; &quot;module&quot; src &#x3D; &quot;app.mjs&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>ES6 모듈은 IE를 포함한 구형 브라우저에서는 동작하지 않으며, 브라우저의 ES6 모듈 기능을 사용하더라도 트랜스파일링이나 번들링이 필요하기 때문에 아직까지는 브라우저가 지원하는 ES6 모듈 기능보다는 Webpack 등의 모듈 번들러를 사용하는 것이 일반적이다. </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jjm2317.github.io/2020/09/18/javascript-function-practice/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jeong Jiman">
      <meta itemprop="description" content="All Dev stories found in here.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeong Jiman's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/18/javascript-function-practice/" class="post-title-link" itemprop="url">javascript function practice</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-09-18 16:43:03 / Modified: 17:56:12" itemprop="dateCreated datePublished" datetime="2020-09-18T16:43:03+09:00">2020-09-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="0918-function-과제"><a href="#0918-function-과제" class="headerlink" title="0918 function 과제"></a>0918 function 과제</h1><h2 id="문제-1-1-10-000의-숫자-중-8이-등장하는-횟수-구하기-Google"><a href="#문제-1-1-10-000의-숫자-중-8이-등장하는-횟수-구하기-Google" class="headerlink" title="문제 1. 1 ~ 10,000의 숫자 중 8이 등장하는 횟수 구하기 (Google)"></a>문제 1. 1 ~ 10,000의 숫자 중 8이 등장하는 횟수 구하기 (Google)</h2><p>1부터 10,000까지 8이라는 숫자가 총 몇번 나오는가? 이를 구하는 함수를 완성하라.<br>단, 8이 포함되어 있는 숫자의 갯수를 카운팅 하는 것이 아니라 8이라는 숫자를 모두 카운팅 해야 한다. 예를 들어 8808은 3, 8888은 4로 카운팅 해야 한다.<br>(hint) 문자열 중 n번째에 있는 문자 : str.charAt(n) or str[n]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function getCount8 () &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.log(getCount8()); &#x2F;&#x2F; 4000</span><br></pre></td></tr></table></figure>



<p><strong>Answer</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function getCount8 () &#123;</span><br><span class="line">  let string &#x3D; &#39;&#39;;</span><br><span class="line">  let count &#x3D; 0;</span><br><span class="line">  for( let i &#x3D; 1; i &lt;&#x3D; 10000; i++)&#123;</span><br><span class="line">    string +&#x3D; i;</span><br><span class="line">  &#125;</span><br><span class="line">  for( let j &#x3D; 0; j &lt; string.length; j ++)&#123;</span><br><span class="line">    if(string[j] &#x3D;&#x3D;&#x3D; &#39;8&#39;) count++;</span><br><span class="line">  &#125;</span><br><span class="line">  return count;</span><br><span class="line">&#125;</span><br><span class="line">console.log(getCount8());&#x2F;&#x2F;4000</span><br></pre></td></tr></table></figure>



<h2 id="문제-2-이상한-문자-만들기"><a href="#문제-2-이상한-문자-만들기" class="headerlink" title="문제 2. 이상한 문자 만들기"></a>문제 2. 이상한 문자 만들기</h2><p>toWeirdCase함수는 문자열을 인수로 전달받는다. 문자열 s에 각 단어의 짝수번째 인덱스 문자는 대문자로, 홀수번째 인덱스 문자는 소문자로 바꾼 문자열을 리턴하도록 함수를 완성하라.<br>예를 들어 s가 ‘hello world’라면 첫 번째 단어는 ‘HeLlO’, 두 번째 단어는 ‘WoRlD’로 바꿔 ‘HeLlO WoRlD’를 리턴한다.<br>주의) 문자열 전체의 짝/홀수 인덱스가 아니라 단어(공백을 기준)별로 짝/홀수 인덱스를 판단한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function toWeirdCase(s) &#123;&#125;console.log(toWeirdCase(&#39;hello world&#39;));    &#x2F;&#x2F; &#39;HeLlO WoRlD&#39;</span><br><span class="line">console.log(toWeirdCase(&#39;my name is lee&#39;)); &#x2F;&#x2F; &#39;My NaMe Is LeE&#39;</span><br></pre></td></tr></table></figure>



<p><strong>Answer</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">function toWeirdCase(s)&#123;</span><br><span class="line">  let index &#x3D; 0;</span><br><span class="line">  let newString &#x3D; &#39;&#39;;</span><br><span class="line">  for (let i &#x3D; 0; i&lt;s.length; i++)&#123;</span><br><span class="line">    let asciiNum &#x3D; s[i].charCodeAt(0);</span><br><span class="line">    &#x2F;&#x2F;공백이면 넘어가기</span><br><span class="line">    if (s[i] &#x3D;&#x3D;&#x3D; &#39; &#39;)&#123;</span><br><span class="line">      newString +&#x3D; &#39; &#39;;</span><br><span class="line">      index &#x3D; 0;</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;알파벳 아니면 그냥 저장</span><br><span class="line">    if(!((asciiNum &gt;&#x3D;65 &amp;&amp; asciiNum &lt;&#x3D; 90) || (asciiNum &gt;&#x3D;97 &amp;&amp; asciiNum &lt;&#x3D; 122)))&#123;</span><br><span class="line">      newString +&#x3D; s[i];</span><br><span class="line">      index ++;</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line">    if (index % 2 &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">      &#x2F;&#x2F; 대문자면 그냥 저장, 소문자면 대문자로바꾸기</span><br><span class="line">      if(asciiNum &gt;&#x3D;65 &amp;&amp; asciiNum &lt;&#x3D; 90)&#123;</span><br><span class="line">        newString +&#x3D; s[i];</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        newString +&#x3D; String.fromCharCode(asciiNum - 32)</span><br><span class="line">      &#125;</span><br><span class="line">      index ++;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      &#x2F;&#x2F;대문자면 소문자로 바꾸기, 소문자면 그냥 저장</span><br><span class="line">      if(asciiNum &gt;&#x3D;65 &amp;&amp; asciiNum &lt;&#x3D; 90)&#123;</span><br><span class="line">        newString +&#x3D; String.fromCharCode(asciiNum + 32)</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        newString +&#x3D; s[i];</span><br><span class="line">      &#125;</span><br><span class="line">      index ++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return newString;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(toWeirdCase(&#39;ahf@@sk!!dhf fD%%FDFas&#39;));</span><br><span class="line">&#x2F;&#x2F;AhF@@sK!!dHf Fd%%FdFaS</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jjm2317.github.io/2020/09/18/javascript-SearchPractice/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jeong Jiman">
      <meta itemprop="description" content="All Dev stories found in here.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeong Jiman's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/18/javascript-SearchPractice/" class="post-title-link" itemprop="url">javascript SearchPractice</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-09-18 12:57:42 / Modified: 13:10:33" itemprop="dateCreated datePublished" datetime="2020-09-18T12:57:42+09:00">2020-09-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="선형-검색-이진검색-과제"><a href="#선형-검색-이진검색-과제" class="headerlink" title="선형 검색 이진검색 과제"></a>선형 검색 이진검색 과제</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">function linearSearch(array, target)&#123;</span><br><span class="line">  for(let i &#x3D; 0; i &lt; array.length; i ++)&#123;</span><br><span class="line">    if(array[i]&#x3D;&#x3D;&#x3D;target)&#123;</span><br><span class="line">      return i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(linearSearch([1,2,3,4,5,6] , 6));</span><br><span class="line"></span><br><span class="line">function binarySearch(array, target) &#123;</span><br><span class="line">  let start &#x3D; 0;</span><br><span class="line">  let end &#x3D; array.length - 1;</span><br><span class="line">  let mid &#x3D; parseInt(( start + end ) &#x2F; 2)  </span><br><span class="line"></span><br><span class="line">  while (start !&#x3D;&#x3D; end) &#123;</span><br><span class="line">    if(array[mid] &lt; target ) &#123;</span><br><span class="line">      start &#x3D; mid + 1;</span><br><span class="line">      mid &#x3D; parseInt(( start + end ) &#x2F; 2);</span><br><span class="line">    &#125;else if (array[mid] &gt; target) &#123;</span><br><span class="line">      end &#x3D; mid - 1;</span><br><span class="line">      mid &#x3D; parseInt(( start + end ) &#x2F; 2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if(array[mid] &#x3D;&#x3D;&#x3D; target)&#123;</span><br><span class="line">      return mid;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(binarySearch([1,2,3,4,5,6],4));</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jjm2317.github.io/2020/09/16/javascript-13Scope/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jeong Jiman">
      <meta itemprop="description" content="All Dev stories found in here.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeong Jiman's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/16/javascript-13Scope/" class="post-title-link" itemprop="url">javascript 13Scope</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-16 09:39:57" itemprop="dateCreated datePublished" datetime="2020-09-16T09:39:57+09:00">2020-09-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-21 19:04:49" itemprop="dateModified" datetime="2020-09-21T19:04:49+09:00">2020-09-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="스코프"><a href="#스코프" class="headerlink" title="스코프"></a>스코프</h1><h2 id="1-스코프란"><a href="#1-스코프란" class="headerlink" title="1. 스코프란?"></a>1. 스코프란?</h2><p><strong>스코프 이해의 중요성</strong></p>
<p>스코프(scope, 유효범위는) 자바스크립트를 포함한 모든 프로그래밍 언어의 기본적이고 중요한 개념이다.  자바스크립트의 스코프는 다른언어의 스코프와 구별되는 특징이 있어서 주의해야 한다.  var 키워드로 선언한 변수와 let, const로 선언한 변수의 스코프도 다르게 동작한다. 스코프는 변수, 함수와 깊은 관련이 있다. </p>
<p><strong>스코프는 식별자가 유효한 범위이다.</strong></p>
<p>우리는 스코프를 이미 경험했다. 바로 함수의 매개변수이다. 함수의 매개변수는 함수 몸체 내에서만 참조할 수 있고, 외부에서는 참조할 수 없다. 이것은 매개변수를 참조할 수 있는 유효범위, 즉 매개변수의 스코프가 함수 몸체 내부로 한정되기 때문이다. </p>
<p>매개변수의 스코프 예제</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function show(input) &#123;</span><br><span class="line">    console.log(input);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">show(&quot;hi&quot;); &#x2F;&#x2F;hi</span><br><span class="line"></span><br><span class="line">console.log(input); &#x2F;&#x2F; ReferenceError: input is not defined</span><br></pre></td></tr></table></figure>

<p>변수는 전역 뿐만 아니라 함수 몸체 내에서 선언할 수 있다. 또한 코드블록이나 함수는 중첩 가능하다.</p>
<p>스코프 별 변수 선언</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var num1 &#x3D; 1;</span><br><span class="line"></span><br><span class="line">if(1) &#123;</span><br><span class="line">    var num2 &#x3D; 2;</span><br><span class="line">    if(1) &#123;</span><br><span class="line">        var num3 &#x3D; 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    var num4 &#x3D; 4;</span><br><span class="line">    </span><br><span class="line">    function bar() &#123;</span><br><span class="line">        var num5 &#x3D; 5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(num1,num2,num3); &#x2F;&#x2F;1 2 3</span><br><span class="line">console.log(num4); &#x2F;&#x2F; ReferenceError: num4 is not defined</span><br><span class="line">console.log(num5); &#x2F;&#x2F; ReferenceError: num5 is not defined</span><br></pre></td></tr></table></figure>

<p>변수는 선언된 위치에 따라 유효한 범위(다른 코드가 변수를 참조할 수 있는 범위)가 정해진다. 변수뿐만 아니라 모든 식별자가 마찬가지이다. </p>
<p>모든 식별자는 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있있는 유효범위가 있다. 그 유효범위를 스코프라고 한다. </p>
<p><strong>스코프는 식별자를 검색할 때 사용하는 규칙이다</strong></p>
<p>다른 위치에 동일한 이름의 변수 선언 예제</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var x &#x3D; &#39;global&#39;;</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    var x &#x3D; &#39;local&#39;;</span><br><span class="line">    console.log(x); &#x2F;&#x2F; local</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line">console.log(x); &#x2F;&#x2F; global</span><br></pre></td></tr></table></figure>

<p>전역과 함수 몸체 내부에 같은 이름의 변수 x 를 선언하였다. 자바스크립트엔진은 이름같은 두개의 변수 중에서 어떤 변수를 참조 할것인지를 결정한다. 이를 식별자 결정(identifier resolution)이라고 한다. 자바스크립트 엔진은 스코프를 통해 어떤 변수를 참조할 것인지를 결정하기 때문에 스코프를 ‘식별자를 검색할 때 사용하는 규칙’ 이라고 할 수 있다.</p>
<p><strong>스코프가 다르면 별개의 변수이다.</strong></p>
<p>자바스크립트 엔진은 코드를 실행할 때 코드의 문맥을 고려한다. 즉, 코드의 위치를 고려하기 때문에 위 예제와 같이 동일한 이름의 변수 x 도 다른 결과를 만들어 낸다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">코드의 문맥(context)와 환경(environment)</span><br><span class="line">코드가 어디서 실행되며 주변에 어떤 코드가 있는지를 렉시컬 환경(lexical environment)라고 부른다. 코드의 문맥은 렉시컬 환경으로 이루어지며, 실행컨텍스트(execution context)로 구현된다. </span><br></pre></td></tr></table></figure>



<p>전역에서 선언된 변수 x 와 함수 내부에서 선언된 변수 x 는 식별자 이름이 동일하지만 스코프가 다른 별개의 변수이다. </p>
<p><strong>스코프는 네임 스페이스(이름으로 개체를 구별하는 공간)이다</strong></p>
<p>스코프라는 개념이 없다면 같은 이름을 갖는 변수는 충돌을 일으키기 띠ㅐ문에 프로그램 전체에서 하나만 사용해야된다.</p>
<p>식별자는 어떤 값을 구별하여 식별해낼 수 있는 고유한 이름을 말한다. 그렇기 때문에 유일(unique)해야 한다. 즉  중복되면 안된다는 뜻이다. 하나의 값은 유일한 식별자에 연결 (name binding)되어야 한다. </p>
<p>서로다른 스코프에서는 같은 이름의 식별자를 사용할 수 있다.</p>
<p>우리는 컴퓨터를 사용할 때 하나의 파일 이름만 사용하지 않는다. 폴더라는 개념이 존재하기 때문이다. 폴더가 있기 때문에 서로 다른 폴더에서 같은 이름의 파일을 만들 수 있다. </p>
<p><strong>var 키워드의 문제점</strong></p>
<p>var 키워드는 같은 스코프내에서 중복 선언이 허용된다.  의도치 않게 변수값이 재할당되는 부작용을 발생시킬 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var x &#x3D; 1;</span><br><span class="line">&#x2F;&#x2F;두번째 선언문은 var 키워드가 없는 것 처럼 동작한다. </span><br><span class="line">var x &#x3D; 2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(x);&#x2F;&#x2F;2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>let이나 const를 사용하자</strong></p>
<p>let, const 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용하지 않는다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let x &#x3D; 1;</span><br><span class="line">let x &#x3D; 2; &#x2F;&#x2F; SyntaxError: Identifier &#39;x&#39; has already been declared</span><br></pre></td></tr></table></figure>





<h2 id="렉시컬-스코프"><a href="#렉시컬-스코프" class="headerlink" title="렉시컬 스코프"></a>렉시컬 스코프</h2><p>lexical를 한국어로 번역해보면 어휘적인 이라는 뜻이다. 즉 문맥을 본다는 것으로 이해하면 된다. </p>
<p>렉시컬 스코프는 클로저를 이해하기도하는 시작점이기도 하다.  </p>
<p>정적스코프라고도 부르고 , 상위 스코프를 어떻게 결정하는 지에 대한 문법이다. 자바스크립트는 렉시컬스코프(정적스코프)를 따른다. </p>
<p>동적스코프는 호출위치에 따라 상위 스코프를 따르는 것이다. </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jjm2317.github.io/2020/09/15/javascript-12Function/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jeong Jiman">
      <meta itemprop="description" content="All Dev stories found in here.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeong Jiman's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/15/javascript-12Function/" class="post-title-link" itemprop="url">javascript 12Function</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-15 22:15:26" itemprop="dateCreated datePublished" datetime="2020-09-15T22:15:26+09:00">2020-09-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-16 21:20:46" itemprop="dateModified" datetime="2020-09-16T21:20:46+09:00">2020-09-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="함수"><a href="#함수" class="headerlink" title="함수"></a>함수</h1><h2 id="1-함수란"><a href="#1-함수란" class="headerlink" title="1. 함수란?"></a>1. 함수란?</h2><p>함수는 **입력(input) 을 받아 출력(output)**을 내보내는 일련의 과정을 정의한 것이다. </p>
<p>프로그래밍을 처음만든 과학자들 대다수가 수학자였다.</p>
<p>수학적사고를 통해서 프로그래밍을 만들었다. 그렇기 때문에 수학적 사고가 필요하다. </p>
<p><strong>프로그래밍에서의 함수는?</strong></p>
<p>프로그래밍 언어의 함수는 일련의 과정을 문(statement)로 구현하고 코드블록으로 감싸서 하나의 실행 단위로 정의한 것이다. </p>
<p>프로그래밍은 함수들의 집합이며, 우리는 함수를 만드는일을한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function sum(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>함수를 정의할때</strong></p>
<p><strong>function이라는 키워드</strong>를 쓰고 <strong>함수이름</strong>을 준다. <strong>괄호(매개변수 선언부)를 여닫고</strong>, **코드블록(함수 몸체)**을 써준다.</p>
<p>괄호를 매개변수 선언부라고한다. 매개 변수는 <strong>0개이상</strong>으로 여러개쓸 수 있다.  매개 ‘변수’는 함수 안에서 선언된 변수이다. </p>
<p><strong>매개변수란?</strong></p>
<p><strong>함수 바깥에 있는 값이</strong> 함수 안으로 들어올때 매개를 하는 것이 매개변수이다.</p>
<p>호출할때 인수로 작성하여 사용한다.</p>
<p>인수로 작성하면 매개변수에 할당된다.</p>
<p>함수 외부에 있었던 값을 함수 내부로 받아들이는 역할을 한다.</p>
<p><strong>함수는 함수정의(function definition)을 통해 생성한다.</strong> </p>
<p>함수를 정의하는 방법은 여러가지가 있다.</p>
<p>function 키워드와 함수이름, 매개변수 선언부() , 함수몸체를 작성해주는 것을 함수 선언문이라고 한다. 함수 몸체안에는 문들의 집합이 온다.</p>
<p>함수는 입력값을 받아서 출력값을 내보내기때문에 return 키워드를 통해 출력값 작성한다. </p>
<p>여기까지 함수 정의이다. 함수정의는 만드는것뿐이다. 사용하기위해선 call,호출해야한다. </p>
<p><strong>함수는 함수 호출(function call/ invoke) 를 통해 사용한다.</strong> </p>
<p>함수 호출을 하기위해서는 함수 식별자를 주고 괄호를 여닫고 괄호안에 매개변수를 통해 함수 안으로 넣어줄 값인 인수(argument)를 작성한다.</p>
<p>함수를 호출하게되면 인수가 매개변수에 할당이된다. </p>
<p>바깥에 있던 값이 안으로 들어가서 사용할 수 있다. </p>
<p>인수는 함수안에서 행해지는 일련의 과정을 위한 재료이다. </p>
<p>함수는 하나의 기계로 이해하면 편하다.</p>
<h2 id="2-함수를-사용하는-이유"><a href="#2-함수를-사용하는-이유" class="headerlink" title="2. 함수를 사용하는 이유"></a>2. 함수를 사용하는 이유</h2><ul>
<li>코드의 재사용<ul>
<li>실행 시점을 개발자가 정하고 재사용이 가능하다</li>
</ul>
</li>
<li>코드의 신뢰성을 높인다<ul>
<li>중복이 줄어드는 만큼 실수할 가능성도 줄기 때문</li>
</ul>
</li>
<li>가독성을 높인다<ul>
<li>적절한 함수 식별자 이름을 사용한다면 내부 코드를 몰라도 함수의 역할을 잘 파악할 수 있게 한다.</li>
</ul>
</li>
</ul>
<h2 id="3-함수-리터럴"><a href="#3-함수-리터럴" class="headerlink" title="3. 함수 리터럴"></a>3. 함수 리터럴</h2><p>리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기 방식(notation) 이다. 즉 표기법이다. 함수 리터럴도 평가되어 값을 생성한다. </p>
<p>자바스크립트에서 함수는 <strong>객체 타입의 값</strong>이다.</p>
<p>숫자를 숫자 리터럴로 생성하고 객체를 객체 리터럴로 생성하는 것처럼 함수도 함수 리터럴로 생성할 수 있다. </p>
<p>함수 리터럴은 다음으로 구성된다.</p>
<ul>
<li>function 키워드</li>
<li>함수 이름</li>
<li>매개변수 목록</li>
<li>함수 몸체</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const multiply &#x3D; function multiply(a, b)&#123;</span><br><span class="line">    &#x2F;&#x2F;var a;</span><br><span class="line">    &#x2F;&#x2F;var b;</span><br><span class="line">    return a * b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>함수 리터럴의 구성요소별 특징</strong></p>
<ul>
<li><strong>함수 이름</strong><ul>
<li>함수 이름은 식별자이므로 식별자 네이밍 규칙을 준수해야 한다.</li>
<li>단, 함수 몸체 내에서만 참조할 수 있는 식별자이다<ul>
<li>보통 재귀호출을 위해 사용된다</li>
</ul>
</li>
<li>함수 이름은 생략가능하다<ul>
<li>이름이 있는 함수는 기명 함수(named function)</li>
<li>이름이 없는 함수를 무명/익명 함수(anonymous function)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>매개변수 목록</strong><ul>
<li>0개 이상의 매개변수를 소괄호 () 로 감싸고 쉼표 , 로 구분</li>
<li>각 매겨변수에는 함수를 호출할때 입력한 인수(argument)가 순서대로 할당 된다. 즉 <strong>순서에 의미가 있다</strong>,</li>
<li>함수 몸체 내에서 변수와 동일하게 취급된다. <ul>
<li>식별자 네이밍 규칙을 준수해야 한다. </li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>함수 몸체<ul>
<li>함수 호출 시 실행될 문 들을 정의한 코드 블록이다.</li>
<li>함수 호출에 의해 실행된다.</li>
</ul>
</li>
</ul>
<p><strong>함수와 일반객체의 차이</strong></p>
<ul>
<li>일반 객체는 호출할 수 없지만 함수는 호출할 수 있다.</li>
<li>일반 객체에는 없는 함수 객체만의 고유한  프로퍼티를 갖는다. </li>
</ul>
<h2 id="4-함수-정의"><a href="#4-함수-정의" class="headerlink" title="4. 함수 정의"></a>4. 함수 정의</h2><p>함수 정의란 함수를 호출하기 이전에 인수를 전달받을 매개변수와 실행될 문들, 그리고 반환할 값을 지정하는 것을 말한다. 정의된 함수는 자바스크립트 엔진에 의해 평가되어 함수 객체가 된다. </p>
<p>함수를 정의하는 방법은 여러가지가 있다.</p>
<ul>
<li>함수 선언문 (function declaration / function statement)</li>
<li>함수 표현식 (function expression)</li>
<li>Function 생성자 함수(Function constructor)</li>
<li>화살표 함수 (arrow function)</li>
</ul>
<p><strong>변수 ‘선언’ 과 함수 ‘정의’는 어떤 차이가 있을까</strong></p>
<p>명확하지 않은것들을 명확하게 하는 것을 <strong>정의</strong></p>
<p><strong>선언</strong>은 이제부터 ~~할래 라는 뉘앙스</p>
<p>c언어 같은경우 선언과 정의를 명확히 구분했다.</p>
<p>(c언어에서) 변수에 값을 할당하는 것을 정의라고 한다. 값을 할당하는 순간 명확한 값을 가졌기때문이다. 선언은 없었던것을 새롭게 만드는 것이다. 선언하기전에는 메모리공간이 확보가 되어있지 않지만 선언을 하면 메모리공간이 확보된다.</p>
<p>자바스크립트에서는 변수 선언을 하면 자동으로 undefined 로 ‘정의’ 되기때문에 명확하지 않다. ECMAScript에서 정의와 선언을 구분하고 있기때문에 구함수는 정의, 변수는 선언이라고 표현하도록 하자. </p>
<h3 id="함수-선언문"><a href="#함수-선언문" class="headerlink" title="함수 선언문"></a>함수 선언문</h3><p>함수를 정의하는 방식 중 하나인 함수 선언문이다.</p>
<p>다음과 같은 특징이 있다.  </p>
<ul>
<li>표현식이 아닌 문</li>
<li>함수 호이스팅</li>
<li>함수이름 생략 불가</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;함수 선언문</span><br><span class="line">function searchWs(sentence)&#123;</span><br><span class="line">    var wsNum &#x3D; 0;</span><br><span class="line">    for(var i &#x3D; 0; i &lt; sentence.length; i ++)&#123;</span><br><span class="line">        if(sentence[i] &#x3D;&#x3D;&#x3D; &#39; &#39;)&#123;</span><br><span class="line">            wsNum ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return wsNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;함수 호출</span><br><span class="line">console.log(searchWs(&#39;my age is 23&#39;)); &#x2F;&#x2F;3</span><br></pre></td></tr></table></figure>



<p>함수 선언문은 함수 리터럴과 형태가 동일하다. 단, 함수 리터럴은 삼수 이름을 생략할 수 있으나 함수 선언문은 함수 이름을 생략할 수 없다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function (x, y) &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; SyntaxError: Function statementws require a function name</span><br></pre></td></tr></table></figure>



<ul>
<li>함수 선언문 은 표현식이 아닌 문이다. 즉, 크롬 개발자 도구의 콘솔에서 함수 선언문을 실행하면 완료 값 (completion) undefined 가 출력된다. </li>
<li>함수 선언문은 표현식이 아닌 문이기 때문에 변수에 할당할 수 없다.</li>
<li>그런데 다음 예제를 보면 함수 선언문이 변수에 할당되는 것처럼 동작한다. </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var add &#x3D; function add(x, y) &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;함수 호출</span><br><span class="line">console.log(add(1,3)); &#x2F;&#x2F; 4</span><br></pre></td></tr></table></figure>

<p>이유가 무엇일까? 위와 같이 동작하는 이유는 자바 스크립트가 문맥을 고려하기 때문이다.함수 선언문은 함수 이름을 생략할 수 없다는 점을 제외하면 함수 리터럴과 형태가 동일하다.</p>
<p> 즉 동일한 함수 표현을 문맥에 따라 두가지로 해석한다.</p>
<ul>
<li>함수 리터럴<ul>
<li>표현식인 문</li>
</ul>
</li>
<li>함수 선언문<ul>
<li>표현식이 아닌 문</li>
</ul>
</li>
</ul>
<p>비슷한 사례가 이전에도 있었다. 바로 객체 리터럴과 블록문이다. </p>
<p>{ }은 블록문일 수도 있고 객체 리터럴일 수도 있다.  즉, { }은 중의적 표현이다. 자바스크립트 엔진은 { } 을 문맥에 따라 다르게 해석한다.</p>
<p>만약 {} 이 단독으로 존재하면, 자바스크립트엔진은 { }을 블록문으로 해석한댜ㅏ. 하지만 { } 이 값으로 평가되어야하는 문맥에서는 { } 을 객체 리터럴로 해석한다. 이처럼 동일한 코드도 코드의 문맥에 따라 해석이 달라질 수 있다. </p>
<p>기명 함수 리터럴, 함수 선언문도 마찬가지로 중의적인 코드이다. 코드의 문맥에 따라 해석이 달라질 수 있다.</p>
<p>자바스크립트엔진은 기명 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석한다. 값으로 평가되어야하는 문맥( 변수 할당 등) 에 사용한다면 함수 리터럴 표현식으로 해석한다. </p>
<p>두 경우 모두 함수가 생성되는 것은 동일 하지만 내부 동작에 차이가 있다. 다음예제를 살펴보자. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;기명 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석된다.</span><br><span class="line">&#x2F;&#x2F; 함수 선언문에서는 함수 이름을 생략할 수 없다.</span><br><span class="line"></span><br><span class="line">function foo() &#123; console.log(&#39;foo&#39;);&#125;</span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 함수 리터럴을 피연산자로 사용하면 함수 선언문이 아니라 함수 리터럴 표현식으로 해석한다.</span><br><span class="line">&#x2F;&#x2F; 함수 리터럴에서는 함수 이름을 생략할 수 있다.</span><br><span class="line"></span><br><span class="line">(function bar() &#123; console.log(&#39;bar&#39;);&#125;);</span><br><span class="line">bar(); &#x2F;&#x2F;ReferenceError: bar is not defined</span><br></pre></td></tr></table></figure>

<p>위 예제에서 단독으로 사용된 함수 리터럴(foo)은 함수 선언문으로 해석된다. 하지만 그룹연산자 () 내에 있는 함수 리터럴(bar)은 함수 선언문으로 해석되지 않고 함수 리터럴 표현식으로 해석된다. 그룹연산자의 피연산자는 값으로  평가될 수 있는 표현식이어야 한다. 따라서 표현식이 아닌 문인 함수 선언문은 피연산자로 사용할 수 없다. </p>
<p>위 예제에서 함수 선언문을로 생성한 foo는 호출할 수 있으나 함수 리터럴 표현식으로 생성한 bar는 호출할 수 없다. 그이유가 무엇일까?</p>
<p>함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자이기 때문이다. </p>
<p>함수 몸체 외부에서는 함수 이름으로 함수를 참조할 수 없으므로 함수 외부에서 함수를 함수 이름으로 호출할 수 없다는 것이다. 즉, 함수를 생성하긴 했지만 생성한 함수를 가리키는 식별자가 존재하지 않는다. bar 함수를 호출 시 참조 에러가 발생하는 이유이다. </p>
<p>그런데 함수 선언문으로 정의한 foo 함수는 왜 호출이 가능하였을까?</p>
<p>foo 역시 함수 함수 이름인데 호출이 가능하려면 foo가 식별자이어야 한다. 우리가 명시 적으로 foo 라는 식별자를 생성한 적은 없다. 그러나 자바스크립트 엔진은 foo라는 식별자를 암묵적으로 생성하였다. </p>
<p>자바스크립트 엔진은 함수 선언문을 해석해 함수 객체를 생성한다. 이때 함수 이름은 함수 몸체 내에서만 유효한 식별자이다. 따라서 별도로 생성된 함수 객체를 가리리키는 식별자가 필요하다. </p>
<p>자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하과, 거기에 생성된 함수 객체를 할당한다. </p>
<p>즉 위에서 선언한 함수 foo는 내부적으로 다음과 같이 동작한다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; function foo() &#123;console.log(&#39;foo&#39;);&#125;;</span><br></pre></td></tr></table></figure>



<p>함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다. 즉, 함수 선언문으로 생성한 함수를 호출한 것은 함수 이름 foo 가 아닌, 암묵적으로 생성된 식별자 foo 이다. </p>
<p>위 의사 코드(pseudo code) 가 바로 다으에 살펴볼 함수 표현식이다. 결론적으로 자바스크립트 엔진은 함수 선언문을 함수 표현식으로 변환해 함수 객체를 생성한다고 생각할 수 있다. 단, 함수 선언문과 함수 표현식이 정확히 동일하게 동작하는 것은 아니다. </p>
<h3 id="함수-표현식"><a href="#함수-표현식" class="headerlink" title="함수 표현식"></a>함수 표현식</h3><p>함수는 객체 타입의 값이다. 함수는 값처럼 변수에 할당할 수 도있고 프로퍼티 값이 될수도 있으며, 배열의 요소가  될 수도 있다. 이러하 값의 성질을 갖는 객체를 일급 객체(first class object)라 한다. 자바스크립트의 함수는 일급 객체이다. 함수가 일급 객체라는 것은 함수를 값처럼 자유롭게 사용할 수 있다는 의미다. </p>
<p>함수는 일급 객체이므로 함수리터럴로 생성한 함수 객체를 변수에 할당할 수 있다. 이러한 정의방식을 함수 표현식(function expression) 이라고 한다. 함수 선언문으로 정의한 foo 함수를 함수 표현식으로 바꿔서 정의하면 다음과 같다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;함수 표현식</span><br><span class="line">var foo &#x3D; function ()&#123;</span><br><span class="line">    console.log(&#39;foo&#39;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo(); &#x2F;&#x2F; foo</span><br></pre></td></tr></table></figure>

<ul>
<li>함수 리터럴의 함수 이름은 생략 가능하다. 이러한 함수를 익명함수(anonymous function)이라 한다. </li>
<li>함수 리터럴은 함수 이름을 생략하는 것이 일반적이다. </li>
</ul>
<p>함수를 호출할 때는 함수 이름이 아니라 <strong>함수 객체를 가리키는 식별자</strong>를 사용해야한다.  함수 이름은 함수 몸체 내부에서만 유효한 식별자이므로, 함수 외부에서 함수 이름으로 함수를 호출할 수 없다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; function bar () &#123;</span><br><span class="line">    console.log(&#39;foo&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;함수 객체를 가리키는 식별자로 호출</span><br><span class="line">foo(); &#x2F;&#x2F; foo</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;함수 이름으로 호출하면 ReferenceError 이 발생한다. </span><br><span class="line">bar(); &#x2F;&#x2F; ReferenceError: bar is not defined</span><br></pre></td></tr></table></figure>



<p>자바스크립트 엔진은 함수 선언문의 함수 이름으로 식별자를 암묵적 생성하고 생성된 함수 객체를 할당하므로 함수 표현식과 유사하게 동작하는 것처럼 보인다. 하지만 함수 선언문과 함수 표현식이 정확히 동작하지는 않는다 </p>
<p>함수 선언문은 표현식이 아닌문이고 함수 표현식은 표현식인 문이다. </p>
<h3 id="함수-생성-시점과-함수-호이스팅"><a href="#함수-생성-시점과-함수-호이스팅" class="headerlink" title="함수 생성 시점과 함수 호이스팅"></a>함수 생성 시점과 함수 호이스팅</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;함수 참조</span><br><span class="line">console.dir(foo); &#x2F;&#x2F; f foo()</span><br><span class="line">console.dir(bar); &#x2F;&#x2F; undefined</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 함수 호출</span><br><span class="line">foo(); &#x2F;&#x2F; foo</span><br><span class="line">bar(); &#x2F;&#x2F; TypeError: bar is not a function </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;함수 선언문</span><br><span class="line">function foo () &#123;</span><br><span class="line">    console.log(&#39;foo&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;함수 표현식</span><br><span class="line">var bar &#x3D; function () &#123;</span><br><span class="line">    console.log(&#39;bar&#39;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있다.그러나 함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출할 수 없다.</p>
<p>함수 선언문으로 정의한 함수 표현식으로 정의한 함수의 생성 시점이 다르기 때문이다. </p>
<p><strong>함수 선언문은 런타임(runtime) 이전에 실행된다</strong></p>
<p>변수 선언문과 마찬가지로, 함수 선언문 역시 런타임 이전에 먼저 실행 된다. 즉, 함수 객체가 런타임이전에 생성된다는 뜻이다. 함수 선언문이 실행되면 자바스크립트 엔진은 <strong>함수 이름과 동일한 이름의 식별자를 암묵적으로 생성</strong>하고 생성된 함수 객체를 가리키게 한다.</p>
<p>코드상에서, 함수 선언문 이전에 함수를 참조하고, 호출할 수 있는 이유이다. 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 함수 호이스팅(function hoisting)이라고 한다.</p>
<p><strong>함수 호이스팅과 변수 호이스팅의 차이</strong></p>
<p>var 키워드를 사용한 변수 선언문과, 함수 선언문은 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행 되어 식별자를 생성한다는 점은 동일하다. 단 변수 호이스팅은 식별자가 암묵적으로 undefined을 할당하는 반면, 함수 선언문의 식별자는 명시한 함수객체를 생성해서 가리킨다는 점에서 차이가 있다. 그렇기 때문에 함수선언문으로 정의한 함수를 선언문 이전에 호출이 가능한 것이다. </p>
<p><strong>함수 표현식은 런타임(runtime)에 함수 객체를 만들어낸다</strong></p>
<p>함수 표현식은 변수 선언 및 할당문의 축약표현과 동일하게 동작한다. 런타임 이전에는 변수 선언만 실행이되어 undefined로 초기화 되고 함수 리터럴은 런타임에 평가되어 함수 객체를 생성한다. </p>
<p>따라서 함수 표현식은 함수 호이스팅이 아닌, 변수 호이스팅을 발생시키는 특징이 있다.  함수 표현식 이전에 함수식별자를 참조하면 함수가 아닌 undefined로 평가된다.  함수 호출 역시 불가하다. undefined를 호출하는 것과 마찬가지이므로 타입 에러가 발생한다. </p>
<p>함수 표현식으로 정의한 함수는 함수 표현식 이후에 참조, 호출하자.</p>
<h3 id="Function-생성자-함수"><a href="#Function-생성자-함수" class="headerlink" title="Function 생성자 함수"></a>Function 생성자 함수</h3><p><strong>생성자 함수(constructor function)란?</strong></p>
<p>생성자 함수는 객체를 생성하는 함수를 말한다. 객체를 생서하는 방식은 객체 리터럴 이외에도 다양한 방법이 있다. 그 중 하나가 생성자함수를 통한 객체 생성이다. </p>
<p><strong>Function 생성자 함수를 통해 함수 객체를 생성하는 방법</strong></p>
<p>Function 생성자 함수는 자바스크립트가 기본 제공하는 빌트인 함수이다.  이 Function 생성자 함수에 매개변수 목록과 함수 몸체를 문자열로 전달하고, new 연산자와 함께 호출하면 함수 객체를 생성해서 반환한다. new 연산자 없이 호출해도 결과는 동일하다. </p>
<p>Function 생성자 함수를 통한 함수 생성 예시</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var multiply &#x3D; new Function (&#39;a&#39;, &#39;b&#39;, &#39;return a*b&#39;);</span><br><span class="line"></span><br><span class="line">console.log(multiply(3,4)); &#x2F;&#x2F; 12</span><br></pre></td></tr></table></figure>

<p>Function 생성자 함수로 함수를 생성하는 것은 보통 바람직하지 않다. </p>
<p>다음과 같은 이유 때문이다.</p>
<ul>
<li>클로저(closure)를 생성하지 않는다. </li>
<li>함수 선언문이나 함수 표현식으로 생성한 함수와 다르게 움직인다. </li>
</ul>
<h3 id="화살표-함수-arrow-function"><a href="#화살표-함수-arrow-function" class="headerlink" title="화살표 함수(arrow function)"></a>화살표 함수(arrow function)</h3><p><strong>화살표 함수는 다음과 같은 특징이 있다.</strong></p>
<ul>
<li>좀 더 간략한 방법으로 함수를 생성</li>
<li>익명함수로 정의한다. </li>
<li>생성자 함수로 사용할 수 없다. </li>
<li>this 바인딩 방식이 다르다.</li>
<li>prototype 프로퍼티가 없다. </li>
<li>arguments 객체를 생성하지 않는다. </li>
</ul>
<p>화살표 함수 사용 예시</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const add &#x3D; (x, y) &#x3D;&gt; x + y;</span><br><span class="line">console.log(add ( 1,6))&#x2F;&#x2F; 7</span><br></pre></td></tr></table></figure>





<h2 id="5-함수-호출"><a href="#5-함수-호출" class="headerlink" title="5. 함수 호출"></a>5. 함수 호출</h2><p><strong>함수 호출이란?</strong></p>
<p>함수 호출은 함수를 참조해서 함수 몸체 내의 문들을 실행하는 것이다. </p>
<p>함수를 가리키는 식별자와 한쌍의 소괄호인 함수 호출 연산자로 호출한다. 함수 호출 연산자 () 내에는 0개 이상의 인수를 쉼표로 구분해서 나열한다.</p>
<p> 함수를 호출하면 현재의 실행 흐름을 중단하고 호출된 함수로 실행 흐름을 옮긴다. 이때 매개변수에 인수가 순서대로 할당되고 함수 몸체의 문들이 실행되기 시작한다. </p>
<h3 id="매개변수와-인수"><a href="#매개변수와-인수" class="headerlink" title="매개변수와 인수"></a>매개변수와 인수</h3><p><strong>매개변수와 인수의 역할</strong></p>
<p>함수를 실행하기 위해 필요한 값을 함수 외부에서 함수 내부로 전달할 필요가  있을 때 매개변수(parameter, 인자)를 통해 인수(argument)를 전달한다. 인수는 값으로 평가될 수 있는 표현식이어야 한다. 인수는 함수를 호출할 때 지정하며, 개수와 타입에 제한이 없다. </p>
<p>매개변수와 인수 사용예시</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 함수 선언문</span><br><span class="line">function divide(a, b) &#123;</span><br><span class="line">    return a &#x2F; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;함수 호출</span><br><span class="line">var result &#x3D; divide (5, 2);</span><br></pre></td></tr></table></figure>





<p><strong>매개 변수는 함수 몸체 내부에서 변수의 역할을 한다.</strong></p>
<p>매개변수는 함수를 정의할 때 선언하며 함수 몸체 내부에서 변수와 동일하게 취급된다. 즉, 함수가 호출되면 함수 몸체 내에서 암묵적으로 매개변수가 생성되고 일반 변수와 마찬가지로 undefined로 초기화 된 이후 인수를 입력한 순서대로 할당하게 된다. </p>
<p>**매개변수의 스코프는 함수 내부이다. **</p>
<p>매개 변수는 함수 몸체 내부에서만 참조할 수 있고 함수 몸체 외부에서는 참조할 수 없다. 즉 함수 내부에서만 유효하다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 함수 선언문</span><br><span class="line">function divide(a, b) &#123;</span><br><span class="line">    return a &#x2F; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;함수 호출</span><br><span class="line">var result &#x3D; divide (5, 2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;매개 변수 a, b는 전역에서 참조할 수 없다.</span><br><span class="line">console.log(a, b); &#x2F;&#x2F; ReferenceError: a is not defined </span><br></pre></td></tr></table></figure>



<p><strong>매개변수의 개수와 인수의 개수의 일치여부</strong></p>
<p>함수는 매개변수의 개수와 인수의 개수가 일치하는지 체크하지 않는다. 일반적으로, 함수를 호출할때 매개변수의 개수만큼 인수를 전달하지만, 만약 개수가 일치하지 않더라도 에러가 발생하지 않는다. </p>
<p><strong>인수가 매개변수의 개수보다 부족한 경우</strong>, 인수가 할당되지 않은 매개변수의 값은 undefined 이다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 함수 선언문</span><br><span class="line">function divide(a, b) &#123;</span><br><span class="line">    &#x2F;&#x2F; var a;</span><br><span class="line">    &#x2F;&#x2F; var b;</span><br><span class="line">    return a &#x2F; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;인수가 할당되지 않은 매개변수의 값은 undefined 이다.</span><br><span class="line">console.log(divide(5)); &#x2F;&#x2F; NaN b에 undefined 가 할당되었다. </span><br></pre></td></tr></table></figure>

<p>위에서 매개변수 a에는 인수 5가 전달되지만, b 에는 전달할 인수가 없으므로 매개 변수 undefined로 초기화된 상태이다. undefined로 산술을 할 수 없으므로 NaN이 출력된다. </p>
<p><strong>매개변수보다 인수가 더 많은 경우,</strong> 초과된 인수는 무시된다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 함수 선언문</span><br><span class="line">function divide(a, b) &#123;</span><br><span class="line">    return a &#x2F; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 초과된 인수 4는 무시된다.</span><br><span class="line">console.log(divide(5, 2, 4)); &#x2F;&#x2F;2.5</span><br></pre></td></tr></table></figure>

<p>초과된 인수는 그냥 버려지는 것은 아니다. 모든 인수는 arguments 객체의 프로퍼티로 보관된다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 함수 선언문</span><br><span class="line">function divide(a, b) &#123;</span><br><span class="line">    console.log(arguments); &#x2F;&#x2F; [Arguments] &#123; &#39;0&#39;: 5, &#39;1&#39;: 2, &#39;2&#39;: 4 &#125; </span><br><span class="line">    return a &#x2F; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(divide(5, 2, 4));</span><br></pre></td></tr></table></figure>

<p>arguments 객체는 함수를 정의할 때, 매개변수 개수를 확정할 수 없는 가변 인자 함수를 구현할 때 유용하게 사용된다.</p>
<h3 id="인수-확인"><a href="#인수-확인" class="headerlink" title="인수 확인"></a>인수 확인</h3><p><strong>적절한 인수 전달의 필요성</strong></p>
<p>다음예제를 살펴보자.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function sum(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 함수를 정의한 개발자의 의도는 2개의 숫자 타입 인수를 전달받아 덧셈의 결과를 반환하려는 것이다. </p>
<p>하지만, 불분명한 점이 있다.</p>
<ul>
<li>어떤 타입의 인수를 전달해야하는지</li>
<li>어떤 타입의 값을 반환해야하는지</li>
</ul>
<p>따라서 다음과 같은 문제가 발생할 수 있다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function sum(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(sum(4)); &#x2F;&#x2F; NaN</span><br><span class="line">console.log(sum(&#39;x&#39;, &#39;y&#39;)); &#x2F;&#x2F; &#39;xy&#39;</span><br></pre></td></tr></table></figure>

<p>위 코드는 문법상 아무 문제가 없다. 하지만 개발자의 의도와는 다르다. </p>
<p>이런 상황이 발생한 이유는 다음과 같다. </p>
<ul>
<li>자바스크립트는 매개변수와 인수의 개수가 일치하는지 확인하지 않는다</li>
<li>자바스크립트는 동적 타입언어이므로 사전에 매개변수 타입을 지정할수없다.</li>
</ul>
<p>우리는 함수를 정의할 때 적절한 인수가 전달되었는지 추가적인 코드로 확인해야 한다.</p>
<p><strong>인수의 타입이 부적절한 경우</strong></p>
<p>매개변수를 통해 전달된 인수의 타입이 부적절한 경우 다음과 같은 방법으로 에러를 발생시킬 수 있다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function sum(a, b) &#123;</span><br><span class="line">    if ( typeof a !&#x3D;&#x3D; &#39;number&#39; || typeof b !&#x3D;&#x3D; &#39;number&#39;)&#123;</span><br><span class="line">        throw new TypeError(&#39;인수는 모두 숫자 값이어야 한다.&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(sum(4)); &#x2F;&#x2F; TypeError: 인수는 모두 숫자 값이어야 한다.</span><br><span class="line">console.log(sum(&#39;x&#39;, &#39;y&#39;)); &#x2F;&#x2F; TypeError: 인수는 모두 숫자 값이어야 한다.</span><br></pre></td></tr></table></figure>

<p>위와 같이 에러를 통해 잘못된 호출을 방지 할 수 있지만, 사전에 방지할 수 없고 에러가 런타임에 발생한다. 따라서 타입 스크립트(정적 타입을 선언할 수 있는 자바스크립트의 상위 확장)를 도입하여 컴파일 시점에 부적절한 호출을 방지할 수도 있다. </p>
<p><strong>인수의 개수를 확인하는 법</strong></p>
<p>앞의 예제는 타입을 확인하지만 인수의 개수는 확인하지 않는다. 인수의 개수를 확인하는 법은 다음과같다. </p>
<ul>
<li>arguments 객체를 통해 인수 개수를 확인할 수 있다.</li>
<li>인수가 전달되지 않은 경우 단축 평가를 사용해 매개변수에 기본값을 할당할 수 있다. </li>
<li>ES6의 매개변수 기본값을 사용할 수 있다. </li>
</ul>
<p>단축 평가를 사용해 매개변수에 기본값을 할당해보자</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function sum(a, b, c) &#123;</span><br><span class="line">    a &#x3D; a || 0;</span><br><span class="line">    b &#x3D; b || 0;</span><br><span class="line">    c &#x3D; c || 0;</span><br><span class="line">    return a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(sum(1, 2, 3)); &#x2F;&#x2F; 6</span><br><span class="line">console.log(sum(1, 2)); &#x2F;&#x2F; 3</span><br><span class="line">console.log(sum(1)); &#x2F;&#x2F; 1</span><br><span class="line">console.log(sum); &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure>



<p>ES6의 매개변수 기본값을 사용해보자. 인수 체크 및 초기화를 간소화할 수 있다. 단, 인수가 부족하게 전달된 경우 즉  인수를 전달하지 않을경우, undefined를 전달한 경우에만 유효하다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function sum(a &#x3D; 0, b &#x3D; 0, c &#x3D; 0) &#123;</span><br><span class="line">    return a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(sum(1, 2, 3)); &#x2F;&#x2F; 6</span><br><span class="line">console.log(sum(1, 2)); &#x2F;&#x2F; 3</span><br><span class="line">console.log(sum(1)); &#x2F;&#x2F; 1</span><br><span class="line">console.log(sum); &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure>





<h3 id="매개변수의-최대-개수"><a href="#매개변수의-최대-개수" class="headerlink" title="매개변수의 최대 개수"></a>매개변수의 최대 개수</h3><p><strong>매개 변수의 개수는 적을 수록 좋다.</strong></p>
<p>ECMAScript 사양에서는 매개변수의 최대 개수에 대해 명시적으로 제한하고 있지 않다. 물론 메모리의 제한때문에 매개변수 선언에도 최대 개수는 제한이 있겠지만, 원한다면 충분히 많은 매개변수를 지정할 수 있다. 매개변수는 최대 몇개까지 사용하는 것이 좋을까?</p>
<p>매개변수는 입력 순서에 의미가 있다. 따라서 함수를 호출 시 인수를 전달하는 경우 마찬가지로 순서를 고려해야한다.  매개변수는 함수의 사용법을 이해하기 어렵게 만들고 실수를 유발하는 요소이다. 매개변수의 개수나 순서가 변경될 때 함수의 호출 방법도 바뀌므로 코드 전체를 수정해야 될 수 있다. 매개변수는 유지보수성을 저하시키는 원인이다.</p>
<p>결론적으로, 매개변수는 코드의 가독성을 떨어뜨리는 요소이므로 이상적으로 0개가 best이며, 적을수록 좋다. 매개변수가 많은 것은 함수가 하나의 기능이 아닌 여러가지 일을 한다는 증거이므로 좋지않다. 이상적인 함수는 한 가지 일만 해야 하며 가급적 작게 만들어야 한다.</p>
<p>매개변수는 최대 3개를 초과하지 않도록 하는 것이 좋다. 그 이상의 매개변수가 필요한 상황이라면 객체를 함수의 인수에 전달함으로서 가독성을 높이고 실수를 줄일 수 있다. </p>
<p>객체를 인수로서 전달하는 예제</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    method: &#39;POST&#39;,</span><br><span class="line">    url: &#39;&#x2F;user&#39;,</span><br><span class="line">    data: &#123; id: 1, name: &#39;Lee&#39;&#125;,</span><br><span class="line">    cache: false</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>객체를 인수로 전달할 시의 장점</strong></p>
<p>객체를 인수로 사용하면 프로퍼티 키만 정확히 지정하면 순서를 고려하지 않아도 되므로 신경쓸 것이 줄어든다. 또한 함수에 인수를 전달할때 프로퍼티 키가 인수의 의미를 설명해주므로, 코드의 가독성이 좋아지고 실수가 줄어드는 효과가 있다. </p>
<p><strong>주의점</strong></p>
<p>함수 외부에서 함수 내부로 전달한 객체를 함수 내부에서 변경하면 함수 외부의 객체가 변경되는 부수효과가 발생한다. </p>
<h3 id="반환문"><a href="#반환문" class="headerlink" title="반환문"></a>반환문</h3><p><strong>함수의 실행결과 반환(return)</strong></p>
<p>함수는 return 키워드와 표현식(반환값)으로 이루어진 반환문을 사용해 실행 결과를 함수 외부로 반환(return)할 수 있다.</p>
<p>반환문 사용예시</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function divide (num1, num2) &#123;</span><br><span class="line">    return num1 &#x2F; num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;함수 호출은 반환값으로 평가된다.</span><br><span class="line">var res &#x3D; divide(2, 8);</span><br><span class="line">console.log(res); &#x2F;&#x2F; 0.25</span><br></pre></td></tr></table></figure>

<p>함수는 return 키워드를 사용해 자바스크립트의 모든 값을 반환할 수 있다. 함수 호출은 표현식이다. 함수 호출 표현식은 return 키워드가 반환한 표현식의 평가 결과인 반환값으로 평가된다. </p>
<p><strong>반환문은 두 가지 역할을 한다.</strong></p>
<ol>
<li>함수의 실행을 중단하고 함수 몸체를 빠져나간다.</li>
<li>return 키워드 뒤에 오는 표현식을 평가해 반환한다.</li>
</ol>
<p><strong>반환문의 역할 1 : 함수의 종료</strong></p>
<p>반환문이 실행되면 함수의 실행이 중단되고 함수 몸체 밖으로 실행흐름이 이동한다. 그렇기 때문에 함수 몸체 안에서 반환문 이후에 오는 문들은 실행되지않고 무시된다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function divide (num1, num2) &#123;</span><br><span class="line">    return num1 &#x2F; num2;</span><br><span class="line">    </span><br><span class="line">    console.log(&#39;실행 안되요&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(divide(4&#x2F;2)); &#x2F;&#x2F;2</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>반환문의 역할 2 : 함수의 실행결과 반환</strong></p>
<p>반환문은 return 키워드 뒤에 위치한 표현식을 평가하여 그 값을 반환한다. return 키워드뒤에 반환결과를 명시하지 않으면 undefined가 암묵적으로 반환된다.  반환문은 생략될 수 있고, 이 경우 함수의 실행 종료시점에 암묵적으로 undefined를 반환한다.  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 실행결과 반환</span><br><span class="line"></span><br><span class="line">function isOdd(num) &#123;</span><br><span class="line">    return num % 2 &#x3D;&#x3D;&#x3D; 1 ? true : false;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;return 뒤의 표현식 평가 후 반환</span><br><span class="line">console.log(isOdd(5)); &#x2F;&#x2F;true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; return 뒤에 표현식이 없는 경우</span><br><span class="line">function foo1 ()&#123;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;암묵적으로 undefined 반환</span><br><span class="line">console.log(foo1()); &#x2F;&#x2F;undefined</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;return 문이 없는 경우</span><br><span class="line">function foo2()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;함수 몸체의 마지막 문까지 실행후 undefined 반환</span><br><span class="line">console.log(foo2()); &#x2F;&#x2F;undefined</span><br></pre></td></tr></table></figure>



<p><strong>반환문 사용시 주의점</strong></p>
<ol>
<li>return 키워드와 반환값 사이에 줄바꿈이 있으면 ASI에 의해 반환값이 무시될 수 있다.</li>
<li>함수 몸체 내부에서만 사용할 수 있다. <ul>
<li>전역에서 사용시 문법에러 발생</li>
<li>단, node.js 는 파일별로 독립적인 파일 스코프를 가져서 에러발생하지 않음</li>
</ul>
</li>
</ol>
<h2 id="6-참조에-의한-전달과-외부-상태의-변경"><a href="#6-참조에-의한-전달과-외부-상태의-변경" class="headerlink" title="6. 참조에 의한 전달과 외부 상태의 변경"></a>6. 참조에 의한 전달과 외부 상태의 변경</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jjm2317.github.io/2020/09/10/0831-0904-TIL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jeong Jiman">
      <meta itemprop="description" content="All Dev stories found in here.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeong Jiman's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/10/0831-0904-TIL/" class="post-title-link" itemprop="url">0831-0904 TIL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-09-10 22:44:07 / Modified: 22:47:30" itemprop="dateCreated datePublished" datetime="2020-09-10T22:44:07+09:00">2020-09-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="0831-0904-TIL"><a href="#0831-0904-TIL" class="headerlink" title="0831-0904 TIL"></a>0831-0904 TIL</h1><h2 id="한-일들"><a href="#한-일들" class="headerlink" title="한 일들"></a>한 일들</h2><ul>
<li>자바스크립트 공부<ul>
<li>poiemaweb 원시값과 객체 ~ 프로토타입</li>
</ul>
</li>
<li>블로그 포스팅 (원시값과 객체)</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jjm2317.github.io/2020/09/07/javascript-control-flow-exercise/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jeong Jiman">
      <meta itemprop="description" content="All Dev stories found in here.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeong Jiman's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/07/javascript-control-flow-exercise/" class="post-title-link" itemprop="url">javascript control-flow-exercise</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-09-07 18:38:56 / Modified: 18:43:59" itemprop="dateCreated datePublished" datetime="2020-09-07T18:38:56+09:00">2020-09-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Exercise-삼항-조건-연산자-제어문"><a href="#Exercise-삼항-조건-연산자-제어문" class="headerlink" title="Exercise (삼항 조건 연산자 , 제어문)"></a>Exercise (삼항 조건 연산자 , 제어문)</h1><h2 id="과제-1"><a href="#과제-1" class="headerlink" title="과제 1"></a>과제 1</h2><p>아래 코드를 삼항 조건 연산자로 변경</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var x &#x3D; 11;</span><br><span class="line">var res;</span><br><span class="line">if (x &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">  res &#x3D; &#39;영&#39;;</span><br><span class="line">&#125; else if (x % 2 &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">  res &#x3D; &#39;짝수&#39;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  res &#x3D; &#39;홀수&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Answer</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var x &#x3D; 11;</span><br><span class="line">var res &#x3D; x % 2 &#x3D;&#x3D;&#x3D; 0 ? (x &#x3D;&#x3D;&#x3D; 0  ? &#39;영&#39; : &#39;짝수&#39;) : &#39;홀수&#39;;</span><br></pre></td></tr></table></figure>



<h2 id="과제-2"><a href="#과제-2" class="headerlink" title="과제 2"></a>과제 2</h2><p>제어문 연습문제 풀이</p>
<h3 id="1-변수-x가-10보다-크고-20보다-작을-때-변수-x를-출력하는-조건식을-완성하라"><a href="#1-변수-x가-10보다-크고-20보다-작을-때-변수-x를-출력하는-조건식을-완성하라" class="headerlink" title="1. 변수 x가 10보다 크고 20보다 작을 때 변수 x를 출력하는 조건식을 완성하라"></a>1. 변수 x가 10보다 크고 20보다 작을 때 변수 x를 출력하는 조건식을 완성하라</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var x &#x3D; 15;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 변수 x가 10보다 크고 20보다 작을 때 변수 x를 출력하는 조건식을 완성하라.</span><br><span class="line">if (...) &#123;</span><br><span class="line">  console.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Answer</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var x &#x3D; 15;</span><br><span class="line"></span><br><span class="line">if (x &gt; 10 &amp;&amp; x &lt; 20) &#123;</span><br><span class="line">  console.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-for문을-사용하여-0부터-10미만의-정수-중에서-짝수만을-작은-수부터-출력하시오"><a href="#2-for문을-사용하여-0부터-10미만의-정수-중에서-짝수만을-작은-수부터-출력하시오" class="headerlink" title="2. for문을 사용하여 0부터 10미만의 정수 중에서 짝수만을 작은 수부터 출력하시오."></a>2. for문을 사용하여 0부터 10미만의 정수 중에서 짝수만을 작은 수부터 출력하시오.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">8</span><br></pre></td></tr></table></figure>



<p><strong>Answer</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(var number &#x3D; 0; number &lt; 10; number++)&#123;</span><br><span class="line">    if(number % 2 &#x3D;&#x3D;&#x3D; 0)&#123;</span><br><span class="line">        console.log(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-for문을-사용하여-0부터-10미만의-정수-중에서-짝수만을-작은-수부터-문자열로-출력하시오"><a href="#3-for문을-사용하여-0부터-10미만의-정수-중에서-짝수만을-작은-수부터-문자열로-출력하시오" class="headerlink" title="3. for문을 사용하여 0부터 10미만의 정수 중에서 짝수만을 작은 수부터 문자열로 출력하시오."></a>3. for문을 사용하여 0부터 10미만의 정수 중에서 짝수만을 작은 수부터 문자열로 출력하시오.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">02468</span><br></pre></td></tr></table></figure>



<p><strong>Answer</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var result&#x3D;&#39;&#39;;</span><br><span class="line"></span><br><span class="line">for(num &#x3D; 0; num &lt; 10; num++)&#123;</span><br><span class="line">    if(num % 2 &#x3D;&#x3D;&#x3D; 0)&#123;</span><br><span class="line">        result +&#x3D; num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure>



<h3 id="4-for문을-사용하여-0부터-10미만의-정수-중에서-홀수만을-큰수부터-출력하시오"><a href="#4-for문을-사용하여-0부터-10미만의-정수-중에서-홀수만을-큰수부터-출력하시오" class="headerlink" title="4. for문을 사용하여 0부터 10미만의 정수 중에서 홀수만을 큰수부터 출력하시오."></a>4. for문을 사용하여 0부터 10미만의 정수 중에서 홀수만을 큰수부터 출력하시오.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">7</span><br><span class="line">5</span><br><span class="line">3</span><br><span class="line">1</span><br></pre></td></tr></table></figure>



<p><strong>Answer</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(var num &#x3D; 9; num &gt;&#x3D; 0; num--)&#123;</span><br><span class="line">    if(num % 2 &#x3D;&#x3D;&#x3D; 1)&#123;</span><br><span class="line">        console.log(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-while문을-사용하여-0-부터-10-미만의-정수-중에서-짝수만을-작은-수부터-출력하시오"><a href="#5-while문을-사용하여-0-부터-10-미만의-정수-중에서-짝수만을-작은-수부터-출력하시오" class="headerlink" title="5. while문을 사용하여 0 부터 10 미만의 정수 중에서 짝수만을 작은 수부터 출력하시오."></a>5. while문을 사용하여 0 부터 10 미만의 정수 중에서 짝수만을 작은 수부터 출력하시오.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">8</span><br></pre></td></tr></table></figure>



<p><strong>Answer</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var num &#x3D; 0;</span><br><span class="line">while(num&lt;10)&#123;</span><br><span class="line">    if(num % 2 &#x3D;&#x3D;&#x3D;0)&#123;</span><br><span class="line">        console.log(num)</span><br><span class="line">    &#125;</span><br><span class="line">    num ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-while문을-사용하여-0-부터-10-미만의-정수-중에서-홀수만을-큰수부터-출력하시오"><a href="#6-while문을-사용하여-0-부터-10-미만의-정수-중에서-홀수만을-큰수부터-출력하시오" class="headerlink" title="6. while문을 사용하여 0 부터 10 미만의 정수 중에서 홀수만을 큰수부터 출력하시오."></a>6. while문을 사용하여 0 부터 10 미만의 정수 중에서 홀수만을 큰수부터 출력하시오.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">7</span><br><span class="line">5</span><br><span class="line">3</span><br><span class="line">1</span><br></pre></td></tr></table></figure>



<p><strong>Answer</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var num &#x3D; 9;</span><br><span class="line">while(num &gt;&#x3D; 0)&#123;</span><br><span class="line">    if(num % 2 &#x3D;&#x3D;&#x3D;1)&#123;</span><br><span class="line">        console.log(num)</span><br><span class="line">    &#125;</span><br><span class="line">    num --;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-for-문을-사용하여-0부터-10미만의-정수의-합을-출력하시오"><a href="#7-for-문을-사용하여-0부터-10미만의-정수의-합을-출력하시오" class="headerlink" title="7. for 문을 사용하여 0부터 10미만의 정수의 합을 출력하시오."></a>7. for 문을 사용하여 0부터 10미만의 정수의 합을 출력하시오.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">45</span><br></pre></td></tr></table></figure>



<p><strong>Answer</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var sum &#x3D; 0;</span><br><span class="line"></span><br><span class="line">for(num &#x3D; 0; num &lt; 10; num ++)&#123;</span><br><span class="line">    sum +&#x3D; num;</span><br><span class="line">&#125;</span><br><span class="line">console.log(sum);</span><br></pre></td></tr></table></figure>



<h3 id="8-1부터-20-미만의-정수-중에서-2-또는-3의-배수가-아닌-수의-총합을-구하시오"><a href="#8-1부터-20-미만의-정수-중에서-2-또는-3의-배수가-아닌-수의-총합을-구하시오" class="headerlink" title="8.  1부터 20 미만의 정수 중에서 2 또는 3의 배수가 아닌 수의 총합을 구하시오."></a>8.  1부터 20 미만의 정수 중에서 2 또는 3의 배수가 아닌 수의 총합을 구하시오.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">73</span><br></pre></td></tr></table></figure>



<p><strong>Answer</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var sum &#x3D; 0;</span><br><span class="line"></span><br><span class="line">for(num &#x3D; 1; num &lt; 20; num ++)&#123;</span><br><span class="line">    sum +&#x3D; (num % 2 &#x3D;&#x3D;&#x3D; 0 || num % 3 &#x3D;&#x3D;&#x3D; 0) ? 0 : num; </span><br><span class="line">&#125;</span><br><span class="line">console.log(sum);</span><br></pre></td></tr></table></figure>



<h3 id="9-1부터-20-미만의-정수-중에서-2-또는-3의-배수인-수의-총합을-구하시오"><a href="#9-1부터-20-미만의-정수-중에서-2-또는-3의-배수인-수의-총합을-구하시오" class="headerlink" title="9. 1부터 20 미만의 정수 중에서 2 또는 3의 배수인 수의 총합을 구하시오."></a>9. 1부터 20 미만의 정수 중에서 2 또는 3의 배수인 수의 총합을 구하시오.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">117</span><br></pre></td></tr></table></figure>



<p><strong>Answer</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var sum &#x3D; 0;</span><br><span class="line"></span><br><span class="line">for(num &#x3D; 1; num &lt; 20; num ++)&#123;</span><br><span class="line">    sum +&#x3D; (num % 2 &#x3D;&#x3D;&#x3D; 0 || num % 3 &#x3D;&#x3D;&#x3D; 0) ? num : 0; </span><br><span class="line">&#125;</span><br><span class="line">console.log(sum);</span><br></pre></td></tr></table></figure>



<h3 id="10-두-개의-주사위를-던졌을-때-눈의-합이-6이-되는-모든-경우의-수를-출력하시오"><a href="#10-두-개의-주사위를-던졌을-때-눈의-합이-6이-되는-모든-경우의-수를-출력하시오" class="headerlink" title="10. 두 개의 주사위를 던졌을 때, 눈의 합이 6이 되는 모든 경우의 수를 출력하시오."></a>10. 두 개의 주사위를 던졌을 때, 눈의 합이 6이 되는 모든 경우의 수를 출력하시오.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[ 1, 5 ]</span><br><span class="line">[ 2, 4 ]</span><br><span class="line">[ 3, 3 ]</span><br><span class="line">[ 4, 2 ]</span><br><span class="line">[ 5, 1 ]</span><br></pre></td></tr></table></figure>



<p><strong>Answer</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(var num1 &#x3D; 1; num1 &lt;&#x3D; 6; num1 ++)&#123;</span><br><span class="line">    for(var num2 &#x3D; 1; num2 &lt;&#x3D; 6; num2 ++)&#123;</span><br><span class="line">        if(num1 + num2 &#x3D;&#x3D;&#x3D; 6)&#123;</span><br><span class="line">            console.log(&#96;[ $&#123;num1&#125;, $&#123;num2&#125; ]&#96;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="11-삼각형-출력하기-pattern-1"><a href="#11-삼각형-출력하기-pattern-1" class="headerlink" title="11. 삼각형 출력하기 - pattern 1"></a>11. 삼각형 출력하기 - pattern 1</h3><p>다음을 참고하여 *(별)로 높이가 5인(var line = 5) 삼각형을 문자열로 완성하라. 개행문자(‘\n’)를 사용하여 개행한다. 완성된 문자열의 마지막은 개행문자(‘\n’)로 끝나도 관계없다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 높이(line)가 5</span><br><span class="line">*</span><br><span class="line">**</span><br><span class="line">***</span><br><span class="line">****</span><br><span class="line">*****</span><br></pre></td></tr></table></figure>



<p><strong>Answer</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var line &#x3D; 5;</span><br><span class="line">var star &#x3D; &#39;&#39;;</span><br><span class="line">var tri &#x3D; &#39;&#39;;</span><br><span class="line">for(var i &#x3D; 0; i &lt; line; i++)&#123;</span><br><span class="line">    star +&#x3D; &#39;*&#39;;</span><br><span class="line">    tri +&#x3D; star + &#39;\n&#39;;</span><br><span class="line">&#125;</span><br><span class="line">console.log(tri);</span><br></pre></td></tr></table></figure>



<h3 id="12-삼각형-출력하기-pattern-2"><a href="#12-삼각형-출력하기-pattern-2" class="headerlink" title="12. 삼각형 출력하기 - pattern 2"></a>12. 삼각형 출력하기 - pattern 2</h3><p>다음을 참고하여 *(별)로 트리를 문자열로 완성하라. 개행문자(‘\n’)를 사용하여 개행한다. 완성된 문자열의 마지막은 개행문자(‘\n’)로 끝나도 관계없다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*****</span><br><span class="line"> ****</span><br><span class="line">  ***</span><br><span class="line">   **</span><br><span class="line">    *</span><br></pre></td></tr></table></figure>



<p><strong>Answer</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var line &#x3D; 5;</span><br><span class="line">var tri &#x3D; &#39;&#39;;</span><br><span class="line">for(var i &#x3D; 0; i &lt; line; i++)&#123;</span><br><span class="line">    for(var j &#x3D; 0; j &lt; i; j ++)&#123;</span><br><span class="line">        tri +&#x3D; &#39; &#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    for(var k &#x3D; 0; k &lt; line - i; k ++)&#123;</span><br><span class="line">        tri +&#x3D; &#39;*&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    tri +&#x3D; &#39;\n&#39;;</span><br><span class="line">&#125;</span><br><span class="line">console.log(tri);</span><br></pre></td></tr></table></figure>



<h3 id="13-삼각형-출력하기-pattern-3"><a href="#13-삼각형-출력하기-pattern-3" class="headerlink" title="13. 삼각형 출력하기 - pattern 3"></a>13. 삼각형 출력하기 - pattern 3</h3><p>다음을 참고하여 *(별)로 트리를 문자열로 완성하라. 개행문자(‘\n’)를 사용하여 개행한다. 완성된 문자열의 마지막은 개행문자(‘\n’)로 끝나도 관계없다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*****</span><br><span class="line">****</span><br><span class="line">***</span><br><span class="line">**</span><br><span class="line">*</span><br></pre></td></tr></table></figure>



<p><strong>Answer</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var line &#x3D; 5;</span><br><span class="line">var tri &#x3D; &#39;&#39;;</span><br><span class="line">for(var i &#x3D; 0; i &lt; line; i++)&#123;</span><br><span class="line">    for(var k &#x3D; 0; k &lt; line - i; k ++)&#123;</span><br><span class="line">        tri +&#x3D; &#39;*&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    for(var j &#x3D; 0; j &lt; i; j ++)&#123;</span><br><span class="line">        tri +&#x3D; &#39; &#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    tri +&#x3D; &#39;\n&#39;;</span><br><span class="line">&#125;</span><br><span class="line">console.log(tri);</span><br></pre></td></tr></table></figure>



<h3 id="14-삼각형-출력하기-pattern-4"><a href="#14-삼각형-출력하기-pattern-4" class="headerlink" title="14. 삼각형 출력하기 - pattern 4"></a>14. 삼각형 출력하기 - pattern 4</h3><p>다음을 참고하여 *(별)로 트리를 문자열로 완성하라. 개행문자(‘\n’)를 사용하여 개행한다. 완성된 문자열의 마지막은 개행문자(‘\n’)로 끝나도 관계없다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    *</span><br><span class="line">   **</span><br><span class="line">  ***</span><br><span class="line"> ****</span><br><span class="line">*****</span><br></pre></td></tr></table></figure>



<p><strong>Answer</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var line &#x3D; 5;</span><br><span class="line">var tri &#x3D; &#39;&#39;;</span><br><span class="line">for(var i &#x3D; 1; i &lt;&#x3D; line; i++)&#123;</span><br><span class="line">    for(var j &#x3D; 0; j &lt; line - i; j ++)&#123;</span><br><span class="line">        tri +&#x3D; &#39; &#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    for(var k &#x3D; 0; k &lt; i; k ++)&#123;</span><br><span class="line">        tri +&#x3D; &#39;*&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    tri +&#x3D; &#39;\n&#39;;</span><br><span class="line">&#125;</span><br><span class="line">console.log(tri);</span><br></pre></td></tr></table></figure>



<h3 id="15-정삼각형-출력하기"><a href="#15-정삼각형-출력하기" class="headerlink" title="15. 정삼각형 출력하기"></a>15. 정삼각형 출력하기</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    *</span><br><span class="line">   ***</span><br><span class="line">  *****</span><br><span class="line"> *******</span><br><span class="line">*********</span><br></pre></td></tr></table></figure>



<p><strong>Answer</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var line &#x3D; 5;</span><br><span class="line">var tri &#x3D; &#39;&#39;;</span><br><span class="line">for(var i &#x3D; 1; i &lt;&#x3D; line; i++)&#123;</span><br><span class="line">    for(var j &#x3D; 0; j &lt; line - i; j ++)&#123;</span><br><span class="line">        tri +&#x3D; &#39; &#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    for(var k &#x3D; 0; k &lt; i * 2 - 1; k ++)&#123;</span><br><span class="line">        tri +&#x3D; &#39;*&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    tri +&#x3D; &#39;\n&#39;;</span><br><span class="line">&#125;</span><br><span class="line">console.log(tri);</span><br></pre></td></tr></table></figure>



<h3 id="16-역정삼각형-출력하기"><a href="#16-역정삼각형-출력하기" class="headerlink" title="16. 역정삼각형 출력하기"></a>16. 역정삼각형 출력하기</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*********</span><br><span class="line"> *******</span><br><span class="line">  *****</span><br><span class="line">   ***</span><br><span class="line">    *</span><br></pre></td></tr></table></figure>



<p><strong>Answer</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var line &#x3D; 5;</span><br><span class="line">var tri &#x3D; &#39;&#39;;</span><br><span class="line">for(var i &#x3D; 1; i &lt;&#x3D; line; i++)&#123;</span><br><span class="line">    for(var j &#x3D; 0; j &lt; i - 1; j ++)&#123;</span><br><span class="line">        tri +&#x3D; &#39; &#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    for(var k &#x3D; 0; k &lt; (line - i) * 2 + 1; k ++)&#123;</span><br><span class="line">        tri +&#x3D; &#39;*&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    tri +&#x3D; &#39;\n&#39;;</span><br><span class="line">&#125;</span><br><span class="line">console.log(tri);</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jjm2317.github.io/2020/09/01/0824-0828-TIL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jeong Jiman">
      <meta itemprop="description" content="All Dev stories found in here.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeong Jiman's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/01/0824-0828-TIL/" class="post-title-link" itemprop="url">0824~0828 TIL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-09-01 23:06:38 / Modified: 23:10:53" itemprop="dateCreated datePublished" datetime="2020-09-01T23:06:38+09:00">2020-09-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="0824-0828-TIL"><a href="#0824-0828-TIL" class="headerlink" title="0824~0828 TIL"></a>0824~0828 TIL</h1><h2 id="한-일들"><a href="#한-일들" class="headerlink" title="한 일들"></a>한 일들</h2><ul>
<li>자바스크립트 변수, 데이터 타입, 표현식 등등 기본 개념 이해</li>
<li>공부한 내용 정리하여 블로그 작성</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jjm2317.github.io/2020/09/01/javascript-11primitiveValue-vs-objectValue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jeong Jiman">
      <meta itemprop="description" content="All Dev stories found in here.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeong Jiman's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/01/javascript-11primitiveValue-vs-objectValue/" class="post-title-link" itemprop="url">javascript 11primitiveValue vs objectValue</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-01 22:08:08" itemprop="dateCreated datePublished" datetime="2020-09-01T22:08:08+09:00">2020-09-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-02 12:05:48" itemprop="dateModified" datetime="2020-09-02T12:05:48+09:00">2020-09-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="원시값과-객체의-비교"><a href="#원시값과-객체의-비교" class="headerlink" title="원시값과 객체의 비교"></a>원시값과 객체의 비교</h1><p>자바스크립트에는 7가지 데이터 타입이 있었다. 그리고 그 데이터 타입은 <strong>원시타입(primitive type)</strong> 과 <strong>객체타입(object/reference type)</strong> 으로 분류되었다.</p>
<ul>
<li>원시 타입<ul>
<li>number</li>
<li>string</li>
<li>boolean</li>
<li>undefined</li>
<li>null</li>
<li>symbol</li>
</ul>
</li>
<li>객체 타입<ul>
<li>함수, 객체 등등</li>
</ul>
</li>
</ul>
<p>원시 타입에서도 number, string 등 데이터 타입을 나누어 놓은 이유가 존재하였다. 자세한 내용은 데이터타입 포스팅에서 다루었다. </p>
<p>원시타입과 객체 타입을 나누어 놓은 이유는 무엇일까? 두 타입의 차이점을 먼저 짚어보자. 크게 3가지 측면에서 차이가 있다. </p>
<ul>
<li>원시 타입의 값, 즉 원시값은 변경 불가능한 값(immutable value)이다. 객체는 변경 가능한 값(mutable value)이다. <ul>
<li>변수에 저장된 값을 변경하고자할때, 원시값은 변경불가하기때문에 재할당에 의해 변경해야되지만, 객체는 재할당없이 값을 변경 가능하다.</li>
</ul>
</li>
<li>원시값을 변수에 할당하면 변수에 실제값이 저장된다. 이에 비해 객체를 변수에 할당하면 변수에는 참조값이 저장이된다. <ul>
<li>참조값은 객체 값을 저장한 메모리 주소를 가리킨다.</li>
</ul>
</li>
<li>원시값을 갖는 변수를 다른 변수에 할당하면 원본의 <strong>원시값이</strong> <strong>복사</strong>되어 전달된다.이를 값에 의한 전달 (pass by value) 라고 한다.  객체를 가리키는 변수를 다른 변수에 할당하면 원본의 <strong>참조값이 복사</strong>되어 전달된다. 이를 참조에 의한 전달(pass by reference) 이라고 한다.  </li>
</ul>
<p>즉 변경 가능성, 저장값, 전달 방식에서 차이가 있다.</p>
<p> 이 관점에서 원시 값과 객체를 분석해보자</p>
<h2 id="1-원시값"><a href="#1-원시값" class="headerlink" title="1. 원시값"></a>1. 원시값</h2><h3 id="1-1-원시값은-변경-불가능한-값이다"><a href="#1-1-원시값은-변경-불가능한-값이다" class="headerlink" title="1.1 원시값은 변경 불가능한 값이다."></a>1.1 원시값은 변경 불가능한 값이다.</h3><p>원시타입(primitive type)의 값, 원시값은 변경 불가능한 값 (immutable value) 이다. </p>
<p>한번 생성된 원시 값은 읽기 전용(read only) 값으로서 변경할 수 없다.</p>
<p><code>값을 변경할 수 없다?</code></p>
<p>값은 표현식이 평가되어 생성된 결과로 메모리에 저장되어 있다. 메모리에 저장된 값은 변경 불가능하다는 뜻이다. </p>
<p>헷갈릴 수 있는 개념에 대해 짚고 넘어가보자. 변수와 값은 구분해서 생각해야하낟. </p>
<ul>
<li>변수 : 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름</li>
<li>값 : 변수에 저장된 데이터로서 표현식이 평가되어 생성된 결과</li>
</ul>
<p>변경 불가 하다는 것은 변수가 아니라 값에 대한 진술이다.</p>
<p>원시값은 변경 불가능하다는 말은 <strong>원시값 자체를 변경할 수 없다</strong>는 것이지 변수 값을 변경할 수 없다는 것이 아니다. </p>
<p>다만, <strong>변수의 값이 변경</strong>되는 것은 원시값 자체의 변화가 아닌, 재할당을 통해 <strong>새로 생성된 원시값을 변수에 할당</strong>하는 것이다. 즉 엄밀히 말해서는 변수의 값이 교체되는 것이다.  </p>
<p>그렇다면 변수의 상대개념인 상수는 어떨까?</p>
<p>상수는 <strong>재할당이 금지된 변수</strong>이다. 상수도 값을 저장하기 위한 메모리 공간이 필요하므로 변수라고 할 수 있다. 다만 변수는 재할당을 통해 변수 값을 변경(교체)할 수 있지만 상수는 단 한번만 할당이 허용되므로 변수 값을 변경(교체)할 수 없다.  이처럼 상수는 재할당이 금지된 <strong>변수</strong>일 뿐이지, 변경 불가능한 값의 범주에 포함시키지는 않는다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 상수는 immutable한 값이 아닌 재할당이 금지된 변수이다.</span><br><span class="line">&#x2F;&#x2F; 상수에 객체를 할당할 시 변경 가능하다는 예시가 있다.</span><br><span class="line"></span><br><span class="line">const obj &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj.key &#x3D; &#39;value&#39;;</span><br><span class="line">console.log(obj); </span><br><span class="line">&#x2F;&#x2F;&#123;key: value&#125;</span><br></pre></td></tr></table></figure>



<p><code>변수의 재할당은 어떻게 일어날까?</code></p>
<p>원시값은 변경 불가능한 값이다. 변수에 재할당을 하게되면 원시값이 저장된 메모리공간으로 접근해서 값을 변경하는 것이 아니다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var num &#x3D; 10;</span><br><span class="line">&#x2F;&#x2F;값의 재할당</span><br><span class="line">num &#x3D; 5;</span><br></pre></td></tr></table></figure>

<p>num이라는 변수에 10이라는 숫자가 저장되어 있다. 5를 재할당 할 경우 10 이 저장되어 있는 메모리공간으로 접근해서 <strong>값을 변경하는 것이 아니라 새로운 메모리 공간을 확보</strong>해서 5를 저장한 후 num이라는 변수 이름을 연결해준다.  10은 가비지 컬렉터에 의해 메모리공간확보가 해제된다. </p>
<p>이렇게 처리하는 이유는 컴퓨터 입장에서 편하기 때문이다. </p>
<p>원시값의 이러한 특성을 불변성(immutaility)라고 한다.  불변성을 갖는 원시값을 할당한 변수는 재할당 의외에 변수 값을 변경할 수 있는 방법이 없다. </p>
<h3 id="1-2-문자열과-불변성"><a href="#1-2-문자열과-불변성" class="headerlink" title="1.2 문자열과 불변성"></a>1.2 문자열과 불변성</h3><p>원시값을 메모리 공간에 저장하기 위해서는, <strong>확보해야 하는 메모리 공간의 크기를 결정해야한다</strong>.  원시타입 별로 확보해야하는 메모리 공간의 크기가 정해져 있는 것이다.  ECMAScript 사양을 보면 문자열 타입 (2byte)와 숫자타입(8byte)는 메모리공간의 크기가 명시되어있는 반면에 다른 원시타입은 명시 되어있지 않고 브라우저 제조사의 구현에따라 다를 수 있다. </p>
<p>문자열 값은 다른 원시값과 비교해 독특한 특징이 있다.</p>
<ul>
<li>문자열은 0개 이상의 문자(character)로 이뤄진 집합이다.</li>
<li>1개의 문자는 2byte의 메모리 공간에 저장된다.</li>
<li>문자열은 몇 개의 문자로 이뤄졌느냐에 따라 필요한 메모리 공간의 크기가 결정된다.</li>
</ul>
<p>즉, 문자열은 확보해야하는 메모리공간의 크기가 고정된 다른 원시값과 다르게 <strong>문자의 개수에 따라 확보되는 메모리공간의 크기가 다르다</strong>. 1개의 문자로 된 문자열은 2byte, 5개의 문자로 이뤄진 문자열은 10byte가 필요하다.(실제 계산은 다르긴하다.)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str1 &#x3D; &#39;&#39;;</span><br><span class="line">var str2 &#x3D; &#39;jiman&#39;;</span><br><span class="line">&#x2F;&#x2F;필요한 메모리 공간의 크기가 다르다.</span><br></pre></td></tr></table></figure>

<p>C와 자바에서는 문자열 데이터 타입이 따로 없다. </p>
<p>c에서는 문자타입(char)들의 배열로 문자열을 처리하고, 자바에서는 String 객체로 문자열을 처리한다. </p>
<p>자바스크립트에서는 string이라는 데이터 타입을 제공하는 것이다. 데이터의 신뢰성을 보장하는, 자바스크립트의 장점이다.  </p>
<p>원시타입인 문자열 역시 변경 불가능하다. </p>
<p>문자열에는 독특한 특징이 하나 더 있는데 바로 유사 배열 객체 (array-like-object)라는 것이다. </p>
<p><strong>유사 배열 객체란?</strong></p>
<p>배열 처럼 인덱스로 프로퍼티 값에 접근할 수 있으며, length 프로퍼티를 갖는 객체이다. </p>
<p>즉 문자열은 인덱스로 각 문자 하나하나 에 접근할 수 있고 length 프로퍼티도 갖는다. for 문으로 순회하는 것도 가능하다. </p>
<p>다만 원시값인 문자열을 객체처럼 사용하면 원시값을 감싸는 래퍼 객체로 자동 변환된다. </p>
<p><strong>문자열은 변경 불가능한 원시값이다.</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var str &#x3D; &#39;jiman&#39;;</span><br><span class="line">str[0] &#x3D; &#39;J&#39;;</span><br><span class="line">console.log(str[0]);</span><br><span class="line">&#x2F;&#x2F;jiman</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;원시값이기때문에 개별문자의 변경이 불가하다. </span><br></pre></td></tr></table></figure>



<h3 id="1-3-값에-의한-전달-pass-by-value"><a href="#1-3-값에-의한-전달-pass-by-value" class="headerlink" title="1.3 값에 의한 전달(pass by value)"></a>1.3 값에 의한 전달(pass by value)</h3><p>어떤 변수에 기존에 원시값을 할당했던 변수를 할당하면 어떻게 될까?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var original &#x3D; 10;</span><br><span class="line">var copy &#x3D; original;</span><br><span class="line"></span><br><span class="line">console.log(original, copy);&#x2F;&#x2F; 10 10</span><br><span class="line"></span><br><span class="line">original &#x3D; 20;</span><br><span class="line"></span><br><span class="line">console.log(original, copy); 20 10</span><br></pre></td></tr></table></figure>

<p>copy에 original을 할당할때 original이 10으로 평가되어 새로운메모리 공간을 확보하고 10을 저장한 후 copy를 연결한다. 즉,  copy에는 original의 원시값이 복사되어 전달된다. 이를 값에의한전달 이라고 한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var original &#x3D; 10;</span><br><span class="line">var copy &#x3D; original;</span><br><span class="line"></span><br><span class="line">console.log( original, copy); &#x2F;&#x2F; 10 10</span><br><span class="line">console.log(original &#x3D;&#x3D;&#x3D; copy); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">orignal &#x3D; 20;</span><br><span class="line">console.log( original &#x3D;&#x3D;&#x3D; copy); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p>original 과 copy는 평가되었을때 동일한 숫자 값이지만, 두 값을 저장한 메모리공간의 위치는 다르다. 즉 orignal과 copy에 저장된 값은 별개의 값이다. </p>
<p>ECMAScript 사양에 변수를 통한 메모리 관리가 명확히 정의되지 않아서 값에 의한 전달시 두가지 경우가 있을 수 있다. </p>
<ul>
<li>식별자를 할당했을때 같은 원시값을 참조하였다가 재할당시 새로운 생성값을 참조</li>
<li>식별자 할당시부터 새로운 메모리공간 생성후 평가값저장후 참조</li>
</ul>
<p>파이썬은 전자처럼 동작한다고 한다. 할당 시점에 두 변수가 기억하는 메모리주소가 같느냐 다르냐이다. </p>
<p><strong>중요한것은 두 변수의 원시값이 결국엔 서로다른 메모리 공간에 저장된 다는 것이다.</strong>  서로 간섭하지 않는다.  </p>
<h2 id="2-객체"><a href="#2-객체" class="headerlink" title="2. 객체"></a>2. 객체</h2><p>객체 값을 생성할때 메모리공간의 크기는 어떻게 될까?</p>
<p>객체는 다음과 같은 특징이있다.</p>
<ul>
<li>객체는 프로퍼티의 개수가 고정되어 있지 않고, 동적으로 추가되고 삭제될 수 있다.</li>
<li>프로퍼티 값에 제약이 없다. </li>
<li>즉, 원시값과 같이 확보해야할 메모리 공간의 크기를 사전에 정해 둘 수 없다. </li>
</ul>
<p>객체는 복합적인 자료구조이다. 원시값과 비교하였을 때 복잡하고 브라우저 제조사마다 구현방식이 다를 수 있댜. 소비하는 메모리가 상대적으로 적은 원시값에 비해, 객체는 소비하는 메모리가 경우에 따라 매우 클 수 있다. </p>
<p>객체를 생성하고 프로퍼티에 접근하는 것도 원시값과 비교할 때 비용이 많이든다. </p>
<h3 id="2-1-객체는-변경-가능한-값이다"><a href="#2-1-객체는-변경-가능한-값이다" class="headerlink" title="2.1 객체는 변경 가능한 값이다."></a>2.1 객체는 변경 가능한 값이다.</h3><p>객체는 변경 가능한 값(mutable value) 이다.  변수에 원시값을 할당하면, 변수를 통해 해당 메모리공간에 저장된 값으로 직접 접근한다. 하지만, 객체를 할당한다면, 변수를 통해서 **참조값(reference value)**에 접근한다. </p>
<p>참조값은 <strong>객체가 저장된 메모리공간의 메모리 주소</strong>이다. 이 참조값을 통해 객체가 저장된 메모리공간에 접근할 수 있다.  그래서 원시값을 할당한 변수의 경우 변수는 ~~값을 갖는다 라고 표현하지만, 객체의 경우 변수는 객체를 가리키고(point) 있다 라고 표현한다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var object &#x3D; &#123;</span><br><span class="line">    key: &#39;value&#39;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;변수 objdect 는 객체&#123;key: &#39;value&#39;&#125;를 가리키고(참조하고) 있다.</span><br></pre></td></tr></table></figure>

<p>변수의 값을 변경해보자. 원시값은 재할당 외에는 방법이 없다. </p>
<p>하지만 객체는 변경 가능한 값이므로 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있다. </p>
<ul>
<li>프로퍼티 동적 추가</li>
<li>프로퍼티 값 갱신 </li>
<li>프로퍼티 삭제</li>
</ul>
<p>위 사항 모두 가능하다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var object &#x3D; &#123;</span><br><span class="line">    key: &#39;value&#39;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;object 변수에 객체 할당</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;프로퍼티 키 동적 추가</span><br><span class="line">object.addedKey&#x3D;&#39;value1&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;프로퍼티 값 갱신</span><br><span class="line">object.key &#x3D; &#39;modifiedValue&#39;;</span><br><span class="line"></span><br><span class="line">console.log(object);</span><br><span class="line">&#x2F;&#x2F;&#123; key: &#39;modifiedValue&#39;, addedKey: &#39;value1&#39; &#125;</span><br></pre></td></tr></table></figure>

<p>변수에는 객체의 참조값이 할당되어 있다.  프로퍼티 값을 조작할때 변수에 재할당은 하지 않았으므로 변수의 참조값이 변경되지않는다. </p>
<p>객체가 새로이 생성되지 않고 변경가능하게 설계된 이유는 무엇일까?</p>
<p>객체를 생성하고 관리하는 방식이 복잡하고 비용이 많이 드는일이다. 객체는 크기가 매우 클 수도 있고 원시값처럼 크기가 일정하지도 않으며 프로퍼티 값이 객체일 수 도있다. 그렇기때문에 복사해서 생성하는 비용이 많이든다. 메모리의 효율적 소비가 어렵고 성능이 나빠진다. </p>
<p>그렇기때문에 원시값 처럼 이전값을 복사해서 새롭게 생성하지 않는다. 객체는 메모리를 효율적으로 사용하고, 복사 및 생성비용을 절약하기 위해 변경가능한 값으로 설계되어 있다. 데이터의 신뢰성이 원시값에 비해 떨어지지만, 메모리 사용의 효율성과 성능을 고려한 것이다. </p>
<p>결론적으로 메모리 관점에서 효율성을 얻었지만 구조적인 단점도 가지고 있다.</p>
<p>이러한 단점에 따른 부작용이 있다.</p>
<p>바로 여러 개의 식별자가 하나의 객체를 공유할 수 있다는 것이다. </p>
<p>얕은 복사와 깊은 복사의 개념을 짚고 넘어가자.</p>
<p>객체의 프로퍼티 값으로 객체를 가지고 있다고 했을 때,</p>
<ul>
<li>얕은복사 : 한단계 까지만 복사하는 것을 말한다.</li>
<li>깊은복사 : 객체에 중첩되어 있는 객체 까지 복사하는 것</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">const o &#x3D; &#123;</span><br><span class="line">    a: &#123;</span><br><span class="line">        b: 2</span><br><span class="line">    &#125;,</span><br><span class="line">    f()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 얕은 복사1</span><br><span class="line">let c &#x3D; &#123; ...o&#125;; &#x2F;&#x2F; 35. 스프레드 문법에 있다고 한다.</span><br><span class="line">console.log(o&#x3D;&#x3D;&#x3D;c); &#x2F;&#x2F;false</span><br><span class="line">console.log(o.a &#x3D;&#x3D;&#x3D; c.a); &#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F; 한단계까지는 복사 하였지만 내부의 객체는 참조값을 전달했다.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;얕은 복사2 </span><br><span class="line">c &#x3D; Object.assign(&#123;&#125;,o);</span><br><span class="line">console.log(o &#x3D;&#x3D;&#x3D; c); &#x2F;&#x2F; false</span><br><span class="line">console.log(o.a &#x3D;&#x3D;&#x3D; c.a); &#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F; 마찬가지로 한단계까지 복사하고 내부의 객체는 참조값을 전달</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 깊은복사 1</span><br><span class="line">&#x2F;&#x2F; JSON.parse 와 JSON.stringify를 사용한 깊은복사</span><br><span class="line">c &#x3D; JSON.parse(JSON.stringify(o));</span><br><span class="line">console.log(o &#x3D;&#x3D;&#x3D; c); &#x2F;&#x2F; false</span><br><span class="line">console.log(o.a &#x3D;&#x3D;&#x3D; c.a); &#x2F;&#x2F; false</span><br><span class="line">&#x2F;&#x2F; 메서드가 사라지는 문제가있다.</span><br><span class="line">console.log(c.f);&#x2F;&#x2F; undefined</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 깊은 복사 2</span><br><span class="line">&#x2F;&#x2F; &quot;npm install lodash&quot;로 lodash를 설치한 후, Node.js 환경에서 실행</span><br><span class="line">const _ &#x3D; require(&#39;lodash&#39;);</span><br><span class="line"></span><br><span class="line">c &#x3D; _cloneDeep(o);</span><br><span class="line">console.log( o &#x3D;&#x3D;&#x3D; c); false</span><br><span class="line">console.log( o.a &#x3D;&#x3D;&#x3D; c.a); &#x2F;&#x2F;false</span><br><span class="line">console.log(c.f); &#x2F;&#x2F; f</span><br></pre></td></tr></table></figure>



<p>참고로, <strong>원시값을 할당한 변수를 다른 변수에 할당</strong>하는 것을 깊은복사, <strong>객체를 할당한 변수를 다른변수에 할당</strong>하는 것을 얕은 복사라고 하는 경우도 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;깊은 복사</span><br><span class="line">const v &#x3D; 1;</span><br><span class="line">const c1 &#x3D; v;</span><br><span class="line">console.log(c1 &#x3D;&#x3D;&#x3D; v); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;얕은 복사</span><br><span class="line">const o &#x3D; &#123; x: 1&#125;;</span><br><span class="line">const c2 &#x3D; o;</span><br><span class="line">consol.log(c2 &#x3D;&#x3D;&#x3D; o); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>



<h3 id="2-2-참조에-의한-전달"><a href="#2-2-참조에-의한-전달" class="headerlink" title="2.2 참조에 의한 전달"></a>2.2 참조에 의한 전달</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jeong Jiman</p>
  <div class="site-description" itemprop="description">All Dev stories found in here.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jeong Jiman</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
