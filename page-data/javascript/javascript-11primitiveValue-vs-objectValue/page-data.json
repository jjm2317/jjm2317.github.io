{"componentChunkName":"component---src-templates-blog-post-js","path":"/javascript/javascript-11primitiveValue-vs-objectValue/","result":{"data":{"site":{"siteMetadata":{"title":"Jiman's Blog","author":"Jeong Jiman","siteUrl":"https://gatsby-starter-bee.netlify.com","comment":{"disqusShortName":"","utterances":"JaeYeopHan/gatsby-starter-bee"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"ee20a785-789a-5a5f-a515-5b76a41cef7a","excerpt":"원시값과 객체의 비교 자바스크립트에는 7가지 데이터 타입이 있었다. 그리고 그 데이터 타입은 원시타입(primitive type) 과 객체타입(object/reference type) 으로 분류되었다. 원시 타입 number string boolean undefined null symbol 객체 타입 함수, 객체 등등 원시 타입에서도 number, string…","html":"<h1 id=\"원시값과-객체의-비교\" style=\"position:relative;\"><a href=\"#%EC%9B%90%EC%8B%9C%EA%B0%92%EA%B3%BC-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EB%B9%84%EA%B5%90\" aria-label=\"원시값과 객체의 비교 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>원시값과 객체의 비교</h1>\n<p>자바스크립트에는 7가지 데이터 타입이 있었다. 그리고 그 데이터 타입은 <strong>원시타입(primitive type)</strong> 과 <strong>객체타입(object/reference type)</strong> 으로 분류되었다.</p>\n<ul>\n<li>\n<p>원시 타입</p>\n<ul>\n<li>number</li>\n<li>string</li>\n<li>boolean</li>\n<li>undefined</li>\n<li>null</li>\n<li>symbol</li>\n</ul>\n</li>\n<li>\n<p>객체 타입</p>\n<ul>\n<li>함수, 객체 등등</li>\n</ul>\n</li>\n</ul>\n<p>원시 타입에서도 number, string 등 데이터 타입을 나누어 놓은 이유가 존재하였다. 자세한 내용은 데이터타입 포스팅에서 다루었다.</p>\n<p>원시타입과 객체 타입을 나누어 놓은 이유는 무엇일까? 두 타입의 차이점을 먼저 짚어보자. 크게 3가지 측면에서 차이가 있다.</p>\n<ul>\n<li>\n<p>원시 타입의 값, 즉 원시값은 변경 불가능한 값(immutable value)이다. 객체는 변경 가능한 값(mutable value)이다.</p>\n<ul>\n<li>변수에 저장된 값을 변경하고자할때, 원시값은 변경불가하기때문에 재할당에 의해 변경해야되지만, 객체는 재할당없이 값을 변경 가능하다.</li>\n</ul>\n</li>\n<li>\n<p>원시값을 변수에 할당하면 변수에 실제값이 저장된다. 이에 비해 객체를 변수에 할당하면 변수에는 참조값이 저장이된다.</p>\n<ul>\n<li>참조값은 객체 값을 저장한 메모리 주소를 가리킨다.</li>\n</ul>\n</li>\n<li>원시값을 갖는 변수를 다른 변수에 할당하면 원본의 <strong>원시값이</strong> <strong>복사</strong>되어 전달된다.이를 값에 의한 전달 (pass by value) 라고 한다. 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 <strong>참조값이 복사</strong>되어 전달된다. 이를 참조에 의한 전달(pass by reference) 이라고 한다.</li>\n</ul>\n<p>즉 변경 가능성, 저장값, 전달 방식에서 차이가 있다.</p>\n<p>이 관점에서 원시 값과 객체를 분석해보자</p>\n<h2 id=\"1-원시값\" style=\"position:relative;\"><a href=\"#1-%EC%9B%90%EC%8B%9C%EA%B0%92\" aria-label=\"1 원시값 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 원시값</h2>\n<h3 id=\"11-원시값은-변경-불가능한-값이다\" style=\"position:relative;\"><a href=\"#11-%EC%9B%90%EC%8B%9C%EA%B0%92%EC%9D%80-%EB%B3%80%EA%B2%BD-%EB%B6%88%EA%B0%80%EB%8A%A5%ED%95%9C-%EA%B0%92%EC%9D%B4%EB%8B%A4\" aria-label=\"11 원시값은 변경 불가능한 값이다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.1 원시값은 변경 불가능한 값이다.</h3>\n<p>원시타입(primitive type)의 값, 원시값은 변경 불가능한 값 (immutable value) 이다.</p>\n<p>한번 생성된 원시 값은 읽기 전용(read only) 값으로서 변경할 수 없다.</p>\n<p><code class=\"language-text\">값을 변경할 수 없다?</code></p>\n<p>값은 표현식이 평가되어 생성된 결과로 메모리에 저장되어 있다. 메모리에 저장된 값은 변경 불가능하다는 뜻이다.</p>\n<p>헷갈릴 수 있는 개념에 대해 짚고 넘어가보자. 변수와 값은 구분해서 생각해야하낟.</p>\n<ul>\n<li>변수 : 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름</li>\n<li>값 : 변수에 저장된 데이터로서 표현식이 평가되어 생성된 결과</li>\n</ul>\n<p>변경 불가 하다는 것은 변수가 아니라 값에 대한 진술이다.</p>\n<p>원시값은 변경 불가능하다는 말은 <strong>원시값 자체를 변경할 수 없다</strong>는 것이지 변수 값을 변경할 수 없다는 것이 아니다.</p>\n<p>다만, <strong>변수의 값이 변경</strong>되는 것은 원시값 자체의 변화가 아닌, 재할당을 통해 <strong>새로 생성된 원시값을 변수에 할당</strong>하는 것이다. 즉 엄밀히 말해서는 변수의 값이 교체되는 것이다.</p>\n<p>그렇다면 변수의 상대개념인 상수는 어떨까?</p>\n<p>상수는 <strong>재할당이 금지된 변수</strong>이다. 상수도 값을 저장하기 위한 메모리 공간이 필요하므로 변수라고 할 수 있다. 다만 변수는 재할당을 통해 변수 값을 변경(교체)할 수 있지만 상수는 단 한번만 할당이 허용되므로 변수 값을 변경(교체)할 수 없다. 이처럼 상수는 재할당이 금지된 <strong>변수</strong>일 뿐이지, 변경 불가능한 값의 범주에 포함시키지는 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// 상수는 immutable한 값이 아닌 재할당이 금지된 변수이다.\n// 상수에 객체를 할당할 시 변경 가능하다는 예시가 있다.\n\nconst obj = {};\n\nobj.key = &#39;value&#39;;\nconsole.log(obj);\n//{key: value}</code></pre></div>\n<p><code class=\"language-text\">변수의 재할당은 어떻게 일어날까?</code></p>\n<p>원시값은 변경 불가능한 값이다. 변수에 재할당을 하게되면 원시값이 저장된 메모리공간으로 접근해서 값을 변경하는 것이 아니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var num = 10;\n//값의 재할당\nnum = 5;</code></pre></div>\n<p>num이라는 변수에 10이라는 숫자가 저장되어 있다. 5를 재할당 할 경우 10 이 저장되어 있는 메모리공간으로 접근해서 <strong>값을 변경하는 것이 아니라 새로운 메모리 공간을 확보</strong>해서 5를 저장한 후 num이라는 변수 이름을 연결해준다. 10은 가비지 컬렉터에 의해 메모리공간확보가 해제된다.</p>\n<p>이렇게 처리하는 이유는 컴퓨터 입장에서 편하기 때문이다.</p>\n<p>원시값의 이러한 특성을 불변성(immutaility)라고 한다. 불변성을 갖는 원시값을 할당한 변수는 재할당 의외에 변수 값을 변경할 수 있는 방법이 없다.</p>\n<h3 id=\"12-문자열과-불변성\" style=\"position:relative;\"><a href=\"#12-%EB%AC%B8%EC%9E%90%EC%97%B4%EA%B3%BC-%EB%B6%88%EB%B3%80%EC%84%B1\" aria-label=\"12 문자열과 불변성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.2 문자열과 불변성</h3>\n<p>원시값을 메모리 공간에 저장하기 위해서는, <strong>확보해야 하는 메모리 공간의 크기를 결정해야한다</strong>. 원시타입 별로 확보해야하는 메모리 공간의 크기가 정해져 있는 것이다. ECMAScript 사양을 보면 문자열 타입 (2byte)와 숫자타입(8byte)는 메모리공간의 크기가 명시되어있는 반면에 다른 원시타입은 명시 되어있지 않고 브라우저 제조사의 구현에따라 다를 수 있다.</p>\n<p>문자열 값은 다른 원시값과 비교해 독특한 특징이 있다.</p>\n<ul>\n<li>문자열은 0개 이상의 문자(character)로 이뤄진 집합이다.</li>\n<li>1개의 문자는 2byte의 메모리 공간에 저장된다.</li>\n<li>문자열은 몇 개의 문자로 이뤄졌느냐에 따라 필요한 메모리 공간의 크기가 결정된다.</li>\n</ul>\n<p>즉, 문자열은 확보해야하는 메모리공간의 크기가 고정된 다른 원시값과 다르게 <strong>문자의 개수에 따라 확보되는 메모리공간의 크기가 다르다</strong>. 1개의 문자로 된 문자열은 2byte, 5개의 문자로 이뤄진 문자열은 10byte가 필요하다.(실제 계산은 다르긴하다.)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var str1 = &#39;&#39;;\nvar str2 = &#39;jiman&#39;;\n//필요한 메모리 공간의 크기가 다르다.</code></pre></div>\n<p>C와 자바에서는 문자열 데이터 타입이 따로 없다.</p>\n<p>c에서는 문자타입(char)들의 배열로 문자열을 처리하고, 자바에서는 String 객체로 문자열을 처리한다.</p>\n<p>자바스크립트에서는 string이라는 데이터 타입을 제공하는 것이다. 데이터의 신뢰성을 보장하는, 자바스크립트의 장점이다.</p>\n<p>원시타입인 문자열 역시 변경 불가능하다.</p>\n<p>문자열에는 독특한 특징이 하나 더 있는데 바로 유사 배열 객체 (array-like-object)라는 것이다.</p>\n<p><strong>유사 배열 객체란?</strong></p>\n<p>배열 처럼 인덱스로 프로퍼티 값에 접근할 수 있으며, length 프로퍼티를 갖는 객체이다.</p>\n<p>즉 문자열은 인덱스로 각 문자 하나하나 에 접근할 수 있고 length 프로퍼티도 갖는다. for 문으로 순회하는 것도 가능하다.</p>\n<p>다만 원시값인 문자열을 객체처럼 사용하면 원시값을 감싸는 래퍼 객체로 자동 변환된다.</p>\n<p><strong>문자열은 변경 불가능한 원시값이다.</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var str = &#39;jiman&#39;;\nstr[0] = &#39;J&#39;;\nconsole.log(str[0]);\n//jiman\n\n//원시값이기때문에 개별문자의 변경이 불가하다.</code></pre></div>\n<h3 id=\"13-값에-의한-전달pass-by-value\" style=\"position:relative;\"><a href=\"#13-%EA%B0%92%EC%97%90-%EC%9D%98%ED%95%9C-%EC%A0%84%EB%8B%ACpass-by-value\" aria-label=\"13 값에 의한 전달pass by value permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.3 값에 의한 전달(pass by value)</h3>\n<p>어떤 변수에 기존에 원시값을 할당했던 변수를 할당하면 어떻게 될까?</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var original = 10;\nvar copy = original;\n\nconsole.log(original, copy);// 10 10\n\noriginal = 20;\n\nconsole.log(original, copy); 20 10</code></pre></div>\n<p>copy에 original을 할당할때 original이 10으로 평가되어 새로운메모리 공간을 확보하고 10을 저장한 후 copy를 연결한다. 즉, copy에는 original의 원시값이 복사되어 전달된다. 이를 값에의한전달 이라고 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var original = 10;\nvar copy = original;\n\nconsole.log( original, copy); // 10 10\nconsole.log(original === copy); // true\n\norignal = 20;\nconsole.log( original === copy); // false</code></pre></div>\n<p>original 과 copy는 평가되었을때 동일한 숫자 값이지만, 두 값을 저장한 메모리공간의 위치는 다르다. 즉 orignal과 copy에 저장된 값은 별개의 값이다.</p>\n<p>ECMAScript 사양에 변수를 통한 메모리 관리가 명확히 정의되지 않아서 값에 의한 전달시 두가지 경우가 있을 수 있다.</p>\n<ul>\n<li>식별자를 할당했을때 같은 원시값을 참조하였다가 재할당시 새로운 생성값을 참조</li>\n<li>식별자 할당시부터 새로운 메모리공간 생성후 평가값저장후 참조</li>\n</ul>\n<p>파이썬은 전자처럼 동작한다고 한다. 할당 시점에 두 변수가 기억하는 메모리주소가 같느냐 다르냐이다.</p>\n<p><strong>중요한것은 두 변수의 원시값이 결국엔 서로다른 메모리 공간에 저장된 다는 것이다.</strong> 서로 간섭하지 않는다.</p>\n<h2 id=\"2-객체\" style=\"position:relative;\"><a href=\"#2-%EA%B0%9D%EC%B2%B4\" aria-label=\"2 객체 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 객체</h2>\n<p>객체 값을 생성할때 메모리공간의 크기는 어떻게 될까?</p>\n<p>객체는 다음과 같은 특징이있다.</p>\n<ul>\n<li>객체는 프로퍼티의 개수가 고정되어 있지 않고, 동적으로 추가되고 삭제될 수 있다.</li>\n<li>프로퍼티 값에 제약이 없다.</li>\n<li>즉, 원시값과 같이 확보해야할 메모리 공간의 크기를 사전에 정해 둘 수 없다.</li>\n</ul>\n<p>객체는 복합적인 자료구조이다. 원시값과 비교하였을 때 복잡하고 브라우저 제조사마다 구현방식이 다를 수 있댜. 소비하는 메모리가 상대적으로 적은 원시값에 비해, 객체는 소비하는 메모리가 경우에 따라 매우 클 수 있다.</p>\n<p>객체를 생성하고 프로퍼티에 접근하는 것도 원시값과 비교할 때 비용이 많이든다.</p>\n<h3 id=\"21-객체는-변경-가능한-값이다\" style=\"position:relative;\"><a href=\"#21-%EA%B0%9D%EC%B2%B4%EB%8A%94-%EB%B3%80%EA%B2%BD-%EA%B0%80%EB%8A%A5%ED%95%9C-%EA%B0%92%EC%9D%B4%EB%8B%A4\" aria-label=\"21 객체는 변경 가능한 값이다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1 객체는 변경 가능한 값이다.</h3>\n<p>객체는 변경 가능한 값(mutable value) 이다. 변수에 원시값을 할당하면, 변수를 통해 해당 메모리공간에 저장된 값으로 직접 접근한다. 하지만, 객체를 할당한다면, 변수를 통해서 <strong>참조값(reference value)</strong>에 접근한다.</p>\n<p>참조값은 <strong>객체가 저장된 메모리공간의 메모리 주소</strong>이다. 이 참조값을 통해 객체가 저장된 메모리공간에 접근할 수 있다. 그래서 원시값을 할당한 변수의 경우 변수는 ~~값을 갖는다 라고 표현하지만, 객체의 경우 변수는 객체를 가리키고(point) 있다 라고 표현한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var object = {\n\tkey: &#39;value&#39;\n}\n//변수 objdect 는 객체{key: &#39;value&#39;}를 가리키고(참조하고) 있다.</code></pre></div>\n<p>변수의 값을 변경해보자. 원시값은 재할당 외에는 방법이 없다.</p>\n<p>하지만 객체는 변경 가능한 값이므로 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있다.</p>\n<ul>\n<li>프로퍼티 동적 추가</li>\n<li>프로퍼티 값 갱신</li>\n<li>프로퍼티 삭제</li>\n</ul>\n<p>위 사항 모두 가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var object = {\n\tkey: &#39;value&#39;\n}\n//object 변수에 객체 할당\n\n//프로퍼티 키 동적 추가\nobject.addedKey=&#39;value1&#39;;\n\n//프로퍼티 값 갱신\nobject.key = &#39;modifiedValue&#39;;\n\nconsole.log(object);\n//{ key: &#39;modifiedValue&#39;, addedKey: &#39;value1&#39; }</code></pre></div>\n<p>변수에는 객체의 참조값이 할당되어 있다. 프로퍼티 값을 조작할때 변수에 재할당은 하지 않았으므로 변수의 참조값이 변경되지않는다.</p>\n<p>객체가 새로이 생성되지 않고 변경가능하게 설계된 이유는 무엇일까?</p>\n<p>객체를 생성하고 관리하는 방식이 복잡하고 비용이 많이 드는일이다. 객체는 크기가 매우 클 수도 있고 원시값처럼 크기가 일정하지도 않으며 프로퍼티 값이 객체일 수 도있다. 그렇기때문에 복사해서 생성하는 비용이 많이든다. 메모리의 효율적 소비가 어렵고 성능이 나빠진다.</p>\n<p>그렇기때문에 원시값 처럼 이전값을 복사해서 새롭게 생성하지 않는다. 객체는 메모리를 효율적으로 사용하고, 복사 및 생성비용을 절약하기 위해 변경가능한 값으로 설계되어 있다. 데이터의 신뢰성이 원시값에 비해 떨어지지만, 메모리 사용의 효율성과 성능을 고려한 것이다.</p>\n<p>결론적으로 메모리 관점에서 효율성을 얻었지만 구조적인 단점도 가지고 있다.</p>\n<p>이러한 단점에 따른 부작용이 있다.</p>\n<p>바로 여러 개의 식별자가 하나의 객체를 공유할 수 있다는 것이다.</p>\n<p>얕은 복사와 깊은 복사의 개념을 짚고 넘어가자.</p>\n<p>객체의 프로퍼티 값으로 객체를 가지고 있다고 했을 때,</p>\n<ul>\n<li>얕은복사 : 한단계 까지만 복사하는 것을 말한다.</li>\n<li>깊은복사 : 객체에 중첩되어 있는 객체 까지 복사하는 것</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const o = {\n\ta: {\n\t\tb: 2\n\t},\n\tf(){}\n};\n\n// 얕은 복사1\nlet c = { ...o}; // 35. 스프레드 문법에 있다고 한다.\nconsole.log(o===c); //false\nconsole.log(o.a === c.a); // true\n// 한단계까지는 복사 하였지만 내부의 객체는 참조값을 전달했다.\n\n//얕은 복사2\nc = Object.assign({},o);\nconsole.log(o === c); // false\nconsole.log(o.a === c.a); // true\n// 마찬가지로 한단계까지 복사하고 내부의 객체는 참조값을 전달\n\n// 깊은복사 1\n// JSON.parse 와 JSON.stringify를 사용한 깊은복사\nc = JSON.parse(JSON.stringify(o));\nconsole.log(o === c); // false\nconsole.log(o.a === c.a); // false\n// 메서드가 사라지는 문제가있다.\nconsole.log(c.f);// undefined\n\n// 깊은 복사 2\n// &quot;npm install lodash&quot;로 lodash를 설치한 후, Node.js 환경에서 실행\nconst _ = require(&#39;lodash&#39;);\n\nc = _cloneDeep(o);\nconsole.log( o === c); false\nconsole.log( o.a === c.a); //false\nconsole.log(c.f); // f</code></pre></div>\n<p>참고로, <strong>원시값을 할당한 변수를 다른 변수에 할당</strong>하는 것을 깊은복사, <strong>객체를 할당한 변수를 다른변수에 할당</strong>하는 것을 얕은 복사라고 하는 경우도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//깊은 복사\nconst v = 1;\nconst c1 = v;\nconsole.log(c1 === v); // true\n\n//얕은 복사\nconst o = { x: 1};\nconst c2 = o;\nconsol.log(c2 === o); //true</code></pre></div>\n<h3 id=\"22-참조에-의한-전달\" style=\"position:relative;\"><a href=\"#22-%EC%B0%B8%EC%A1%B0%EC%97%90-%EC%9D%98%ED%95%9C-%EC%A0%84%EB%8B%AC\" aria-label=\"22 참조에 의한 전달 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.2 참조에 의한 전달</h3>","frontmatter":{"title":"javascript 11primitiveValue vs objectValue","date":"September 01, 2020"}}},"pageContext":{"slug":"/javascript/javascript-11primitiveValue-vs-objectValue/","previous":{"fields":{"slug":"/javascript/javascript-ASCII-Unicode/"},"frontmatter":{"title":"javascript ASCII, Unicode","category":"javascript","draft":false}},"next":{"fields":{"slug":"/javascript/javascript-control-flow-exercise/"},"frontmatter":{"title":"javascript control-flow-exercise","category":"javascript","draft":false}}}},"staticQueryHashes":["2486386679","3128451518"]}